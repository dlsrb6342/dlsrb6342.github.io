{"meta":{"title":"Ododododo","subtitle":null,"description":null,"author":"Ingyu Hwang","url":"https://dlsrb6342.github.io"},"pages":[{"title":"all-categories","date":"2021-01-30T08:34:59.289Z","updated":"2021-01-30T08:34:59.289Z","comments":false,"path":"all-categories/index.html","permalink":"https://dlsrb6342.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2021-01-30T08:34:59.289Z","updated":"2021-01-30T08:34:59.289Z","comments":false,"path":"all-tags/index.html","permalink":"https://dlsrb6342.github.io/all-tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-01-30T08:34:59.288Z","updated":"2021-01-30T08:34:59.288Z","comments":true,"path":"about/index.html","permalink":"https://dlsrb6342.github.io/about/index.html","excerpt":"","text":"About"}],"posts":[{"title":"Spring Cloud Stream with Spring Cloud Dataflow","slug":"Spring-Cloud-Stream-with-Spring-Cloud-Dataflow","date":"2021-02-07T07:25:32.000Z","updated":"2021-02-07T09:38:56.270Z","comments":true,"path":"2021/02/07/Spring-Cloud-Stream-with-Spring-Cloud-Dataflow/","link":"","permalink":"https://dlsrb6342.github.io/2021/02/07/Spring-Cloud-Stream-with-Spring-Cloud-Dataflow/","excerpt":"","text":"최근 회사에서 spring cloud dataflow 상에서 spring cloud stream을 사용하기로 결정해 여러가지 삽질을 한 것을 정리해보려 한다. 굉장히 다양한 삽질을 했으나 몇가지만 정리해보려고 한다. Functional Stylespring cloud stream app은 Functional Style, Annotation Based Style 2가지 방식으로 정의할 수 있다.Annotation Based Style로 작성하였을때는 정말 아무 문제없이 처리되었지만.. Functional Style로 바꾸니 바로 동작하지 않았다. https://cloud.spring.io/spring-cloud-stream/reference/html/spring-cloud-stream.html#spring_cloud_function https://cloud.spring.io/spring-cloud-stream/reference/html/spring-cloud-stream.html#_annotation_based_support_legacy 12345678910111213141516171819// Annotation Based Style@SpringBootApplication@EnableBinding(Processor.class)public class SampleStreamApplication &#123; @StreamListener(Sink.INPUT) @SendTo(Source.OUTPUT) public String toUpperCase(String str) &#123; return str.toUpperCase(); &#125;&#125;// Functional Style@SpringBootApplicationpublic class SampleStreamApplication &#123; @Bean public Function&lt;String, String&gt; toUpperCase() &#123; return str -&gt; str.toUpperCase(); &#125;&#125; 원인원인부터 말하면 Annotation Based Style로 stream app을 작성했을때는 binding의 기본 이름이 input, output으로 정해지지만 Functional Style은 정의한 Function의 이름에 따라 달라진다. 이 부분에 대해 부가 설명을 하자면.. Annotation Based Style에 쓰이는 @StreamListener와 @SendTo annotation에 들어가는 값에 따라 binding의 이름이 정해지는데 보통 Sink.INPUT, Source.OUTPUT을 사용하기 때문에 기본 이름이라 칭했다. Functional Style 는 동작하지 않았다라고 한 것은 사실 spring-cloud-dataflow에 올렸을 경우에 동작하지 않는다는 것을 의미한다. spring-cloud-dataflow의 경우, stream app의 input, output binding을 input, output이라는 값으로 정해져있다고 가정하고 app을 구동하기 때문에 이런 경우가 발생하는 것으로 파악했다. 해결책해결책은 간단했다. application.yml에 binding의 이름을 정해주면 된다. 위 예시 코드에서는 Function의 이름이 toUpperCase이므로 input binding은 toUpperCase-in-0, output binding은 toUpperCase-out-0으로 생성되었을 것이다. 이걸 input, output으로 바꿔주기만 하면 된다. 나중에 본 것이지만 spring-cloud-dataflow-samples에 예시가 잘 되어있었다.. ㅠㅠ1234// application.ymlspring.cloud.stream.function.bindings: toUpperCase-in-0: input toUpperCase-out-0: output Header EncodingStream Sample App 중에 header enricher라는 App이 있다. 입력한 SpEL에 따라 kafka record header에 값을 추가해주는 App인데 이 App을 통해 필요한 값을 헤더에 넣어주곤 했는데 stream definition을 따라 잘 전달되다가 어느 앱만 지나면 String으로 잘 전달되던 헤더 값이 byte[]로 표현됐다. 원인Dependencies Version의 문제였다. 내가 사용 중인 Kubernetes Cluster는 1.15.X 버전이기에 spring cloud dataflow는 2.5.3을 설치해서 사용했다. 또 spring cloud dataflow 2.5.3을 사용했기 때문에 spring cloud는 Hoxton.SR4를 사용했다. https://dataflow.spring.io/docs/installation/kubernetes/compatibility/ https://github.com/spring-cloud/spring-cloud-dataflow/releases/tag/v2.5.3.RELEASE 이렇게 해서 버전을 다 맞춰 문제가 없을 줄 알았으나.. spring cloud dataflow 2.5.3을 설치해서 import 해둔 Sample App들의 버전이 문제였다.내가 만든 Stream App들은 spring cloud Hoxton.SR4에 포함된 spring cloud stream 3.0.4.RELEASE를 사용했지만 미리 import된 Sample App들은 2.1.X 버전을 사용하고 있었다. 여기서 버전 차이로 인해 BinderHeaderMapper의 구현에 차이가 있었다. 그래서 하위 버전앱에서 추가된 헤더를 상위버전앱에서 제대로 읽지 못하는 이슈가 있는 것 같다. 해결책해결책으로는 3.0.X Version의 Sample App을 빌드하는 것과 하위 버전 앱을 원하는 버전으로 직접 빌드하는 것, 두가지가 있다. Stream Sample App들은 2.1.X와 3.0.X가 다른 레포지토리에 관리되고 있다. 이걸 찾는 것도 힘들었다 ㅠㅠ 3.0.X : https://github.com/spring-cloud/stream-applications 2.1.X : https://github.com/spring-cloud-stream-app-starters 첫 번째 방법인 3.0.X Version을 사용하려면 Release Tag에서 spring-cloud-datflow에 Bulk Import할 수 있는 url / file을 얻을 수 있다. 간단히 Import해서 사용하기만 하면 된다. 두 번째 방법인 직접 하위 버전 앱을 빌드하는 방법은 아래와 같이 dependencies를 추가하고 Configuration만 import해주면 된다.1234567891011121314&#x2F;&#x2F; 예시로 aggregator app을 빌드해보겠다.&#x2F;&#x2F; build.gradledependencies &#123; implementation &#39;org.springframework.cloud.stream.app:spring-cloud-starter-stream-processor-aggregator:2.1.5.RELEASE&#39;&#125;&#x2F;&#x2F; AggregatorApplication.java@SpringBootApplication@Import(AggregatorProcessorConfiguration.class)public class AggregatorApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AggregatorApplication.class, args); &#125;&#125; Headers with Reactor https://docs.spring.io/spring-cloud-stream/docs/3.1.1/reference/html/spring-cloud-stream.html#_reactive_functions_support Stream Application은 Reactor를 사용해서 Reactive Programming model로 작성할 수 있다.이 예시로 위에 말한 sample app 중에 httpclient(http-request)를 살펴보면 2.1.X의 httpclient는 내부에서 RestTemplate bean을 생성해서 요청을 보내고 있고 http-request-processor는 WebClient를 사용하고 있다. 2.1.X : https://github.com/spring-cloud-stream-app-starters/httpclient 3.0.X : https://github.com/spring-cloud/stream-applications/tree/master/applications/processor/http-request-processor 그런데 reactor를 사용해 Function을 작성했을때 Header가 다음 App으로 전달되지 않았다. 원인아쉽게도 이 문제는 아직 원인을 파악하지 못했다. 내부의 Message build하는 로직을 많이 들여다봤는데도 Reactor로 되어있다보니 Debugging이 쉽지가 않았다.아마 Message build 과정에서 헤더는 복사되지 않고 build하고 있는 것 같다. 원인을 아시는 분은 제보 부탁드립니다… ㅋㅋ 해결책원인을 못 찾았기 때문에 해결책이 깔끔하지는 않다. Message Build가 문제되는 것 같으니 직접 Message를 build했다. 이렇게 하면 다음 Stream으로 문제없이 헤더가 잘 전달된다.1234567891011@SpringBootApplicationpublic class SampleStreamApplication &#123; @Bean public Function&lt;Flux&lt;Message&lt;String&gt;&gt;, Flux&lt;Message&lt;String&gt;&gt;&gt; reactiveToUpperCase() &#123; return messageFlux -&gt; messageFlux .map(message -&gt; &#123; String payload = message.getPayload(); return MessageBuilder.createMessage(payload.toUpperCase(), message.getHeaders()); &#125;); &#125;&#125; Stream App TestStream App은 Kafka 혹은 RabbitMQ를 필요로 한다. 물론 테스트를 위해 TestContainer 혹은 Embedded Kafka 같은 방법을 선택할 수 있지만 여러 제한이 있어 사용하지 못했다. 그래서.. 테스트할 방법을 찾아야만 했다. 이번 삽질은 딱히 원인/해결책은 없고 Stream App을 테스트하는 방법을 소개하려고 한다. Stream Sample Apps에서 사용하고 있는 테스트 방법을 사용했다. Kafka / RabbitMQ가 아닌 spring-cloud-stream의 test 구현체인 TestBinder를 사용하는 방법이다. https://github.com/spring-cloud/stream-applications/blob/1e6a2e1f44f12619d4522e97a9f5e5869461cd8f/applications/stream-applications-core/pom.xml#L83-L89 maven에서는 위 링크와 같이 넣어주면 되지만 gradle은 아래와 같이 하면 된다. gradle을 많이 사용해보지 않는 나로서는 이것도 꽤나 찾기 힘들었다 ㅠㅠ123dependencies &#123; testImplementation group: &#x27;org.springframework.cloud&#x27;, name: &#x27;spring-cloud-stream&#x27;, classifier: &#x27;test-binder&#x27;&#125;test-binder를 사용한 toUpperCase App에 대한 간단한 테스트 코드는 아래와 같다.12345678910111213141516171819202122class SampleStreamApplicationTest &#123; @Test void test_toUpperCase() &#123; try (ConfigurableApplicationContext context = new SpringApplicationBuilder( TestChannelBinderConfiguration.getCompleteConfiguration(SampleStreamApplication.class)) .web(WebApplicationType.NONE) .run()) &#123; InputDestination processorInput = context.getBean(InputDestination.class); OutputDestination processorOutput = context.getBean(OutputDestination.class); String testStr = &quot;test&quot;; final Message&lt;Map&lt;String, String&gt;&gt; message = MessageBuilder.withPayload(testStr) .build(); processorInput.send(message); Message&lt;byte[]&gt; output = processorOutput.receive(); assertEquals(testStr.toUpperCase, new String(output.getPayload())); &#125; &#125;&#125; spring cloud dataflow가 Task / Stream / Batch 를 관리하고 실행할 수 있다는 점에서 굉장히 좋아보여 사용하기로 했는데 생각보다 Reference가 부족해 조금 어려움을 겪었다. 전체적인 개념을 이해하는데에 시간이 오래 걸리긴 했지만 공식문서가 굉장히 잘 되어있어 도움이 됐다. 영어로 되어있더라도 건너뛰지 않아야겠다.앞으로 spring cloud dataflow / spring cloud stream을 더 많이 사용할테니 삽질은 더 많아질 예정이다..","categories":[{"name":"spring-cloud-stream","slug":"spring-cloud-stream","permalink":"https://dlsrb6342.github.io/categories/spring-cloud-stream/"},{"name":"spring-cloud-dataflow","slug":"spring-cloud-stream/spring-cloud-dataflow","permalink":"https://dlsrb6342.github.io/categories/spring-cloud-stream/spring-cloud-dataflow/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://dlsrb6342.github.io/tags/spring/"},{"name":"spring-cloud","slug":"spring-cloud","permalink":"https://dlsrb6342.github.io/tags/spring-cloud/"}]},{"title":"Gradle Multi Project with Multiple version of plugin","slug":"Gradle-Multi-Project-with-Multiple-version-of-plugin","date":"2021-01-30T06:58:19.000Z","updated":"2021-01-30T08:34:59.227Z","comments":true,"path":"2021/01/30/Gradle-Multi-Project-with-Multiple-version-of-plugin/","link":"","permalink":"https://dlsrb6342.github.io/2021/01/30/Gradle-Multi-Project-with-Multiple-version-of-plugin/","excerpt":"","text":"gradle에서 spring boot dependencies 버전은 org.springframework.boot plugin으로 관리된다. 그런데 plugin의 경우 rootProject에서 버전을 명시해버리면 하위 프로젝트에서 버전을 변경해서 적용할 수 없다. 이 점 때문에 gradle에서 한가지 plugin을 다양한 버전으로 사용하는 것은 조금 불편하다..123456789101112. # 전체 프로젝트는 2.4.1├── build.gradle├── bar│ └── build.gradle├── foo│ └── build.gradle└── streams # streams 이하 모듈은 2.2.7.RELEASE ├── build.gradle ├── stream-baz │ └── build.gradle └── stream-qux └── build.gradle 이번 새 프로젝트는 특정 모듈에서만 spring boot 버전이 다르게 사용해야 하는 요구사항이 있었다. 위 프로젝트 구조에서 streams 아래 모듈에서만 2.2.7.RELEASE 버전의 spring boot를 사용해야 했다(나중에 글을 쓸 예정이지만 spring-cloud-dataflow를 사용하면서 어쩔 수 없는 상황이었다 ㅠㅠ). 대충 요구사항을 정리해보자면.. spring-boot 버전은 streams에서는 2.2.7.RELEASE를, 나머지 모듈에서는 2.4.1을 사용한다. Library/Plugin의 버전 관리는 하나의 파일에서 혹은 정리된 형태로 보기 쉽게 한다. 이 요구사항을 충족시키기 위해 몇가지 방법을 찾고 적용해봤다. 1. Plugin Version in classpath첫 번째 방법은 classpath로 plugin version을 선언해두는 것이다.12345678910111213141516171819202122232425262728// libraries.gradleext.version = [ springBoot: &#x27;2.4.1&#x27;, ...]ext.libraries = [ classpath: [ springBootPlugin: &quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;ext.version.springBoot&#125;&quot;, ], dependency: [ .... ]]ext.streamsVersion = [ springBoot: &#x27;2.2.7.RELEASE&#x27;, ...]ext.streamsLibraries = [ classpath: [ springBootPlugin: &quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;ext.streamsVersion.springBoot&#125;&quot; ], dependency: [ ... ]]1234567891011121314151617//rootProject build.gradlesubprojects &#123; apply from: &quot;$&#123;rootDir&#125;/libraries.gradle&quot; buildscript &#123; dependencies &#123; if (project.displayName.contains(&quot;streams&quot;)) &#123; classpath &quot;$&#123;project.ext.streamsLibraries.classpath.springBootPlugin&#125;&quot; &#125; else &#123; classpath &quot;$&#123;project.ext.libraries.classpath.springBootPlugin&#125;&quot; &#125; &#125; &#125;&#125;// sub module builld.gradleapply plugin: &#x27;org.springframework.boot&#x27;이렇게 선언해놓으면 sub module들에서 plugin을 적용하기만 해도 원하는 버전으로 적용시킬 수 있다. 장점 libraries.gradle에서 모든 버전 및 라이브러리 관리할 수 있다. sub module에서는 버전에 대해 신경쓰지 않고 모든 것을 root project가 관리할 수 있다. 단점 plugin 적용 방법이 새로운 형식(plugins &#123; id &#39;ID&#39; &#125;)이 아닌 오래된 형식(apply plugin &#39;ID&#39;)을 사용해야 한다. 결론오래된 형식의 plugin 적용 방법을 사용하고 싶지 않아서 이 방법은 버려졌다. 물론 subproject, allproject에서는 plugins는 사용할 수 없고 apply plugin을 사용해야 한다. (https://stackoverflow.com/a/32353244/7018283) 2. pluginManagement https://docs.gradle.org/current/userguide/plugins.html#sec:plugin_management gradle에서 plugin 버전을 관리할 수 있는 방법을 공식적으로 지원한다. 그런데 이 방법은 무조건 setting.gradle 파일의 가장 처음에 작성되거나 init scripts 파일에 작성되어야 한다. 결론하지만 이 방법으로는 내가 원하는 모듈 별로 서로 다른 버전의 plugin을 적용할 수는 없는 것 같다(할 수 있지만 방법을 못 찾은것일수도..). 만약 전체 프로젝트에서 version을 한가지만 사용하고 있다면 공식적으로 지원하는 방법이니 이걸 택했을 것 같다. 3. gradle.properties에 plugin 버전 선언이 방법은 plugin 버전을 libraries.gradle이 아닌 gradle.properties에 선언하는 방법이다. plugins 블록에서 버전을 변수로써 작성하려면 libraries.gradle에 선언한것은 동작하지 않고 gradle.properties에 선언되어 있어야 동작하기 때문이다. 123// gradle.propertiesspringBootVersion=2.4.1springBootVersionForStreams=2.2.7.RELEASE 123456789// foo/build.gradleplugins &#123; id &#x27;org.springframework.boot&#x27; version &quot;$&#123;springBootVersion&#125;&quot;&#125;// streams/build.gradleplugins &#123; id &#x27;org.springframework.boot&#x27; version &quot;$&#123;springBootVersionForStreams&#125;&quot;&#125; 장점 plugins 블록을 사용하여 plugin을 적용할 수 있다. 버전 관리를 gradle.properties에서 할 수 있다. 단점 각 모듈에서 plugin을 적용할 때 항상 version을 명시해주어야 한다. dependencies 관리는 libraries.gradle, plugin 관리는 gradle.properties로 나뉜다. 사실 이 점은 gradle.properties에 모두 맡겨도 된다. 결론plugins 블록을 사용할 수 있다는 점과 버전 관리를 하나의 파일에서 할 수 있다는 점을 이유로 이 방법을 택했다. 항상 maven만 사용해오다가 gradle을 큰 프로젝트에 사용해본 것은 처음이었는데 maven보다 자유도가 높은 느낌이었다. 그렇다보니 유명한 큰 오픈소스 프로젝트를 봐도 제각기 사용하는 방식이 달랐다. 이런 점이 gradle의 장점이기도 하고 단점이기도 한 것 같다. Reference https://medium.com/@jsuch2362/gradle-dependency-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0-eb0c7c794b9c https://gradle.org/","categories":[{"name":"gradle","slug":"gradle","permalink":"https://dlsrb6342.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://dlsrb6342.github.io/tags/gradle/"}]},{"title":"Make git-branchcut with Go lang","slug":"Make-git-branchcut-with-Go-lang","date":"2021-01-16T07:29:02.000Z","updated":"2021-01-30T08:34:59.228Z","comments":true,"path":"2021/01/16/Make-git-branchcut-with-Go-lang/","link":"","permalink":"https://dlsrb6342.github.io/2021/01/16/Make-git-branchcut-with-Go-lang/","excerpt":"","text":"https://github.com/dlsrb6342/git-branchcut 업무/개인프로젝트/오픈소스 등에서 git을 사용하다 보니 나도 모르는새에 프로젝트마다 브랜치가 엄청 쌓여있었다. 이것들을 한번에 싹 지워버리고 싶었는데 내가 원하는 옵션으로 없앨 수 있는 방법을 찾지 못해 직접 만들었다. Git Add-Ongit addon으로 만들어서 git [name] [option] 이런식으로 사용하고 싶었다. 하지만 어떻게 만들고 어떻게 배포해야 할지 막막했기에 awesome-git-addons에서 다른 프로젝트들을 많이 참고했다. 무언가 필요할때 awesome을 붙여 검색하면 친절히 정리해둔 repository가 많이 있다. :) Go lang참고했던 프로젝트들은 python, shell script, js, go 등 다양한 언어로 작성되어있었다.이중에 난 예전부터 관심있었던 Go lang을 선택했다 (https://youtu.be/LJvEIjRBSDA 이걸 보고 관심이 생겼다). 지금 생각해보면 여러 언어 중에 Go lang을 선택한건 굉장히 좋은 선택이었다. 다른 언어들에 대해 많이 알아보지는 않았지만 cobra와 goreleaser는 내겐 혁명이었다. Cobra https://cobra.dev/ Cobra는 Go lang의 CLI Framework이다. Subcommand / Flag 등 정말 간단한 작업으로 내가 만들었나 싶을정도로 Modern한 CLI를 만들어준다. Kubernetes, Helm, Github CLI 등 굉장히 다양한 프로젝트에서 Cobra 를 사용 중이다. Subcommand의 Subcommand, 즉 Nested Subcommand도 지원한다. Global / Local / Cascading 등 Flag의 Scope을 지원한다. 내가 command/flag마다 설명을 넣어둔다면 help를 자동생성해준다. 예시 코드는 git-branchcut을 봐도 되고 공식 홈페이지 설명이 자세히 되어있다. 내가 해본 CLI App들은 학부생 때 열심히 손으로 직접 만든 C언어 프로그램 밖에 없어서 그런지, Cobra를 써보고 많이 놀랐다. 물론 내가 Cobra를 깊게 사용해보진 않았지만 굉장히 강력한 프레임워크으로 보인다. 만약 Go로 CLI를 만든다고 한다면 사용하지 않을 이유가 없는 것 같다. Goreleaser https://goreleaser.com/ Goreleaser는 Go lang project의 release automation 툴이다. 모든 설정은 .goreleaser.yml에 저장된다. 설치나 실행방법, 피쳐들은 너무 내용이 많아 다 설명할 수 없으니 Goreleaser 공식 홈페이지를 참고하면 될 것 같다. Cobra를 처음 썼을 때와 비슷한 느낌을 받았다. 너무 편하고 쉽다. 처음 git-branchcut을 만들 때 만들기는 하는데 다른 사람들이 사용할 수 있게 어떻게 배포할까 라는 고민을 많이 했다.그 고민들이 무색하게 Goreleaser는 config 몇줄 수정/추가하고 goreleaser만 입력해주면 Release Note, Executable files, Homebrew-tap recipe를 모두 만들어준다. git-branchcut을 사용하고 싶어하는 사람들이 이젠 쉽게 Executable files를 받을 수 있고 혹은 Homebrew를 통해서 설치할 수 있게 된 것이다. git-branchcut이제 내가 만든 git branchcut에 대해서 설명하려고 한다. 내가 원하는 기능은 딱 2가지였다. Outdated branch, 즉 새로운 커밋이 생긴지 오래된 브랜치 삭제. Pattern, Branch 이름의 pattern으로 삭제. 그래서 git branchcut은 일단 두가지 옵션을 제공한다. 지극히 내 요구사항에 의해 만들었으니..ㅎㅎ12345678910111213141516&gt; git branchcut execute --helpCut branchesUsage: branchcut execute [flags]Flags: -o, --day-offset int Day offset. Branches that is committed before day offset would be deleted --dry-run Only print branch list that would be delete, without deleting it. --force Allow deleting the branch irrespective of its merged status. -h, --help help for execute -m, --main-branch string Default branch name (default &quot;main&quot;) -p, --pattern string Pattern for branch nameGlobal Flags: -g, --executable-git-path string The git executable to use (default &quot;git&quot;)--day-offset으로 며칠 전 커밋된 브랜치를 살릴지 정할 수 있다. 예를 들어 --day-offset 7로 했다면 마지막 커밋이 7일 이내에 있는 브랜치만 살아남는다.--pattern으로 브랜치 이름의 Pattern을 지정할 수 있다. --pattern &quot;feature/*&quot;로 설정하면 “feature/“로 시작하는 브랜치들은 삭제된다. 두가지 옵션 모두 입력하였다면 두 조건을 모두 만족하는 브랜치만 삭제된다. 이 프로젝트를 하면서 Go lang을 처음 사용하였는데 책을 보면서 공부하거나 심도있게 사용한 것은 아니어도 어렵지 않은 언어라는 느낌을 받았다. 나중에 만약 언어의 선택이 자유롭고 새로운 것을 도전하고 싶다면 Go lang을 선택할 것 같다. 이로써 내 로컬 git project들의 브랜치들은 깨끗하게 정리되었다!","categories":[{"name":"go","slug":"go","permalink":"https://dlsrb6342.github.io/categories/go/"},{"name":"git","slug":"go/git","permalink":"https://dlsrb6342.github.io/categories/go/git/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dlsrb6342.github.io/tags/go/"}]},{"title":"Resilience4j RateLimiter","slug":"Resilience4j-RateLimiter","date":"2019-12-11T15:43:22.000Z","updated":"2021-01-30T08:34:59.263Z","comments":true,"path":"2019/12/12/Resilience4j-RateLimiter/","link":"","permalink":"https://dlsrb6342.github.io/2019/12/12/Resilience4j-RateLimiter/","excerpt":"","text":"Resilience4j RateLimiterRateLimiter 패턴이란 일정 시간동안의 요청의 수를 제한하는 것이다. 자세한 내용은 생략한다. Token Bucket wiki와 Java token-bucket 구현체를 보면 도움이 될 것이다. AtomicRateLimiterresilience4j의 RateLimiter는 AtomicRateLimiter와 SemaphoreRateLimiter 2가지로 구현되어있는데 default로 AtomicRateLimiter를 사용한다. AtomicRateLimiter는 RateLimiter가 생성된 시점부터의 모든 nanosecond를 cycle로 나눈다. CycleCycle은 RateLimiterConfig.limitRefreshPeriod 값만큼의 Duration을 가진다. RateLimiter는 각 Cycle이 시작할때마다 active permission의 수를 RateLimiterConfig.limitForPeriod 값으로 설정해준다.호출하는 입장에서 바라봤을 때는 매 Cycle마다 active permission을 바꿔주는 것으로 보이겠지만 resilience4j의 AtomicRateLimiter는 RateLimiter를 사용하지 않는동안에는 refresh를 skip하는 성능 최적화가 되어있다. StateAtomicRateLimiter는 내부에서 State 값을 AtomicReference로 관리하고 있다. State는 immutable한 객체이며 아래와 같은 값들을 갖는다. activeCycle : 가장 최근 호출에서 사용된 cycle number. activePermissions : 현재 사용할 수 있는 permission의 수. 만약 reserve된 호출이 있다면 음수 값을 가질 수 있다. nanosToWait : 최근 호출이 permission을 얻기 위해 기다려야 할 nanoseconds. RateLimiterConfig123456RateLimiterConfig.custom() .timeoutDuration(Duration.ofSeconds(1)) .limitRefreshPeriod(Duration.ofSeconds(2)) .limitForPeriod(100) .writableStackTraceEnabled(true) .build(); RateLimiterConfig에는 timeoutDuration, limitRefreshPeriod, limitForPeriod, writableStackTraceEnabled이 있다. timeoutDuration : permission을 얻기 위해 thread가 기다릴 시간. limitRefreshPeriod : limit가 refresh되는 period. limitForPeriod : period마다 허용되는 permission의 수. writableStackTraceEnabled : 호출이 permission을 얻지 못해 CallNotPermittedException이 발생했을때 Stack Trace를 출력할지 정하는 boolean 값. 위의 예시에서는 2초동안 100개의 요청만 허용하면서 만약 permission이 부족할 경우, 1초 간은 기다리게 되는 설정이다. 또 CallNotPermittedException이 발생하면 Stack Trace까지 출력하게 된다. Weight in RateLimiter1234RateLimiter rateLimiter = RateLimiter.ofDefaults(&quot;test&quot;);rateLimiter.executeRunnable(3, () -&gt; &#123; ...&#125;); 현재 공식 문서에는 추가되어있지는 않지만 1.2.0 버전부터는 RateLimiter의 permission을 얻을 때, weight를 넣어서 호출할 수 있다. 위 예시에서 실행하고자 하는 Runnable Lambda 표현식은 permission 3개를 필요로 하게 된다. Reference https://resilience4j.readme.io/docs/ratelimiter https://github.com/resilience4j/resilience4j https://en.wikipedia.org/wiki/Token_bucket","categories":[{"name":"resilience4j","slug":"resilience4j","permalink":"https://dlsrb6342.github.io/categories/resilience4j/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"resilience4j","slug":"resilience4j","permalink":"https://dlsrb6342.github.io/tags/resilience4j/"}]},{"title":"Resilience4j CircuitBreaker","slug":"Resilience4j-CircuitBreaker","date":"2019-12-09T14:11:48.000Z","updated":"2021-01-30T08:34:59.247Z","comments":true,"path":"2019/12/09/Resilience4j-CircuitBreaker/","link":"","permalink":"https://dlsrb6342.github.io/2019/12/09/Resilience4j-CircuitBreaker/","excerpt":"","text":"Resilience4j CircuitBreakerresilience4j의 CircuitBreaker는 3개의 정상적인 state (CLOSED / OPEN / HALF_OPEN) 과 2개의 예외 state (DISABLED / FORCED_OPEN) 으로 구성된 finite state machine으로 구현되어있다. Sliding Window호출의 결과를 Store / Aggregation하기 위해 Sliding Window 를 사용하고 있고 Count Based 와 Time Based, 2 가지 종류가 있다. default로는 Count Based를 사용하고 있다. Count Based Sliding Window FixedSizeSlidingWindowMetrics.java 12345// Count BasedCircuitBreakerConfig.custom() .slidingWindowType(SlidingWindowType.COUNT_BASED) .slidingWindowSize(N) .build(); Count Based Sliding Window는 N개의 요청을 저장하고 aggregation해서 Circuit의 상태를 판단한다. N개의 Measurements를 가지고 있고 요청이 올때마다 가장 오래된 Measurement를 Total Aggregation에서 빼고 초기화한다.요청이 있을 때마다 Total Aggregation을 업데이트하기 때문에 Circuit의 Snapshot을 얻는 것은 O(1)의 시간이 걸리고, Circuit을 위해 필요한 메모리는 N개의 Measurements를 가지기 때문에 O(N)이다. Time Based Sliding Window SlidingTimeWindowMetrics.java 12345// Time BasedCircuitBreakerConfig.custom() .slidingWindowType(SlidingWindowType.TIME_BASED) .slidingWindowSize(N) .build(); Time Based Sliding Window는 N개의 Partial Aggregation Circular Array로 구현되어있다. N초 동안의 요청을 저장하고 aggregation해서 Circuit의 상태를 판단한다. Partial Aggregation은 Bucket이라고 생각하면 되는데, 1초동안에 발생한 요청들에 대해 Aggregation해서 저장하고 있는 bucket이다.요청의 결과를 각각 저장하는 것이 아닌 Partial Aggregation과 Total Aggregation에 저장한다. 시간이 지나 필요없어진 Partial Aggregation은 Total Aggregation에서 빼고 초기상태로 reset 된다.Time Based Sliding Window도 Total Aggregation을 요청마다 업데이트하기 때문에 Circuit의 Snapshot을 얻는 것은 O(1)의 시간이 걸린다. 필요한 메모리는 N개의 Partial Aggregation과 1개의 Total Aggregation을 가지기 때문에 O(N) 이다. Threshold for Open Stateresilience4j에서는 CircuitBreakerStateMachine가 OPEN State로 전이되기 위한 threshold를 2가지 제공한다. 요청이 Exception을 던지고 실패한 비율에 대한 Failure Rate Threshold, 지정한 Duration보다 오래 걸린 요청의 비율에 대한 Slow Call Rate Threshold가 있다.1234// Minimum Number of CallsCircuitBreakerConfig.custom() .minimumNumberOfCalls(10) .build();Failure Rate와 Slow Call Rate 모두 minimum number of calls보다 많은 요청이 있을 때부터 계산하기 시작한다. minimum number of calls보다 적은 요청만 들어왔다면 CircuitBreakerStateMachine은 OPEN 상태로 전이되지 않는다.minimumNumberOfCalls를 지정할 때 주의할 점이 있다. 만약 COUNT_BASED Sliding Window를 사용하면서 Window Size를 minimumNumberOfCalls보다 작게 지정했다면 Window Size의 값이 minimumNumberOfCalls 값으로 사용된다. Failure Rate Threshold12345678// Failure Rate ConfigCircuitBreakerConfig.custom() .failureRateThreshold(80) .recordExceptions(Exception.class) .ignoreExceptions(IllegalArgumentException.class) .recordException(throwable -&gt; throwable instanceof Exception) .ignoreException(throwable -&gt; throwable instanceof IllegalArgumentException) .build(); 말그대로 실패한 요청에 대한 threshold이다. 기본값은 50이고 Failure Rate가 전체 요청의 50%를 넘게 되면 CircuitBreakerStateMachine의 State가 CLOSED에서 OPEN으로 전이된다.기본으로는 모든 Exception이 Failure로 기록되지만 여러 가지 config 값을 넣어줄 수 있다. recordExceptions : 실패로 기록할 Exception list를 넣어줄 수 있다. 이 list에 속한 Exception은 ignoreExceptions에 포함되지 않는다면 모두 Failure로 기록된다. ignoreExceptions : 실패나 성공으로 기록하지 않을 Exception list를 넣어줄 수 있다. 이 list에 속한 Exception은 Success도 아니고 Failure도 아닌 요청이 된다. recordException : 실패로 기록할 Exception을 판단하는 Predicate&lt;Throwable&gt;을 설정할 수 있다. ignoreException : 무시하고 넘어갈 Exception을 판단하는 Predicate&lt;Throwable&gt;을 설정할 수 있다. Slow Call Rate Threshold12345// Slow Call Rate ConfigCircuitBreakerConfig.custom() .slowCallDurationThreshold(Duration.ofSeconds(3)) .slowCallRateThreshold(80) .build(); Slow Call에 대한 threshold 이다. slow call duration threshold를 설정할 수 있고 이 값보다 더 오래 걸린 요청에 대해서는 slow call로 기록하게 된다. 이렇게 기록된 slow call이 전체 요청에서 slow call rate threshold보다 높게 되면 CircuitBreakerStateMachine의 State가 OPEN으로 전이된다.기본값으로는 slowCallDurationThreshold는 60초, slowCallRateThreshold는 100%로 되어있다. 그렇기 때문에 따로 설정을 넣어주지 않는다면 slow call에 의한 OPEN State 전이는 Disable된 것이나 마찬가지이다. CircuitBreaker StateCircuitBreaker의 State는 AtomicReference에 저장된다. 또 State를 update할 때, atomic operation을 사용하고 Sliding Window에 요청을 기록하거나 SnapShot을 읽는 작업들이 모두 synchronized되어있기 때문에 CircuitBreaker는 thread safe하다. Half Open State1234// Permitted Calls in Half Open StateCircuitBreakerConfig.custom() .permittedNumberOfCallsInHalfOpenState(80) .build(); resilience4j의 CircuitBreaker는 HALF_OPEN state일 때, 다시 CLOSED나 OPEN으로 전이하기 위한 테스트 요청의 수를 정할 수 있다. CLOSED state의 Sliding Window는 TIME_BASED와 COUNT_BASED 2가지 종류를 지원하는 것과는 달리 HALF_OPEN state의 Sliding Window는 COUNT_BASED 만 지원하고 있다.permittedNumberOfCallsInHalfOpenState 값으로 HALF_OPEN state의 Sliding Window의 size를 지정할 수 있다. CLOSED state와 마찬가지로 minimumNumberOfCalls 값에 영향을 받으며 이때도 Window Size가 minimumNumberOfCalls보다 작으면 Window Size의 값을 minimumNumberOfCalls 값으로 사용한다. Disabled and Forced Open StateDISABLED State는 모든 요청을 허용하는 상태이고 FORCED_OPEN은 모든 요청을 거부하는 상태이다. 이 두 상태 모두 아무런 CircuitBreaker Event를 발생시키지 않고, metrics 또한 기록하지 않는다. 또 DISABLED나 FORCED_OPEN state에서 다른 state로 전이되는 방법은 직접 상태 전이를 trigger하거나 CircuitBreaker를 reset해야 한다. Other Configs이외에도 writableStackTraceEnabled, automaticTransitionFromOpenToHalfOpenEnabled, waitIntervalFunctionInOpenState 등의 설정이 있다. writableStackTraceEnabled : Circuit Open으로 인해 CallNotPermittedException이 발생했을때 Stack Trace를 출력할지 정하는 boolean 값이다. waitIntervalFunctionInOpenState : 고정된 wait duration이 아닌 Circuit open 후에 CLOSED State로의 전이를 위해 시도한 횟수로 wait duration을 설정해주는 Function을 넣어줄 수 있다. automaticTransitionFromOpenToHalfOpenEnabled : OPEN State에서 HALF_OPEN State로의 전이는 이 설정이 false일 경우, 다음 요청이 들어왔을 때 전이된다. 하지만 이 설정이 true라면 waitDurationInOpenState 시간 이후에 바로 HALF_OPEN State로 전이된다. Reference https://resilience4j.readme.io/docs/circuitbreaker https://github.com/resilience4j/resilience4j","categories":[{"name":"resilience4j","slug":"resilience4j","permalink":"https://dlsrb6342.github.io/categories/resilience4j/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"resilience4j","slug":"resilience4j","permalink":"https://dlsrb6342.github.io/tags/resilience4j/"}]},{"title":"Resilience4j Contribution (오픈소스 Contribution의 시작)","slug":"Resilience4j-Contribution","date":"2019-12-08T16:15:28.000Z","updated":"2021-01-30T08:34:59.248Z","comments":true,"path":"2019/12/09/Resilience4j-Contribution/","link":"","permalink":"https://dlsrb6342.github.io/2019/12/09/Resilience4j-Contribution/","excerpt":"","text":"Resilience4j Contributionresilience4j를 처음 알게 되고 사용한 지 6~7개월 정도 지났다. 그 당시 새로 진행하고 있던 프로젝트에 적용할 CircuitBreaker 구현체를 찾고 있었고 지난 프로젝트에 사용한 Hystrix가 maintenance 모드에 들어갔기에 resilience4j를 사용했다. Hystrix와의 차이점은 지난 포스트에 작성해두었다. 그리고 7개월이 지난 지금은 resilience4j의 maintainer로 활동 중이다. 시작.resilience4j에 처음으로 한 contribution은 오타 수정이다. resilience4j를 사용해보기 위해 guide나 javadoc을 꼼꼼하게 다 읽어보았고, 그러다 보니 보이는 오타들이 있었다. 이슈를 남기기보다는 간단한 문서 수정이기에 바로 PR을 올렸었다. https://github.com/resilience4j/resilience4j/pull/482 https://github.com/resilience4j/resilience4j/pull/535 작은 수정들이었지만 내가 Open Source Contribution에 흥미를 갖게 해주는 계기가 되었다. 이후에는 resilience4j에 올라오는 이슈들을 하나하나 다 읽어보고 혹시나 내가 기여할 수 있는 부분이 있는지 찾아보았다. 이 시기에 진행하고 있던 프로젝트에 resilience4j를 사용하고 있었으므로 사용 중에 불편했던 점이 생기기도 했고 여러 트러블 슈팅 경험도 생겨서 이슈에 코멘트를 달아주고 해결 방법에 대해 대화를 나누는 일들이 많아졌다. Spring Cloud.진행 중인 프로젝트가 spring-cloud의 library들을 많이 사용했었다. 이전 포스트들을 보면 알겠지만 spring-cloud-gateway / spring-cloud-sleuth / spring-cloud-config 등에 대한 글을 몇 개 작성했었고 spring-cloud-gateway에는 여러 커밋을 하기도 했다. 이 시기에 참 열심히 살았던 것 같다. 퇴근해서는 오픈 소스만 쳐다봤고 contribution 자체가 재밌었다. spring-cloud 이야기를 꺼낸 이유는 resilience4j에 첫 소스 코드에 대한 커밋은 spring-cloud 덕분이었기 때문이다. 이 당시(2019.06)에는 spring-cloud-circuitbreaker가 아직 incubating 중이었기 때문에 resilience4j를 spring-cloud와 사용하기에 불편함이 있었다. 이에 대해 똑같은 생각을 했던 사람이 이슈를 남겼고 코멘트로 트러블 슈팅을 했던 경험을 공유했다. https://github.com/resilience4j/resilience4j/issues/546 이에 resilience4j maintainer가 PR을 해줄 수 있냐고 물었고 난 정말 기쁜 마음으로 코드를 짜고 컨트리뷰팅을 했다. 이 이슈에 대한 PR은 7월 말에 처음 open 하였고 9월초에 머지되었다. 한 달이 넘는 기간, 46개의 코멘트를 주고받으며 리뷰를 받고 머지될 수 있었다. 중간중간 다른 이슈들에 대해서도 PR을 보냈고 여러 PR들이 머지되었다. 초대.여러 가지 이슈도 만들고 PR을 보내가며 커밋을 6개 정도 쌓아 갔을 때쯤, resilience4j maintainer로부터 slack에 초대를 받았다. resilience4j maintaining을 위한 채널이었다. https://github.com/resilience4j/resilience4j/pull/606#issuecomment-530386425 resilience4j maintainer로써 활동하게 된 것이다. 이 초대를 받고 resilience4j의 member가 된 것이 9월 중순이었으니 resilience4j에 관심을 갖고 여러 contribution을 한 지 3개월 만에 member가 될 수 있었다. 이후.resilience4j의 member가 되고 난 이후에는, 사실 commit은 많이 하지 못했다. 약간의 번아웃이 오기도 했고 여러 가지 개인 사정으로 인해 많은 시간을 쏟지 못했다. commit은 못했지만 그 대신 issue에 대해 답변을 준다거나 PR을 리뷰해주는 등 resilience4j가 더 성숙해지고 커질 수 있도록 노력했다. 6월 v0.16.0이던 프로젝트가 이젠 v1.2.0을 달고 릴리즈 되었고 spring-cloud-circuitbreaker에서 다른 CircuitBreaker 구현체들은 제외하고 resilience4j만을 지원하는 등, 정말 많은 성장을 한 것 같다. 처음 resilience4j를 만나고 간단한 포스트를 작성했었는데 이제는 많은 설정들이 달라졌고 추가되었다. 이 부분에 대해서는 이어질 포스트들에서 다뤄볼 예정이고 앞으로의 버전 릴리즈 시에도 변경사항에 대한 포스트를 작성해볼 생각이다. Open Source Contributing.나에게는 굉장히 신선한 경험이었다. spring-cloud-gateway에서 받은 PR 리뷰도 그렇고 resilience4j에서 받은 리뷰 모두 내가 생각하지 못했던 부분에 대한 리뷰를 받을 수 있었다. 라이브러리 개발자가 아닌 서비스 개발자로서 개발해왔기 때문에 내가 만든 코드를 사용하는 유저들에 대한 생각을 하지 못했다. 이런 내가 고려하지 못했던, 놓쳤던 부분들에 대한 리뷰들이 나를 더욱 Open Source Contribution에 빠져들게 했고 한층 더 성장시켜주었다. 직장에 다니고 대학 시절과는 다르게 개발이 일이 되면서 흥미나 의욕을 조금씩 잃어가는 느낌이 있었는데 Open Source Contribution을 하면서 대학 시절보다도 더 의욕이 넘치게 된 것 같다.Open Source Contribution를 처음 시작하려고 하는 분들에게는 쉽게 생각하자고 말씀드리고 싶다. 나도 처음엔 얼굴에 철판을 깔았는지 이슈를 올리고 아무 PR이나 보내고 이슈에 코멘트를 달고 많이 나대고 다녔었다. 그러다 보니 contribution 자체가 어렵지 않게 느껴졌고 편하고 쉽게 생각할 수 있게 되었다. 또 시작하려고 할 때 뭐부터 해야 하지 라고 생각이 들 때는 문서를 꼼꼼하게 읽고 파악하는 것과 조금이라도 직접 사용해보는 것이 중요해 보인다. 그래야 PR도 자신 있게 올릴 수 있고 문제점이 눈에 들어오기도 하는 것 같다. 더 많은 사람들이 오픈 소스를 그저 사용해보는 것만이 아닌 여러 가지 방법으로 기여하면서 나와 비슷한 경험들을 했으면 좋겠다.","categories":[{"name":"resilience4j","slug":"resilience4j","permalink":"https://dlsrb6342.github.io/categories/resilience4j/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"resilience4j","slug":"resilience4j","permalink":"https://dlsrb6342.github.io/tags/resilience4j/"}]},{"title":"Reactor-Tools 사용해보기","slug":"Reactor-Tools-사용해보기","date":"2019-11-23T03:57:51.000Z","updated":"2021-01-30T08:34:59.237Z","comments":true,"path":"2019/11/23/Reactor-Tools-사용해보기/","link":"","permalink":"https://dlsrb6342.github.io/2019/11/23/Reactor-Tools-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/","excerpt":"","text":"A set of tools to improve Project Reactor’s debugging and development experience. reactor-tools란 Reactor 라이브러리를 사용했을 때, 디버깅과 개발을 용이하게 해주기 위한 툴이다. 얼마 전까지는 reactor-core가 아닌 별도의 프로젝트로 관리되었으나 reactor-core 3.3.0 버전에 맞춰서 reactor-core에 migration 되었고 3.3.0.RELEASE에서 릴리즈되었다. spring-boot에서 reactor-tools를 사용하려면 spring-boot 버전을 2.2.0 이상으로 올려줘야 한다. 예시 코드에서는 spring-boot 2.2.1을 사용하였다. 예시 코드는 https://github.com/dlsrb6342/blog-sample/tree/master/reactor-tools-demo 에 올라가 있다. reactor-tools를 활성화하는 방법은 아주 간단하다. SpringApplication이 실행되기 전에 init 해주기만 하면 된다.123456789@SpringBootApplicationpublic class ReactorToolsDemoApplication &#123; public static void main(String[] args) &#123; ReactorDebugAgent.init(); SpringApplication.run(ReactorToolsDemoApplication.class, args); &#125;&#125;ReactorDebugAgent는 Call Site Info를 넣어주는 java agent이다. Runtime Cost없이 실행되기 때문에 Production에서도 사용 가능하다고 하다. reactor의 call chain을 bytecode 레벨에서 아래와 같이 바꿔준다고 한다.123456789# FROMFlux.range(0, 5) .single();# TOFlux flux = Flux.range(0, 5);flux = Hooks.addCallSiteInfo(flux, &quot;Flux.range\\n foo.Bar.baz(Bar.java:21)&quot;));flux = flux.single();flux = Hooks.addCallSiteInfo(flux, &quot;Flux.single\\n foo.Bar.baz(Bar.java:22)&quot;));ReactorDebugAgent를 init 해주고 나서 Exception을 발생시키면 아래와 같이 call chain을 확인해볼 수 있다. 확실히 어디서 어떤 call이 이어지면서 Exception이 발생했는지 한눈에 알 수 있었다. 물론 call chain info 밑에 Stack Trace도 출력된다. Reactive Programming의 단점 중 하나인 Debugging이 어려운 점을 reactor-tools가 해결해줄 것으로 보인다. 또 조금만 더 기다리면 IntelliJ 2019.3에서는 Reactor에 대한 지원을 강화한다고 한다. 관련된 내용은 여기에서 확인해볼 수 있다. Reference https://spring.io/blog/2019/03/28/reactor-debugging-experience https://github.com/reactor/reactor-core/tree/master/reactor-tools https://blog.jetbrains.com/idea/2019/10/whats-new-in-intellij-idea-2019-3-eap6-improved-reactor-support-and-a-huge-pack-of-fixes/","categories":[{"name":"spring-webflux","slug":"spring-webflux","permalink":"https://dlsrb6342.github.io/categories/spring-webflux/"},{"name":"reactor","slug":"spring-webflux/reactor","permalink":"https://dlsrb6342.github.io/categories/spring-webflux/reactor/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://dlsrb6342.github.io/tags/spring/"},{"name":"reactor","slug":"reactor","permalink":"https://dlsrb6342.github.io/tags/reactor/"}]},{"title":"jib-gradle-plugin으로 spring-boot application을 Docker에 배포하기","slug":"jib-gradle-plugin으로-spring-boot-application을-Docker에-배포하기","date":"2019-07-26T07:39:46.000Z","updated":"2021-01-30T08:34:59.268Z","comments":true,"path":"2019/07/26/jib-gradle-plugin으로-spring-boot-application을-Docker에-배포하기/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/26/jib-gradle-plugin%EC%9C%BC%EB%A1%9C-spring-boot-application%EC%9D%84-Docker%EC%97%90-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/","excerpt":"","text":"Build container images for your Java applications.https://github.com/GoogleContainerTools/jib spring boot application을 Docker에 배포해보기 위해 검색했을 때 가장 먼저 뜨는 링크는 spring.io에 실려있는 게시글이다. 이 게시글에서는 com.palantir.docker plugin을 사용하고 Dockerfile을 작성하여 image build를 해주고 있다. 물론 착착 잘 되는 사람도 있었겠지만 내가 하는 환경에서는 잘 되지 않았다. Mac에서는 docker command의 PATH를 찾지 못하고 계속 오류를 내고 있었다. (참고 : https://github.com/palantir/gradle-docker/issues/162)여러 시도를 하다가 포기하고 다른 plugin을 찾았는데 그것이 Google에서 만든 jib-gradle-plugin이다. 사용해본 결과, 정말 편하게 별다른 설정없이 docker에 application을 올릴 수 있었다. jib github repo에 들어가보면 maven plugin도 있으니 maven을 사용하신다면 한번 확인해보기 바란다. jib-gradle-pluginImage build123plugins &#123; id &#x27;com.google.cloud.tools.jib&#x27; version &#x27;1.4.0&#x27;&#125; 적용방법은 간단하다. build.gradle에 plugin으로 넣어주면 된다. 아무런 설정을 넣어주지 않는다면 image의 이름은 module 이름과 version 태그로 빌드된다. 물론 이름과 태깅 설정도 간단하다.1234567891011bootJar &#123; baseName = &#x27;service-1&#x27; version = &#x27;0.1.0&#x27;&#125;jib &#123; to &#123; image = &quot;$&#123;bootJar.baseName&#125;:$&#123;bootJar.version&#125;&quot; tags = [&#x27;latest&#x27;] &#125;&#125;난 bootJar를 통해 만들어지는 jar 파일과 이름을 같게 하기 위해 위와 같이 설정했다. 위 설정으로 이미지를 빌드하면 service-1:0.1.0과 service01:latest 두 개의 태그가 만들어진다. Push to Docker hubDocker hub나 원하는 docker registry에 Push하는 것도 간단하다. jib github repo를 확인해보면 다양한 cloud service에 push하는 방법들이 나와있다. 난 Docker hub로 Push하도록 설정해보았다.12345678910ext.dockerId = &#x27;dlsrb6342&#x27;jib &#123; to &#123; image = &quot;$&#123;dockerId&#125;/$&#123;bootJar.baseName&#125;:$&#123;bootJar.version&#125;&quot; username = &quot;USER_ID&quot; password = &quot;PASSWORD&quot; tags = [&#x27;latest&#x27;] &#125;&#125; 위의 이미지 및 태그 설정했던 부분에 docker hub ID를 넣어주고 username / password 값을 추가해주면 된다. 하지만 이 방법은 password가 다 노출될 수 있기 때문에 docker-credential-helper를 사용하기를 권장한다. docker-credential-helper를 사용하면 username과 password를 직접 적어두지 않아도 된다. 나는 OSX를 사용 중이기에 osxkeychain을 설치했다.123456brew install goexport GOPATH=/usr/local/Cellar/go/1.12.7go get github.com/docker/docker-credential-helperscd $GOPATH/docker/docker-credentials-helpersmake osxkeychainexport PATH=&quot;$&#123;PATH:+$&#123;PATH&#125;:&#125;/usr/local/Cellar/go/1.12.7/src/github.com/docker/docker-credential-helpers/bin&quot;go lang도 설치되어있지 않아 다 설치해주었다. 다 설치해주고 나서 docker-credential-osxkeychain list를 입력해보면 잘 설정되었는지 볼 수 있을 것이다. 여기서 하나 정리해야 하는것이 jib-gradle-plugin이 가지고있는 명령들이다. jib : Build your container image jibBuildTar : You can build and save your image to disk as a tarball jibDockerBuild : Jib can also build your image directly to a Docker daemon jibBuildTar는 이름 그래도 image를 tar 파일로 만들어주는 명령이다. jib과 jibDockerBuild는 하는 일은 거의 똑같다. 한 가지 다른 점은 jib은 docker hub와 같은 원격 registry에도 image를 push해준다는 점이다. jibDockerBuild를 사용하면 자신의 환경에 설치되어있는 docker command를 사용하기 때문에 local에만 image가 올라가게 된다. 우린 remote registry에 올릴 것이기 때문에 jib 명령을 사용하면 된다. Example코드는 https://github.com/dlsrb6342/blog-sample/tree/master/gradle-docker-example에 올려두었다. service1, service2 2개의 모듈이 있고 이를 jib-gradle-plugin으로 빌드하고 docker-compose를 사용해 두 모듈을 함께 실행해보는 예제이다. 위에 얘기한 설정들은 각 모듈의 build.gradle에서 확인할 수 있고 root project의 build.gradle을 보면 편의를 위해 직접 task를 추가해었다.123456789task dockerDownAll(type:Exec) &#123; commandLine &#x27;docker-compose&#x27;, &#x27;down&#x27;&#125;task dockerRunAll(type:Exec) &#123; dependsOn dockerDownAll dependsOn subprojects.jibDockerBuild commandLine &#x27;docker-compose&#x27;, &#x27;up&#x27;, &#x27;-d&#x27;&#125; dockerRunAll : subprojects를 모두 이미지로 빌드하고 docker-compose를 사용해 실행시키는 명령 dockerDownAll : 모든 모듈을 중지시키는 명령 12345678910111213141516&gt; ./gradlew dockerRunAll...&gt; Task :dockerRunAllCreating network &quot;gradle-docker-example_default&quot; with the default driverCreating service-1 ... Creating service-2 ... Creating service-2 ... doneBUILD SUCCESSFUL in 30s&gt; docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3053876b03ee service-2:latest &quot;java -cp /app/resou…&quot; 10 seconds ago Up 7 seconds 0.0.0.0:8082-&gt;8082/tcp service-2983cb559414e service-1:latest &quot;java -cp /app/resou…&quot; 10 seconds ago Up 7 seconds 0.0.0.0:8081-&gt;8081/tcp service-1&gt; curl http://127.0.0.1:8081/toService2&#123;&quot;service2&quot;:&quot;success&quot;,&quot;service1&quot;:&quot;toService2-passed&quot;&#125; dockerRunAll 명령을 실행하게 되면 service1, service2 모듈이 실행되는 것을 볼 수 있다. Docker hub에 push하는 방법은 각 모듈에서 jib 명령을 실행해주면 된다.123456789&gt; ./gradlew :service1:jib...Built and pushed image as dlsrb6342/service-1:0.1.0, dlsrb6342/service-1Executing tasks:[==============================] 100.0% completeBUILD SUCCESSFUL in 17s3 actionable tasks: 2 executed, 1 up-to-datepush된 이미지는 Docker hub 페이지에서 확인할 수 있다. 정리com.palantir.docker plugin을 사용하면서 힘들었던 점이 많았다. Dockerfile을 작성하는 문법도 정확히 몰라서 계속 찾아봐야 했고 심지어 다 작성한 후에는 무슨 이유인지 모르게 docker command의 PATH를 찾지 못하는 이슈도 있었다. 이런 일이 있어서인지 jib-gradle-plugin은 정말 편하다는 느낌을 많이 받았다. java application을 docker image로 빌드할 때는 고민없이 이 plugin을 사용할 것 같다.","categories":[{"name":"build","slug":"build","permalink":"https://dlsrb6342.github.io/categories/build/"},{"name":"gradle","slug":"build/gradle","permalink":"https://dlsrb6342.github.io/categories/build/gradle/"},{"name":"spring-boot","slug":"build/gradle/spring-boot","permalink":"https://dlsrb6342.github.io/categories/build/gradle/spring-boot/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"gradle","slug":"gradle","permalink":"https://dlsrb6342.github.io/tags/gradle/"},{"name":"spring","slug":"spring","permalink":"https://dlsrb6342.github.io/tags/spring/"}]},{"title":"spring-cloud-sleuth 예제로 살펴보기","slug":"spring-cloud-sleuth-예제로-살펴보기","date":"2019-07-20T08:36:43.000Z","updated":"2021-01-30T08:34:59.279Z","comments":true,"path":"2019/07/20/spring-cloud-sleuth-예제로-살펴보기/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/20/spring-cloud-sleuth-%EC%98%88%EC%A0%9C%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/","excerpt":"","text":"Spring Cloud Sleuth implements a distributed tracing solution for Spring Cloud. 오늘은 spring-cloud 프로젝트 중 분산형 추적 솔루션인 spring-cloud-sleuth에 대해 알아보려한다.공식 문서 : https://cloud.spring.io/spring-cloud-sleuth/spring-cloud-sleuth.html 용어spring-cloud-sleuth는 Dapper의 용어를 가져와서 사용하고 있다. 중요한 용어 몇가지만 정리하겠다. SpanSpan은 64 bit unique ID를 가지는 Tracing의 가장 기본 단위이다.12345678910final class RealSpan extends Span &#123; final TraceContext context; final PendingSpans pendingSpans; final MutableSpan state; final Clock clock; final FinishedSpanHandler finishedSpanHandler; ...&#125;openzipkin/brave에 있는 Span 구현체이다. context는 span이 속해있는 Trace에 대한 정보를 들고 있고 pendingSpans에는 report되기 전의 pending된 span들이 WeakConcurrentMap으로 담겨있다.실제로 이 Span에 대한 정보를 담고 있는건 state이다. TraceContext를 제외한 시작시간 / local ip / remote ip / tags 등등 많은 정보를 들고 있다. TraceSpan을 설명할때 잠깐 언급된 Trace이다. Trace는 span들을 모아둔 것으로 tree와 비슷한 구조로 되어있다. Trace Id는 가장 처음 trace를 시작시킨 span의 ID와 같다. AnnotationAnnotation은 어떤 이벤트가 발생하고 진행되는지에 대한 기록을 쓰인다. 하지만 Brave를 사용하면서 더이상 request에 대해 이벤트들을 기록할 필요가 없어졌다. cs : Client Sent. client가 request를 보낸 이벤트. span의 시작이다. sr : Server Received. server가 request를 받는 이벤트. ss : Server Sent. server가 request 처리를 완료한 이벤트. cr “ Client Received. client가 response를 받는 이벤트. span의 종료이다. Bravespring-cloud-sleuth 2.0.0 version부터는 tracing instrumentation library인 Brave를 사용하고 있다. sleuth는 더이상 context를 만들거나 관리하지 않고 그 일을 Brave에게 위임하였다. naming이나 tagging conventions도 Brave와 똑같게 변경하였다. Example이제 spring-cloud-sleuth를 실제로 사용해보면서 공부해보겠다. 예시 코드는 https://github.com/dlsrb6342/blog-sample/tree/master/spring-cloud-sleuth-example 에 올라가있다. 예시는 spring-webflux를 사용해서 만들려고 했지만 제대로 동작하질 않아서 힘들었다. 이틀정도 고생하면서 내가 뭘 잘못해서 안되는지 찾아봤다. 결론은 내 잘못은 아닌것으로 보인다. spring-cloud-sleuth 이슈로 등록해두었다. 아직 답변은 못 받았지만 버그인 것 같다. 예시 코드는 일단 webflux와 mvc 두개 모두 만들어두었다. 예시 코드의 구조는 간단하다. 4가지 application(fcaller, fclient, mcaller, mclient)을 만들고 모두 sleuth를 적용시켜두었다. zipkin 서버는 간단하게 docker에 띄우고 실행했다. http://localhost:9411에 접근해보면 zipkin ui를 볼 수 있을 것이다.1&gt; docker run -d -p 9411:9411 openzipkin/zipkin user -&gt; mcaller -&gt; mclientmcaller와 mclient는 spring-mvc를 사용해 구현한 application이다.12&gt; curl http://localhost:8082/mcaller&#123;&quot;mclient&quot;:&quot;client&quot;,&quot;mcaller&quot;:&quot;caller&quot;&#125;위 요청을 보내면 mcaller가 mclient에 요청을 보내고 받은 응답을 user에게 돌려준다. zipkin에도 해당 request가 정확히 tracing되었다. mcaller가 user로부터 받은 요청으로 인해 생긴 “Server Start / Server finish” span mcaller가 mclient를 호출하면서 생긴 “Client Start / Client finish” span mclient가 mcaller로부터 받은 요청으로 인해 생긴 “Server Start / Server finish” span 총 3개의 span이 생성되었고 문제없이 잘 동작하였다. user -&gt; fcaller -&gt; fclientfcaller와 fclient는 spring-weblfux로 만들었는데 위에 언급했듯이 정확하게 동작하지 않는다. Tracing정보를 넘겨주고 요청이 완료될 경우 report를 하고 있는 CoreSubscriber의 onComplete 함수가 제대로 호출되지 않고 있다.자세한 예시와 내용에 대해서는 https://github.com/spring-cloud/spring-cloud-sleuth/issues/1402 여기서 확인하면 된다. 정리spring boot의 auto configuration 덕분에 spring-cloud-sleuth를 dependency에 넣어주고 zipkin uri만 넣어주는 것만으로도 쉽게 적용할 수 있었다. 하지만 spring-webflux에서는 제대로 동작하지 않을뿐만 아니라 성능상의 이슈도 있다고 한다( https://github.com/spring-cloud/spring-cloud-sleuth/issues/1397 ). 성능이 중요한 webflux application을 개발할 때는 spring-cloud-sleuth를 적용하는 것에 대해 조금 고민이 필요할 것 같다.","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"https://dlsrb6342.github.io/categories/spring-cloud/"},{"name":"spring-cloud-sleuth","slug":"spring-cloud/spring-cloud-sleuth","permalink":"https://dlsrb6342.github.io/categories/spring-cloud/spring-cloud-sleuth/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://dlsrb6342.github.io/tags/spring/"},{"name":"spring-cloud","slug":"spring-cloud","permalink":"https://dlsrb6342.github.io/tags/spring-cloud/"}]},{"title":"Gradle Guide 3. Creating Multi-project Builds","slug":"Gradle-Guide-3-Creating-Multi-project-Builds","date":"2019-07-20T04:02:38.000Z","updated":"2021-01-30T08:34:59.226Z","comments":true,"path":"2019/07/20/Gradle-Guide-3-Creating-Multi-project-Builds/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/20/Gradle-Guide-3-Creating-Multi-project-Builds/","excerpt":"","text":"Gradle Guide 3. Creating Multi-project Builds 공식 가이드 : https://guides.gradle.org/creating-multi-project-builds/ 이번 가이드에는 gradle로 멀티 모듈의 프로젝트를 만들고 빌드하는 것에 대해 배운다. Create a root projectGradle Guide 2에서 했던 것처럼 gradle init으로 새로운 root project를 만들어준다. 자동생성된 많은 파일 중에 settings.gradle을 보면 rootProject.name이 잘 들어가 있을 것이다. 12345678&gt; gradle initStarting a Gradle Daemon (subsequent builds will be faster)BUILD SUCCESSFUL in 5s2 actionable tasks: 2 executed&gt; cat settings.gradlerootProject.name = &#x27;gradle-3&#x27; Configure from above내가 멀티 프로젝트의 장점이라 생각하는 점 중에 하나는 공통의 dependency나 설정에 대해 root project에 한번에 쓸 수 있다는 점이다.123456789101112// build.gradleallprojects &#123; repositories &#123; jcenter() &#125;&#125;subprojects &#123; version = &#x27;1.0&#x27;&#125; allprojectsallprojects는 root를 포함한 모든 sub project들에 configuration을 추가하는 block이다. 위에서는 모든 project에 jcenter repository를 추가하였다. subprojectssubprojects는 allprojects block에서 root를 제외한 설정이다. 위에서는 모든 sub project에 version을 1.0으로 설정하였다. 다른 scripts block에 대해서는 gradle docs를 보면 자세히 설명이 되어있다. Add a Groovy library subproject이제 sub project를 추가해보자. 가이드에서는 groovy library를 추가하는 방법에 대해 설명하고 있어서 groovy를 잘 모르지만 그냥 따라해봤다. greeting-library란 폴더를 만들고 build.gradle 파일을 작성하였다.123456789101112// greeting-library/build.gradleplugins &#123; id &#x27;groovy&#x27;&#125;dependencies &#123; compile &#x27;org.codehaus.groovy:groovy:2.4.10&#x27; testCompile &#x27;org.spockframework:spock-core:1.0-groovy-2.4&#x27;, &#123; exclude module: &#x27;groovy-all&#x27; &#125;&#125;이제 root project에 greeting-library를 포함시켜보자. 아까 rootProject.name이 쓰여있던 settings.gradle 파일에 써주면된다.12rootProject.name = &#x27;gradle-3&#x27;include &#x27;greeting-library&#x27;기본 폴더 구조인 src/main/groovy/greeter, src/main/test/groovy/greeter를 만들어주고 간단한 코드를 작성해준다.1234567891011// greeting-library/src/main/groovy/greeter/GreetingFormatter.groovypackage greeterimport groovy.transform.CompileStatic@CompileStaticclass GreetingFormatter &#123; static String greeting(final String name) &#123; &quot;Hello, $&#123;name.capitalize()&#125;&quot; &#125;&#125;테스트코드는 건너뛰겠다.. 다 작성한 후에 ./gradlew build를 쓰면 greeting-library 모듈이 빌드되는 것을 볼 수 있을 것이다. gradle은 sub project의 build task가 있다는것을 자동으로 감지하고 그것을 실행해준다. 이 부분이 gradle multi project의 큰 장점 중 하나라고 한다.=&gt; Root project에 있는 task 이름과 같은 task가 sub project에 있다면 Gradle이 각각의 project의 같은 이름의 task를 함께 실행해줄 수 있다. Add a Java application sub-project이번엔 java application을 추가한다. 똑같이 폴더를 만들고 build.gradle 작성, code 작성을 하면 된다. 물론 root project의 settings.gradle에도 sub project로 추가하여야 한다. 코드는 생략하고 github에 올려두었다. 위의 gradle project와 다른 점은 mainClassName을 설정해주어야 한다는 점이다. Java application 모듈이기 때문에 gradle에게 진입점(main 함수가 있는 class)를 알려주어야 한다.12// greeter/build.gradlemainClassName = &#x27;greeter.Greeter&#x27;또 greeter-library에 있는 GreetingFormatter를 사용하기 때문에 greeting-library를 greeter의 dependency로 추가해주어야 한다.1234// greeter/build.gradledependencies &#123; compile project(&#x27;:greeting-library&#x27;)&#125;두 sub project가 완성되었으니 이제 build를 해보자. 문제없이 sub project 모두 build가 잘 될것이다. 본문 가이드에서는 Docs / Test 추가있지만 따로 다루진 않겠지만 한번 읽어보면 좋을 것 같다. 이 가이드 관련 코드는 https://github.com/dlsrb6342/gradle-study/tree/guide-3-multi-projects에 올려두었다. gradle guide를 공부하게 된 계기도 multi project를 구성하려다 막혀서 였는데 이 가이드를 통해서 어느정도 알아간 것 같다. scripts block에 대해서도 조금 찾아봐야 할 것 같다.","categories":[{"name":"build","slug":"build","permalink":"https://dlsrb6342.github.io/categories/build/"},{"name":"gradle","slug":"build/gradle","permalink":"https://dlsrb6342.github.io/categories/build/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://dlsrb6342.github.io/tags/gradle/"}]},{"title":"ThreadLocal vs. InheritableThreadLocal","slug":"ThreadLocal-vs-InheritableThreadLocal","date":"2019-07-15T13:13:44.000Z","updated":"2021-01-30T08:34:59.266Z","comments":true,"path":"2019/07/15/ThreadLocal-vs-InheritableThreadLocal/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/15/ThreadLocal-vs-InheritableThreadLocal/","excerpt":"","text":"ThreadLocal vs. InheritableThreadLocalThread.java 코드를 보면 아래와 같이 InheritableThreadLocal과 ThreadLocal이 따로 관리되는 것을 볼 수 있다. 둘의 차이가 무엇인지 확인해보자.123456789101112131415public class Thread implements Runnable &#123; ... /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; ...&#125; ThreadLocalThreadLocal은 이름에서도 알 수 있듯이 한 Thread의 scope내의 local variable이다. 하나의 Thread 안에서는 같은 값을 공유해서 사용한다.12345678// 생성ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();// 저장threadLocal.set(&quot;test&quot;);// 사용threadLocal.get();사용법도 간단하다. 만들고 저장하고 쓰면 된다. 활용보통 하나의 Request에 대한 정보들을 저장할 때 사용된다. spring-security : 사용자 인증 정보를 ThreadLocal에 담아서 전달해준다. spring-web : RequestContextHolder가 요청의 Context를 ThreadLocal로 들고 있어 어디서든 꺼내쓸 수 있다. mdc : Logging에 사용될 attribute를 ThreadLocal로 들고 있다. ThreadLocal은 spring-web을 사용할때는 문제가 되지 않았다. 하지만 reactive programming(spring-webflux)을 사용하게 되고 하나의 요청이 여러 Thread에서 처리될 수 있게 되면서 ThreadLocal이 문제가 되었다. InheritableThreadLocal이름에서도 알 수 있듯이 Inheritable한 ThreadLocal이다. InheritableThreadLocal은 부모 Thread에서 생성된 자식 Thread에 그 값이 전달된다. 사용법은 ThreadLocal과 똑같다.자식 Thread에도 그 값이 전달되기 때문에 Thread를 왔다갔다 할수도 있는 reactive programming에서도 문제없이 사용 가능하다. 비교 테스트1234567891011121314151617181920212223public class ThreadLocalTests &#123; ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = new InheritableThreadLocal&lt;&gt;(); @Test public void toAnotherThread() &#123; long threadId = Thread.currentThread().getId(); threadLocal.set(&quot;test&quot;); inheritableThreadLocal.set(&quot;test&quot;); System.out.println(String.format( &quot;Thread ID : %s / ThreadLocal : %s / InheritableThreadLocal : %s&quot;, threadId, threadLocal.get(), inheritableThreadLocal.get())); Mono.fromRunnable(() -&gt; &#123; long anotherThreadId = Thread.currentThread().getId(); System.out.println(String.format( &quot;Thread ID : %s / ThreadLocal : %s / InheritableThreadLocal : %s&quot;, anotherThreadId, threadLocal.get(), inheritableThreadLocal.get())); &#125;).subscribeOn(Schedulers.elastic()).subscribe(); &#125;&#125; ThreadLocal과 InheritableThreadLocal을 비교하는 테스트이다. 부모 Thread에서 ThreadLocal과 InheritableThreadLocal를 모두 set해주고 자식 Thread에서 꺼내서 확인하는 코드이다. 다른 Thread를 실행하는 것은 reactor의 subscribeOn을 사용했다.12Thread ID : 1 / ThreadLocal : test / InheritableThreadLocal : testThread ID : 15 / ThreadLocal : null / InheritableThreadLocal : test결과는 이렇게 나온다. 부모 Thread에서는 두 값 모두 저장되어있지만 자식 Thread에서는 InheritableThreadLocal만 남아있다. InheritableThreadLocal in zipkinInheritableThreadLocal은 spring-cloud-sleuth와 zipkin을 사용하다가 발견했다. zipkin은 다른 Thread로 넘어가도 문제가 없게 하기 위해 현재 span의 정보를 CurrentTraceContext에 InheritableThreadLocal에 담아서 들고 있고 새로운 Scope가 시작될때 바꿔주고 있다. zipkin에서 MDC도 활용하고 있기 때문에 MDC에 넣어주는 부분은 Slf4jScopeDecorator를 참고하면 된다. 1234567891011121314151617181920212223242526// CurrentTraceContext.java public static final class Default extends ThreadLocalCurrentTraceContext &#123; static final InheritableThreadLocal&lt;TraceContext&gt; INHERITABLE = new InheritableThreadLocal&lt;&gt;(); public static CurrentTraceContext inheritable() &#123; return new Default(); &#125; Default() &#123; super(new Builder(), INHERITABLE); &#125; &#125;// ThreadLocalCurrentTraceContext.java @Override public Scope newScope(@Nullable TraceContext currentSpan) &#123; final TraceContext previous = local.get(); local.set(currentSpan); class ThreadLocalScope implements Scope &#123; @Override public void close() &#123; local.set(previous); &#125; &#125; Scope result = new ThreadLocalScope(); return decorateScope(currentSpan, result); &#125; 결론Reactive 환경에서는 InheritableThreadLocal을 사용하면 Servlet에서 RequestContext를 관리했던 것처럼 할 수 있을 것 같다. 하지만 reactor에서는 subscriberContext()를 제공하기 때문에 이것을 활용하는 것이 더 나을수도 있을 것 같다. 나중에 그 둘을 비교하는 글도 작성할 예정이다.또 여러 글들을 보다보니 InheritableThreadLocal은 Servlet에서는 사용하면 좋지 않다는 얘기가 있다. 관련된 내용은 https://stackoverflow.com/questions/14498503/why-should-i-avoid-using-inheritablethreadlocal-in-servlets 이 링크에서 확인하면 된다.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 69 70 71","slug":"Effective-Java-3rd-ITEM-69-70-71","date":"2019-07-14T06:20:49.000Z","updated":"2021-01-30T08:34:59.176Z","comments":true,"path":"2019/07/14/Effective-Java-3rd-ITEM-69-70-71/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/14/Effective-Java-3rd-ITEM-69-70-71/","excerpt":"","text":"ITEM 69. Use exceptions only for exceptional conditions예외는 이름 그대로 오직 예외 상황에서만 상황해야 한다. 절대로 일상적인 흐름을 제어하기 위해 사용되어서는 안된다. 일부러 예외를 만들고 그 예외를 catch하는 흐름을 만들어서는 안된다. 이런 원칙은 API 설계에도 똑같이 적용할 수 있다. 클라이언트가 정상적인 흐름에서 예외를 사용할 일은 없어야 한다. 특정 상황에서만 호출 가능한 상태 의존적 메서드는 상태 검사 메서드와 함께 제공되어야 한다.12345// 상태 의존적 메서드iterator.next();// 상태 검사 메서드iterator.hasNext();이런 상태 검사 메서드 대신 null같은 특정값 혹은 Optional은 return하는 방법도 있다. 특정값? Optional? 상태 검사 메서드? 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부요인으로 상태가 변할 수 있다면 Optional이나 특정값을 사용하자. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 상태가 변경될 수 있기 때문이다. 성능이 중요한 상황에서 상태 검사 메서드와 상태 의존적 메서드의 작업이 일부 중복된다면 Optional이나 특정값을 사용하자. 1번 2번을 제외한 모든 경우에 상태 검사 메서드가 더 낫다. 가독성도 좋고 버그를 발견하기도 쉽기 때문이다. ITEM 70. Use checked exceptions for recoverable conditions and runtime exceptions for programming errorsthrowable에는 검사 예외, 런타임 예외, 에러 3가지가 있다. 이중에 비검사 throwable에는 런ㅁ타임 예외와 에러가 있고 둘의 동작도 똑같다. 이 둘은 프로그램에서 잡을 필요가 없거나 잡으면 안되는 예외들이다. 또 비검사 throwable들은 모두 RuntimeException의 하위 클래스이다. 검사 예외? 런타임 예외? 에러? 호출하는 쪽에서 catch하고 처리해야하는 상황이라면 검사 예외를 사용하라. 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하라. Exception / RuntimeException / Error 모두 상속하지 않은 throwable은 사용하지 말자. 검사 예외는 복구할 수 있는 조건일 때 사용하자. ITEM 71. Avoid unnecessary use of checked exceptions검사 예외를 과하게 사용하면 쓰기 불편한 API가 될 수 있다. 어떤 메서드가 검사 예외를 던진다면, 그것을 호출하는 클라이언트는 catch 블록을 두고 처리하거나 바깥으로 던져주는 코드를 작성해야 한다. 결국 사용자에게 부담을 주게 된다. API를 제대로 사용해도 발생할 수 있는 예외이거나 의미있는 예외가 아니라면 비검사 예외를 사용하는 것이 좋다. 검사 예외 대신 Optional을 return하는 것도 방법이다. 상태 검사 메서드를 추가할 수 있지만 여러 단점이 존재해 적절하지 않을 수 있다. 검사 예외는 프로그램의 안전성을 높여주지만 사용자에게 부담을 줄 수 있다. 비검사 예외를 사용하거나 Optional로 처리해보자","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"10. Exceptions","slug":"Effective-Java-3rd/10-Exceptions","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/10-Exceptions/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Gradle Guide 2. Create new Gradle builds","slug":"Gradle-Guide-2-Create-new-Gradle-builds","date":"2019-07-14T05:40:56.000Z","updated":"2021-01-30T08:34:59.225Z","comments":true,"path":"2019/07/14/Gradle-Guide-2-Create-new-Gradle-builds/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/14/Gradle-Guide-2-Create-new-Gradle-builds/","excerpt":"","text":"Gradle Guide 2. Create new Gradle builds 공식 가이드 : https://guides.gradle.org/creating-new-gradle-builds/ 이번 가이드에서는 command line에서 gradle project를 생성하고 기본적인 명령어를 배운다. gradle init12345678910111213141516171819202122# kotlin# gradle init --dsl kotlin# groovy&gt; gradle initStarting a Gradle Daemon (subsequent builds will be faster)BUILD SUCCESSFUL in 6s2 actionable tasks: 2 executed&gt; tree ..├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat└── settings.gradle2 directories, 6 files build.gradle : project의 configuration을 담고 있는 build script이다. gradle-wrapper.jar : Gradle Wrapper을 들고있는 executable jar 이다. gradle-wrapper.properties : Gradle Wrapper의 설정을 가진 파일이다. gradlew : UNIX 계열에서 사용할 수 있는 Gradle Wrapper script이다. gradlew.bat : Windows에서 사용할 수 있는 Gradle Wrapper script이다. settings.gradle : gradle build를 위해 gradle을 설정하는 script이다. Gradle Wrapper란 선언된 gradle version으로 gradle을 실행하는 script이다. 필요하다면 실행 전에 gradle 다운로드도 실행한다. gradle project의 빌드에는 Gradle Wrapper를 사용하도록 권장된다. Task / Plugin새로운 Task를 만들고 실행하는 방법에 대한 설명이 있지만 간단해서 생략하겠다. 여러가지 gradle task type을 알고 싶다면 Documentation의 왼쪽 목록 중 Task Type을 보면 된다. Plugin 적용은 이전에 작성한 build-scan을 적용하는 글을 참고하면 된다. Explore build ./gradlew tasks : 사용 가능한 모든 task를 보는 명령이다. ./gradlew properties: 프로젝트의 모든 properties를 보는 명령이다. Debug build어떤 task든 실행할 때 --scan 옵션을 주면 build scan이 적용되어 웹UI로 task의 과정을 모두 디버깅할 수 있다. build scan을 적용하는 방법은 이전 글을 확인하면 알 수 있다. gradle project 생성했을 때의 기초적인 명령들을 알 수 있었다. ./gradlew tasks나 ./gradlew properties는 정말 유용하게 사용할 수 있을 것 같다.","categories":[{"name":"build","slug":"build","permalink":"https://dlsrb6342.github.io/categories/build/"},{"name":"gradle","slug":"build/gradle","permalink":"https://dlsrb6342.github.io/categories/build/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://dlsrb6342.github.io/tags/gradle/"}]},{"title":"Gradle Guide 1. Build scan","slug":"Gradle-Guide-1-Build-scan","date":"2019-07-13T09:37:53.000Z","updated":"2021-01-30T08:34:59.180Z","comments":true,"path":"2019/07/13/Gradle-Guide-1-Build-scan/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/13/Gradle-Guide-1-Build-scan/","excerpt":"","text":"gradle.. spring을 처음 사용했을때 gradle을 썼었다(뭣도모르고 좋다니 쓴 느낌). 그 이후부터는 항상 maven을 썼고 이제는 maven의 xml이 너무 편해졌다. 그래도 혼자 공부할때나 토이 프로젝트를 할 때는 gradle을 썼다. 하지만 갓텔리제이가 처음 initializing 해주는 gradle 파일로도 충분했기에 따로 공부할 생각을 안했다. 결국 항상 가져다만 쓰던 gradle에 발목이 잡혔다. 멀티모듈 프로젝트를 구성하고 root module의 build.gradle을 어떻게 사용하는지 찾아봤는데 도대체가 답변마다 다 가지각색으로 다르게 사용하고 있다. 이걸 보고나서 ‘아 이젠 공부하고 써야겠다’ 라는 마음이 들어 gradle 공식문서의 guide들을 공부하기로 했다. 가이드 공부에 사용된 gradle 프로젝트 IntelliJ spring initializr로 생성한 간단한 spring 프로젝트이다.https://github.com/dlsrb6342/gradle-study1234567891011121314&gt; ./gradlew --version------------------------------------------------------------Gradle 5.4.1------------------------------------------------------------Build time: 2019-04-26 08:14:42 UTCRevision: 261d171646b36a6a28d5a19a69676cd098a4c19dKotlin: 1.3.21Groovy: 2.5.4Ant: Apache Ant(TM) version 1.9.13 compiled on July 10 2018JVM: 12.0.1 (Azul Systems, Inc. 12.0.1+12)OS: Mac OS X 10.14.4 x86_64 Gradle Guide 1. Creating Build Scans 공식 가이드 : https://guides.gradle.org/creating-build-scans/ 1번부터 처음보는 것이다. 여태까지 정말 막 써 왔구나를 느낀다. 이 가이드에서는 별다른 수정이나 설정없이 build scan ad-hoc을 적용하는 방법에 대해 배운다. Upper gradle 4.3gradle 4.3 이후부터는 별다른 설정없이 ./gradlew build --scan을 입력하면 build scan을 사용할 수 있다고 한다. 는 개구라였다 ㅋㅋㅋㅋ 안된다!!! gradle 관련 글들이 너무 가지각색이라 공식 문서로 찾아왔는데 공식문서도 안된다 ㅋㅋㅋㅋㅋㅋ ./gradlew build --help를 쳐보니 build scan plugin을 넣어야한다고 한다. 123456&gt; ./gradlew biuld --help...--scan Creates a build scan. Gradle will emit a warning if the build scan plugin has not been applied. (https://gradle.com/build-scans)... 사실 이 글을 다 쓰고 build-scan plugin 제거하고 다시 ./gradlew build --scan을 입력해봤는데 plugin없이도 된다.. 뭐가 문제였는지 모르겠다 ㅠㅠ build-scan plugin추가하는 방법은 간단하다. build.gradle에 plugins 안에 넣어주면 된다. 만약 현재 사용중인 plugin이 있다면 build-sacn을 가장 위에 놓아야 한다. 아래 넣어도 똑같이 동작하지만 모든 build 과정을 scan하지 못하게 된다.1234// build.gradleplugins &#123; id &#x27;com.gradle.build-scan&#x27; version &#x27;2.1&#x27; &#125;plugin을 추가하고 나서 ./gradlew build --scan을 입력하면 잘 동작한다.123456789&gt; ./gradlew build --scan...Publishing a build scan to scans.gradle.com requires accepting the Gradle Terms of Service defined at https://gradle.com/terms-of-service. Do you accept these terms? [yes, no] yesGradle Terms of Service accepted.Publishing build scan...https://gradle.com/s/&#123;어쩌구저쩌구&#125;아래 주소에 url에 들어가면 이메일 주소를 입력하게 되고 scan결과를 보여주는 url을 메일로 받을 수 있다. 보여주는 것도 깔끔하고 실행시간, 콜솔 로그 등등 엄청 많은 정보가 들어있어 디버깅하기 좋아보인다. License Agreementbuild scan의 귀찮은 점은 build가 끝나고 항상 license agreement에 yes라고 타이핑해줘야 한다는 점이다. 이것 또한 항상 동의할 수 있도록 설정할 수 있다.12345// build.gradlebuildScan &#123; termsOfServiceUrl = &#x27;https://gradle.com/terms-of-service&#x27; termsOfServiceAgree = &#x27;yes&#x27;&#125;기존 프로젝트에 별다른 추가 사항은 없지만 따로 관리하기 위해 이번 build-scan 가이드는 https://github.com/dlsrb6342/gradle-study/tree/guide-1-build-scan에 올려두었다.gradle build가 너무 오래 걸리거나 혹은 오류를 뱉어낸다면 정말 유용한 툴이 될 수 있을 것 같다. 첫 가이드부터 좋은 글인거 같아 다음 가이드들이 기대된다.","categories":[{"name":"build","slug":"build","permalink":"https://dlsrb6342.github.io/categories/build/"},{"name":"gradle","slug":"build/gradle","permalink":"https://dlsrb6342.github.io/categories/build/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://dlsrb6342.github.io/tags/gradle/"}]},{"title":"Effective Java 3rd ITEM 66 67 68","slug":"Effective-Java-3rd-ITEM-66-67-68","date":"2019-07-13T05:57:25.000Z","updated":"2021-01-30T08:34:59.175Z","comments":true,"path":"2019/07/13/Effective-Java-3rd-ITEM-66-67-68/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/13/Effective-Java-3rd-ITEM-66-67-68/","excerpt":"","text":"ITEM 66. Use native methods judiciouslyJNI(Java Native Interface)는 네이티브 메서드를 호출할 수 있게 해주는 기술이다. 네이티브 메서드란 C나 C++로 작성한 네이티브 프로그래밍 언어로 작성한 메서드를 말한다. 네이티브 메서드는 레지스트리같은 플랫폼 특화된 기능을 사용할때, 기존 라이브러리를 사용할때, 성능 개선을 목적으로 사용할때, 이렇게 3가지 경우에 주로 사용한다. 1. 플랫폼 특화된 기능 / 기존 라이브러리 사용자바가 발전하면서 OS같은 하부 플랫폼의 기능들을 점차 사용할 수 있게 되었다. java9에서 process API가 추가되어 OS process에 접근할 수 있게 되었다. 대체할만한 자바 라이브러리가 없을 경우엔 네이티브 메서드를 사용해야 한다. 2. 성능 개선성능 개선을 목적으로 사용하는건 권장하지 않는다. JVM의 발전으로 네이티브 구현보다도 빨라진 부분도 있다.네이티브 메서드는 안전하지 않아 메모리 훼손 오류가 있을 수 있고 플랫폼을 많이 타서 이식성도 낮다. 디버깅도 어렵고 속도가 오히려 느려질 수 있다. 네이티브 메모리는 GC가 자동회수 하지 못하고 추적도 못해 위험할 수 있다. 네이티브 메서드와 자바 코드 사이의 접착 코드도 작성해야 하며, 넘나들때 비용도 추가된다. =&gt; 네이티브 메서드를 사용하려거든 다시 한번 더 생각해보자. ITEM 67. Optimize judiciously성능 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고 프로그램의 견고한 구조를 망가뜨릴 수 있다.=&gt; 빠른 프로그램보다는 좋은 프로그램을 작성하자. 아키텍처 - 성능그렇다고 성능을 무시하라는 것이 아니다. 최적화는 나중에 해결할 수 있지만 아키텍처가 망가지면 선능을 제한할 수 있다. 또 성능을 위해 아키텍처 설계의 기본 틀을 변경하려다 보면 유지보수가 어려운 구조의 시스템이 만들어지기 쉽다. 따라서 아키텍처 설계 과정에서 성능을 반드시 염두해야 한다. 성능을 제한하는 설계를 피하라. API를 설계할 때 성능에 주는 영향을 고려하라. 신중한 설계로 멋진 구조를 갖춘 프로그램을 완성한 후에 성능 최적화를 생각하자. 각각의 최적화 시도 전후로 성능을 측정하라. ITEM 68. Adhere to generally accepted naming conventions패키지 각 요소를 점(.)으로 구분하여 계층적으로 짓는다. 모두 소문자 알파벳 혹은 숫자로 이뤄진다. 8자 이하의 짧은 단어로 한다. 클래스와 인터페이스 하나 이상의 단어로 이뤈진다. 각 단어는 대문자로 시작한다. 통용되는 줄임말을 제외하고는 줄여 쓰지 않는다. 메서드와 필드 이름 첫글자를 소문자로 쓴다. 나머지 규칙은 클래스와 같다. 상수 필드 모두 대문자로 쓰며 단어 사이는 밑줄로 구분한다. 타입 매개변수 보통 한문자로 표현한다. T : Type / E : Element / K : Key / V : Value / X : eXception / R : Return","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"9. General Programming","slug":"Effective-Java-3rd/9-General-Programming","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/9-General-Programming/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 63 64 65","slug":"Effective-Java-3rd-ITEM-63-64-65","date":"2019-07-13T05:40:42.000Z","updated":"2021-01-30T08:34:59.175Z","comments":true,"path":"2019/07/13/Effective-Java-3rd-ITEM-63-64-65/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/13/Effective-Java-3rd-ITEM-63-64-65/","excerpt":"","text":"ITEM 63. Beware the performance of string concatenation문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례한다.=&gt; StringBuilder를 사용하자! ITEM 64. Refer to objects by their interfaces매개변수 반환값 변수 필드 등 전부 인터페이스 타입으로 선언하는 것이 좋다. 프로그램을 훨씬 유연하게 만들 수 있다.적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스를 타입으로 사용하자! ITEM 65. Prefer interfaces to reflection리플렉션(java.lang.reflect)를 사용하면 클래스의 생성자 메서드 필드에 해당하는 인스턴스를 꺼낼 수 있고 그에 해당하는 정보를 가져올 수 있다. 클래스의 거의 모든 것을 조작하고 호출할 수 있다. 리플렉션의 단점 컴파일타임의 타입 검사의 이점을 누릴 수 없다. 코드가 지저분해지고 장황해진다. 성능이 떨어진다. 컴파일 타임에 알 수 없는 클래스를 사용해야 한다면 리플렉션을 사용할 수 밖에 없을 것이다. 이 경우에도 객체 생성에만 리플렉션을 사용하고 객체를 사용할 때는 적절한 인터페이스나 상위 클래스로 사용하자.=&gt; 리플렉션은 단점을 피하고 이점만 취할 수 있는 아주 제한된 형태로만 사용하자!","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"9. General Programming","slug":"Effective-Java-3rd/9-General-Programming","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/9-General-Programming/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 60 61 62","slug":"Effective-Java-3rd-ITEM-60-61-62","date":"2019-07-10T13:44:50.000Z","updated":"2021-01-30T08:34:59.174Z","comments":true,"path":"2019/07/10/Effective-Java-3rd-ITEM-60-61-62/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/10/Effective-Java-3rd-ITEM-60-61-62/","excerpt":"","text":"ITEM 60. Avoid float and double if exact answers are requiredfloat와 double은 부동소수점 연산에 쓰이고 과학과 공학 계산용으로 설계되었다. 따라서 정확한 결과가 필요할 때는 적절치 않다. 따라서 올바른 값을 얻기 위해서는 BigDecimal이나 int 혹은 long을 사용해야 한다. BigDecimalBigDecimal은 정확한 값을 얻을 수 있지만 기본 타입보다 쓰기 불편하고 느리다. 그 대안으로 int 혹은 long을 쓸 수 있다. int 혹은 longint 혹은 long은 정확한 값을 얻을 수 있고 기본 타입이라 편하고 속도도 좋다. 하지만 값의 크기가 제한되고 소수점을 직접 관리해야 한다. ITEM 61. Prefer primitive types to boxed primitives기본 타입과 박싱된 기본 타입의 차이 기본 타입은 값만 / 박싱된 기본 타입은 값과 식별성을 갖는다. 기본 타입의 값은 언제나 유효 / 박싱된 기본 타입은 null을 가질 수 있다. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다. 주의할점 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다. 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 오토언박싱이 일어나 NPE가 발생할 수 있다. 박싱과 언박싱이 반복해서 일어나면 성능이 굉장히 느려진다. ITEM 62. Avoid strings where other types are more appropriate 문자열은 다른 값 타입(boolean / int / long …)을 대신하기에 적합하지 않다. 문자열은 열거 타입을 대신하기에 적합하지 않다. 문자열은 혼합 타입을 대신하기에 적합하지 않다. 문자열은 권한을 표현하기에 적합하지 않다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"9. General Programming","slug":"Effective-Java-3rd/9-General-Programming","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/9-General-Programming/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 57 58 59","slug":"Effective-Java-3rd-ITEM-57-58-59","date":"2019-07-10T13:10:59.000Z","updated":"2021-01-30T08:34:59.170Z","comments":true,"path":"2019/07/10/Effective-Java-3rd-ITEM-57-58-59/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/10/Effective-Java-3rd-ITEM-57-58-59/","excerpt":"","text":"ITEM 57. Minimize the scope of local variables지역변수의 범위를 최소화하면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다. 지역 변수가 가장 처음 쓰일 때 선언하자. 거의 모든 지역변수는 선언과 동시에 초기화하자. 메서드를 작게 유지하고 한 가지 기능에 집중하자. ITEM 58. Prefer for-each loops to traditional for loopsIterator를 사용한 for문이나 인덱스 변수로인한 for문은 코드를 지저분하게 하고 오류가 생길 가능성이 높아진다. 또 컬렉션 / 배열에 따라 코드 형태도 달라지는 문제점이 있다. for-each문을 사용하면 이 모든 문제를 해결할 수 있다. 또한 for-each문은 사람이 손으로 최적화한 것과 같은 성능을 낸다. ITEM 59. Know and use the libraries표준 라이브러리 사용의 이점 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다. 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다. 따로 노력하지 않아도 성능이 지속해서 개선된다. 기능이 점점 많아진다. 우리가 작성한 코드가 많은 사람에게 낯익은 코드가 된다. java.lang / java.util / java.io 는 잘 알아두자! 특히 java.util.stream / java.util.Collections / java.util.concurrent는 능숙하게 다룰 수 있게 하자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"9. General Programming","slug":"Effective-Java-3rd/9-General-Programming","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/9-General-Programming/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Spring Content Logging","slug":"Spring-Content-Logging","date":"2019-07-02T12:55:05.000Z","updated":"2021-01-30T08:34:59.265Z","comments":true,"path":"2019/07/02/Spring-Content-Logging/","link":"","permalink":"https://dlsrb6342.github.io/2019/07/02/Spring-Content-Logging/","excerpt":"","text":"Spring Content Logging요구사항은 간단하다. Request body와 Response body를 로깅하는 것이다. 생각보다 간단했다. Servlet Wrapperspring boot에서는 기본적으로 RequestPacade / ResponsePacade로 SevletRequest / ServletResponse가 들어온다. 이를 Content Caching Wrapper로 감싸주기만 하면 된다. spring-web에 이미 ContentCachingRequestWrapper와 ContentCachingResponseWrapper가 구현되어있다.물론 원하는대로 직접 구현해도 되지만 spring이 예쁘게 구현해두었으니 활용해보자. CustomServletWrapperFilter12345678910111213141516@Componentpublic class CustomServletWrappingFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; ContentCachingRequestWrapper wrappingRequest = new ContentCachingRequestWrapper(request); ContentCachingResponseWrapper wrappingResponse = new ContentCachingResponseWrapper(response); chain.doFilter(wrappingRequest, wrappingResponse); wrappingResponse.copyBodyToResponse(); &#125;&#125; Servlet을 wrapping해주는 filter를 구현했다. OncePerRequestFilter를 상속받아 한 reuqest당 한번의 실행만 되도록 보장하였다. spring bean으로 등록해두면 Filter 적용은 끝난다. 가장 중요한 점은 마지막 줄에 있다. wrappingResponse.copyBodyToResponse()로 실제 response body에다가 값을 넣어주어야 한다. 이 코드를 안넣어주면 클라이언트가 아무 응답도 받지 못하게 된다. LoggingInterceptor1234567891011121314151617181920212223@Slf4j@RequiredArgsConstructor@Componentpublic class LoggingInterceptor extends HandlerInterceptorAdapter &#123; private final ObjectMapper objectMapper; @Override public void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; final ContentCachingRequestWrapper cachingRequest = (ContentCachingRequestWrapper) request; final ContentCachingResponseWrapper cachingResponse = (ContentCachingResponseWrapper) response; log.info( &quot;ReqBody : &#123;&#125; / ResBody : &#123;&#125;&quot;, objectMapper.readTree(cachingRequest.getContentAsByteArray()), objectMapper.readTree(cachingResponse.getContentAsByteArray()) ); &#125;&#125; logging은 interceptor로 구현하였다. 이 코드는 간단하게 구현하느라 validation들을 모두 제외하였다. 직접 구현할 때는 wrapping이 안됐을 경우나 caching된 content가 없을 경우 등, 검증해야 할 부분이 많다.caching된 content는 byte array로 들고 있기 때문에 objectMapper를 이용해 JsonNode로 읽어주고 로깅했다. TestSample code는 https://github.com/dlsrb6342/blog-sample/tree/master/spring-content-caching 에서 확인할 수 있다.아래 예시와 같이 request body / response body logging을 할 수 있다.1234567891011121314&#x2F;&#x2F; requestcurl -X POST \\ http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;test \\ -H &#39;Content-Type: application&#x2F;json&#39; \\ -d &#39;&#123; &quot;foo&quot;: &quot;foo&quot;, &quot;bar&quot;: &quot;bar&quot;&#125;&#39;&#x2F;&#x2F; response&#123;&quot;result&quot;:&quot;test&quot;,&quot;code&quot;:100&#125;&#x2F;&#x2F; logging result2019-07-02 22:44:21.195 INFO 15920 --- [nio-8080-exec-1] c.c.caching.demo.LoggingInterceptor : ReqBody : &#123;&quot;foo&quot;:&quot;foo&quot;,&quot;bar&quot;:&quot;bar&quot;&#125; &#x2F; ResBody : &#123;&quot;result&quot;:&quot;test&quot;,&quot;code&quot;:100&#125;","categories":[{"name":"spring-mvc","slug":"spring-mvc","permalink":"https://dlsrb6342.github.io/categories/spring-mvc/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://dlsrb6342.github.io/tags/spring/"}]},{"title":"spring-cloud-gateway Custom Filter","slug":"spring-cloud-gateway-Custom-Filter","date":"2019-06-30T14:01:11.000Z","updated":"2021-01-30T08:34:59.272Z","comments":true,"path":"2019/06/30/spring-cloud-gateway-Custom-Filter/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/30/spring-cloud-gateway-Custom-Filter/","excerpt":"","text":"spring-cloud-gateway Custom Filterspring-cloud-gateway에서 Custom Filter 추가하는 방법에 대해 정리해보았다. Add shortcutFieldspring-cloud-gateway를 쓰면서 정말 편하다고 생각했던 부분은 yml에도 custom으로 추가한 Filter나 Predicate를 쓸 수 있다는 점이다.**GatewayFilterFactory / **RoutePredicateFactory라고 이름을 지어줬다면 postfix를 제거한 이름으로 yml에서 사용할 수 있다. 물론 Bean으로 등록해줘야 한다. 여기서 더 발전하여 custom Factory에서도 shortcut field를 사용할 수 있다.123456789# shortcut fieldfilters: - StripPrefix=2# without shortcut fieldfilters: - name: StripPrefix args: parts: 2위 yaml은 기본구현체인 StripPrefixGatewayFilterFactory를 shortcut을 쓴 예시와 안쓴 예시의 설정이다. shortcut field를 쓰면 조금 더 간단하게 설정을 할 수가 있다.이를 구현하는것은 간단하다.1234567891011121314151617public class CustomGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;Config&gt; &#123; public static final String FOO_KEY = &quot;foo&quot;; public static final String BAR_KEY = &quot;bar&quot;; @Override public List&lt;String&gt; shortcutFieldOrder() &#123; return List.of(FOO_KEY, BAR_KEY); &#125; public static class Config &#123; private String foo; private String bar; &#125;&#125;// Custom=foo_value,bar_valueshortcutFieldOrder()를 override해주면 된다. 반환값은 Config class의 field의 이름들을 담은 리스트이다. 마지막줄의 주석처럼 yaml 설정 파일에서 foo의 값, bar의 값을 순서대로 넣어주면 된다!shortcut field를 사용하면 간단해서 좋긴 하지만, 그 값이 무슨 field를 뜻하는지 한눈에 보기 어려운 단점이 있는듯하다. field가 하나이거나 의미가 명확한 경우 사용하면 좋을 것 같다. Add Orderspring-cloud-gateway에서는 filter들에게 순서를 줄 수 있다. 명시해주지 않는다면 yaml 설정에 적어준 순서대로 0, 1, 2, … 의 order 값을 받게 된다.1234567891011// RouteDefinitionRouteLocator.javaArrayList&lt;GatewayFilter&gt; ordered = new ArrayList&lt;&gt;(filters.size());for (int i = 0; i &lt; filters.size(); i++) &#123; GatewayFilter gatewayFilter = filters.get(i); if (gatewayFilter instanceof Ordered) &#123; ordered.add(gatewayFilter); &#125; else &#123; ordered.add(new OrderedGatewayFilter(gatewayFilter, i + 1)); &#125;&#125; @Order / Orderedcustom filter에 순서를 넣어주고자 할때 가장 먼저 드는 생각은 @Order annotation이나 Ordered를 implement하는 것일 것이다.1234@Order(100)public class CustomGatewayFilterFactory &#123; &#125;public class CustomGatewayFilterFactory implement Ordered &#123; &#125;하지만 이런 방법은 filter에 순서를 넣어주지 못한다. Filter가 아닌 FilterFactory에게 순서를 넣어줬을 뿐이다. 따라서 이를 위해 spring-cloud-gateway가 지원하는 OrderedGatewayFilter를 사용해야 한다. OrderedGatewayFilter12345678910public class CustomGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;Config&gt; &#123; @Override public GatewayFilter apply(Config config) &#123; return new OrderedGatewayFilter((exchange, chain) -&gt; &#123; // ... return chain.filter(exchange); &#125;, Ordered.HIGHEST_PRECEDENCE); &#125;&#125; 위 예시는 가장 높은 우선순위를 주어 구현한 OrderedGatewayFilter이다. 이 GatewayFilterFacotyr를 사용하면 가장 먼저 이 filter를 타게 된다.사실 난 처음엔 OrderedGatewayFilter의 존재를 몰랐고 왜 GatewayFilterFactory의 Order를 받지 않는지 의문이 생겼었다. 그래서 spring-cloud-gateway에 issue를 남겼었다. 올리고나서 OrderedGatewayFilter를 발견했고 코멘트로도 이것을 사용하라는 가이드를 받았다. Sample Source Codehttps://github.com/dlsrb6342/blog-sample/tree/master/spring-cloud-gateway-custom-filterShortCut field와 OrderedGatewayFilter를 사용한 sample custom filter code이다. 가장 높은 우선순위를 준 filter가 설정에 상관없이 항상 먼저 실행되는 것을 확인할 수 있을 것이다.","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"https://dlsrb6342.github.io/categories/spring-cloud/"},{"name":"spring-cloud-gateway","slug":"spring-cloud/spring-cloud-gateway","permalink":"https://dlsrb6342.github.io/categories/spring-cloud/spring-cloud-gateway/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://dlsrb6342.github.io/tags/spring/"},{"name":"spring-cloud","slug":"spring-cloud","permalink":"https://dlsrb6342.github.io/tags/spring-cloud/"}]},{"title":"Effective Java 3rd ITEM 56","slug":"Effective-Java-3rd-ITEM-56","date":"2019-06-30T09:08:17.000Z","updated":"2021-01-30T08:34:59.169Z","comments":true,"path":"2019/06/30/Effective-Java-3rd-ITEM-56/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/30/Effective-Java-3rd-ITEM-56/","excerpt":"","text":"ITEM 56. Write doc comments for all exposed API elementsjavadoc 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다. 비공개 클래스에도 유지보수를 위해 주석을 달자. 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다. how가 아닌 what을 기술하자. 전제조건 / 사후조건 모두 나열. 부작용도 문서화하자. @param / @return / @throws 활용 재정의한 메서드는 @implSpec으로 어떻게 동작하는지 명시하자. 제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다. 열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다. 에너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다. 패키지 설명은 package-info.java에 / 모듈 설명은 module-info.java에 작성하면 된다. 클래스의 스레드 안전성과 직렬화 형태도 기술해야 한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"8. Methods","slug":"Effective-Java-3rd/8-Methods","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/8-Methods/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 55","slug":"Effective-Java-3rd-ITEM-55","date":"2019-06-30T08:50:40.000Z","updated":"2021-01-30T08:34:59.168Z","comments":true,"path":"2019/06/30/Effective-Java-3rd-ITEM-55/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/30/Effective-Java-3rd-ITEM-55/","excerpt":"","text":"ITEM 55. Return optionals judiciouslyOptionaljava8이전에 값을 반환할 수 없을때는 null을 반환하거나 예외를 던져야 했다. 하지만 java8부터 Optional&lt;T&gt;이 추가되었고 값이 없을때는 Optional에 빈 결과를 담아 반환하면 된다. Optional은 사용자에게 값이 없을 수도 있음을 명확히 알려주는 취지다. orElse orElseThrow orElseGet isPresent … Optional에는 위와같이 다양한 메서드들이 있으니 값이 없을때를 대비하여 설계하자. Optional은 결과가 없을 수 있으며, 클라이언트가 이 상황을 따로 처리해야 할때 사용하자. 어느정도 성능 저하가 있을 수 있으므로 성능이 민감한 메서드는 null을 반환하자. Optional with Container typeOptional은 컨테이너 타입과는 사용하면 안된다. 빈 Optional&lt;List&lt;T&gt;&gt;를 반환하기 보다는 빈 List&lt;T&gt;를 반환하는 것이 클라이언트 입장에서 Optional 처리를 안해도 되기 때문에 더 좋다. Optional with Boxing type박싱된 기본 타입을 담은 Optional은 사용하지 말자. 기본 타입을 박싱하고 다시 Optional로 감싸면 더욱 무겁기 때문이다. Optional&lt;T&gt;가 아닌 OptionalInt / OptionalLong / OptionalDouble을 사용하자. Optional in CollectionOptional을 컬렉션의 키 / 값 / 원소로 사용하는 것은 적절치 않다. 쓸데없이 복잡해 혼란을 주고 오류 가능성만 키울 뿐이다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"8. Methods","slug":"Effective-Java-3rd/8-Methods","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/8-Methods/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 54","slug":"Effective-Java-3rd-ITEM-54","date":"2019-06-30T08:32:38.000Z","updated":"2021-01-30T08:34:59.167Z","comments":true,"path":"2019/06/30/Effective-Java-3rd-ITEM-54/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/30/Effective-Java-3rd-ITEM-54/","excerpt":"","text":"ITEM 54. Return empty collections or arrays, not nulls12345678910111213141516private final List&lt;Cheese&gt; cheesesInStock = ...;/*** @return a list containing all of the cheeses in theshop,* or null if no cheeses are available for purchase.*/public List&lt;Cheese&gt; getCheeses() &#123; return cheesesInStock.isEmpty() ? null : new ArrayList&lt;&gt;(cheesesInStock);&#125;List&lt;Cheese&gt; cheeses = shop.getCheeses();if (cheeses != null &amp;&amp; ... ) &#123; ...&#125; getCheeses() 메서드가 null을 반환하기 때문에 그 메서드를 사용하는 클라이언트는 항상 null check를 해주어야 한다. 이때문에 코드도 더 복잡해지고 만약 check하지 않았다면 오류가 발생할 수도 있다.=&gt; null 대신 empty Collection을 반환하자 Empty Collection을 반환하는 것이 성능을 떨어뜨릴 수 있다고 얘기하지만 사실이 아니다. 이정도의 성능 차이는 신경 쓸 수준이 못 된다. 새로 빈 컬렉션을 할당하지 않고도 반환할 수 있다. new ArrayList&lt;&gt;(cheesesInStock); / Collections.emptyList(); 와 같이 사용한다면 성능 저하는 없을 것이다.배열의 경우도 마찬가지이다. null보다는 길이 0짜리 배열을 반환하자.123public Cheese[] getCheeses() &#123; return cheesesInStock.toArray(new Cheese[0]);&#125;매번 new Cheese[0]하는 것이 성능을 떨어뜨릴 것 같다면 길이가 0인 배열을 미리 선언해두고 사용하자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"8. Methods","slug":"Effective-Java-3rd/8-Methods","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/8-Methods/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 53","slug":"Effective-Java-3rd-ITEM-53","date":"2019-06-30T08:18:05.000Z","updated":"2021-01-30T08:34:59.166Z","comments":true,"path":"2019/06/30/Effective-Java-3rd-ITEM-53/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/30/Effective-Java-3rd-ITEM-53/","excerpt":"","text":"ITEM 53. Use varargs judiciously가변인수 메서드는 인수를 0개 이상 받을 수 있는 메서드이다. 인수들을 배열에 저장하여 메서드에 전달해준다. 가변인수가 1개 이상 필요할때가변인수가 1개 이상이어야 할 때는 인수로 가변인수만 받게 설계하는 것은 좋지 않다.123456789static int min(int... args) &#123; if (args.length == 0) throw new IllegalArgumentException(&quot;Too few arguments&quot;); int min = args[0]; for (int i = 1; i &lt; args.length; i++) if (args[i] &lt; min) min = args[i]; return min;&#125;위 코드는 1개 이상의 가변인수를 받아 최솟값을 반환하는 메서드이다. 이 메서드는 0개의 인수를 받았을때 런타임 예외가 발생하는 점과 명시적인 유효성 검사를 해야하는 등 여러 문제점이 있다. 이럴 경우에는 첫 번째 인수로 평범한 매겨변수를 받고, 두 번째 인수에 가변인수를 받으면 해결된다.1234567static int min(int firstArg, int... args) &#123; int min = firstArg; for (int arg : args) if (arg &lt; min) min = arg; return min;&#125; 성능에 민감한 상황만약 성능에 민감한 상황에서 가변인수를 사용해야 한다면 배열을 새로 하나 할당하고 초기화하는 가변인수는 걸림돌이 될 수 있다.이럴 경우에는 인수가 0개인 것부터 4개인 것까지 만들어주면 그나마 성능을 올릴 수 있다.12345public void foo() &#123;&#125;public void foo(int a1) &#123;&#125;public void foo(int a1, int a2) &#123;&#125;public void foo(int a1, int a2, int a3) &#123;&#125;public void foo(int a1, int a2, int a3, int... rest) &#123;&#125;","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"8. Methods","slug":"Effective-Java-3rd/8-Methods","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/8-Methods/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 52","slug":"Effective-Java-3rd-ITEM-52","date":"2019-06-30T07:43:58.000Z","updated":"2021-01-30T08:34:59.165Z","comments":true,"path":"2019/06/30/Effective-Java-3rd-ITEM-52/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/30/Effective-Java-3rd-ITEM-52/","excerpt":"","text":"ITEM 52. Use overloading judiciouslyOverloading으로 인한 혼란123456789101112131415161718192021222324public class CollectionClassifier &#123; public static String classify(Set&lt;?&gt; s) &#123; return &quot;Set&quot;; &#125; public static String classify(List&lt;?&gt; lst) &#123; return &quot;List&quot;; &#125; public static String classify(Collection&lt;?&gt; c) &#123; return &quot;Unknown Collection&quot;; &#125; public static void main(String[] args) &#123; Collection&lt;?&gt;[] collections = &#123; new HashSet&lt;String&gt;(), new ArrayList&lt;BigInteger&gt;(), new HashMap&lt;String, String&gt;().values() &#125;; for (Collection&lt;?&gt; c : collections) System.out.println(classify(c)); &#125;&#125; 위 코드는 &quot;Set&quot;, &quot;List&quot;, &quot;Unknown Collection&quot;을 출력하길 기대하고 작성된 코드지만 결과는 모두 &quot;Unknown Collection&quot;을 출력한다. 그 이유는 다중 정의된 세 classify 중 어느 메서들를 호출할지가 컴파일 타임에 정해지기 때문이다. 컴파일 타임에 for문의 c는 모두 Collection 타입이다. 따라서 모두 &quot;Unknown Collection&quot;을 출력하는 것이다. Overriding 메서드는 동적으로(런타임에) 선택되고 Overloading한 메서드는 정적으로(컴파일 타임에) 선택된다. Overloading한 메서드는 객체의 런타임 타입은 전혀 중요하지 않고 컴파일 타임의 타입에 의해 선택된다. 위 CollectionClassifier처럼 다중정의가 혼동을 일으키는 상황은 피해야 한다. 안전하고 보수적으로 하려면 매개변수 수가 같은 다중정의는 만들지 말고 가변인수를 사용하는 메서드에서는 다중정의를 아예 사용하지 말아야 한다. Overloading의 대안 메서드 이름을 다르게 지어주자.ObjectOutputStream 클래스를 보면 다중정의를 하는 대신 writeBoolean / writeInt / writeLong 같이 이름으로 나누어주었다. readBoolean / readInt / readLong 과 짝을 맞추기도 좋다. 정적 팩터리생성자의 경우 이름을 다르게 할 수 없기 때문에 여러 생성자가 있다면 다중정의가 된다. 이럴 경우엔 정적 팩터리 메서드를 사용하면 이름을 구분할 수 있다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"8. Methods","slug":"Effective-Java-3rd/8-Methods","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/8-Methods/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 51","slug":"Effective-Java-3rd-ITEM-51","date":"2019-06-28T14:02:59.000Z","updated":"2021-01-30T08:34:59.164Z","comments":true,"path":"2019/06/28/Effective-Java-3rd-ITEM-51/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/28/Effective-Java-3rd-ITEM-51/","excerpt":"","text":"ITEM 51. Design method signatures carefully메서드 이름메서드 이름은 신중히 짓자. 표준 명명 규칙을 따라야 하고 패키지에 따라 일관되어야 하고 너무 긴 이름은 피해야 한다. 편의 메서드너무 많은 편의 메서드를 만들지 말자. 메서드가 너무 많으면 클래스를 사용하는 입장에서 여러가지로 어려운 점이 많다. 매개변수매개변수 목록은 짧게 유지하자. 4개가 넘어가면 전부 기억하기가 어렵다. 또 같은 타입의 매개변수가 반복되는 경우가 특히 좋지 않다. 순서를 기억하기도 어렵고 실수로 바꿔 썼을때 오류가 나지 않기 때문이다. 매개변수 타입매개변수의 타입으로는 클래스보다 인터페이스를 사용하는 것이 낫다. 적합한 인터페이스가 있다면 직접 그 인터페이스를 사용하자. booleanboolean보다는 원소 2개를 가진 열거타입을 사용하자. 열거 타입을 사용하면 코드를 읽고 쓰기가 더 쉬워진다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"8. Methods","slug":"Effective-Java-3rd/8-Methods","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/8-Methods/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"spring-cloud-config Auto Refresh","slug":"spring-cloud-config-Auto-Refresh","date":"2019-06-28T13:11:26.000Z","updated":"2021-01-30T08:34:59.271Z","comments":true,"path":"2019/06/28/spring-cloud-config-Auto-Refresh/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/28/spring-cloud-config-Auto-Refresh/","excerpt":"","text":"spring-cloud-gateway를 사용하면서 Dynamic Properties를 사용하고 싶어 spring-cloud-config도 같이 사용하기로 했다. https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html Refresh 이슈설정된 PropertySource를 refresh 해주려면 Actuator API를 하나하나 다 요청해주어야 한다. 여러 머신에 여러 인스턴스가 떠있는 상황이었기에 하나하나 다 찔러주는건 무리가 있었다. 1. spring-cloud-bus이런 상황을 위해 spring-cloud-bus가 있다. mq를 써서 각 인스턴스마다 refresh 이벤트를 전달해준다. https://www.baeldung.com/spring-cloud-bus 하지만 spring-cloud-bus까지 도입하자니 운영해야할 것들이 너무 많이 늘어나게 된다. 2. ConfigClientWatch이전 프로젝트에서 Dynamic Properties를 위해 CentralDogma를 사용한 적이 있다. CentralDogma에는 Watcher 구현체가 있어서 spring-cloud-config-client에도 있지 않을까?하는 생각에 코드를 뒤져봤다.ConfigClientWatch가 있었다! spring.cloud.config.watch.enabled 값을 true로 설정해주면 된다. 하지만…123456789// https://github.com/spring-cloud/spring-cloud-config/blob/f24f02395153761236b102786a15450a48fe0b10/spring-cloud-config-client/src/main/java/org/springframework/cloud/config/client/ConfigClientWatch.java#L65-L72String newState = this.environment.getProperty(&quot;config.client.state&quot;);String oldState = ConfigClientStateHolder.getState();// only refresh if state has changedif (stateChanged(oldState, newState)) &#123; ConfigClientStateHolder.setState(newState); this.refresher.refresh();&#125;내부 로직을 보면 ConfigClientWatch는 config.client.state 값을 보고 변경되었는지 체크한다. 하지만 이 state 값은 Vault를 Backend로 사용했을 때만 존재한다. 따라서 git을 Backend로 사용하고 있는 난 사용할 수 없었다. 3. Version?Git을 Backend로 썼을 때는 방법이 없을까 하고 열심히 코드를 뒤져봤다.그러다 config.client.state 값은 config client가 config server로부터 받은 결과에서 꺼내서 직접 property에 put하고 있다는것을 발견했다.Environment 클래스가 config server로부터 받은 결과이고 이 안에 state와 version이 있다.그 결과를 받은 config client는 아래 코드와 같이 직접 property를 넣어주고 있다.123// https://github.com/spring-cloud/spring-cloud-config/blob/79cd1100d1399cd880ea5c89577de1ed8f80396b/spring-cloud-config-client/src/main/java/org/springframework/cloud/config/client/ConfigServicePropertySourceLocator.java#L118-L119putValue(map, &quot;config.client.state&quot;, result.getState());putValue(map, &quot;config.client.version&quot;, result.getVersion());state뿐만 아니라 version을 넣어주고 있었고 테스트를 해보니 Git을 Backend로 사용했을때 config server가 이 값을 git HEAD의 checksum으로 전달해주고 있었다. 따라서 config.client.state 값이 아닌 config.client.version을 확인한다면 똑같이 refresh의 효과를 볼 수 있을거라 생각이 들었다. 4. ConfigGitClientWatch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ConfigGitClientWatch implements Closeable, EnvironmentAware &#123; private final AtomicBoolean running = new AtomicBoolean(false); private final AtomicReference&lt;String&gt; version = new AtomicReference&lt;&gt;(); private final ContextRefresher refresher; private final ConfigServicePropertySourceLocator locator; private Environment environment; public ConfigGitClientWatch( ContextRefresher refresher, ConfigServicePropertySourceLocator locator) &#123; this.refresher = refresher; this.locator = locator; &#125; @Override public void setEnvironment(Environment environment) &#123; this.environment = environment; &#125; @PostConstruct public void start() &#123; running.compareAndSet(false, true); &#125; @Scheduled( initialDelayString = &quot;$&#123;spring.cloud.config.watch.git.initialDelay:180000&#125;&quot;, fixedDelayString = &quot;$&#123;spring.cloud.config.watch.git.delay:500&#125;&quot; ) public void watchConfigServer() &#123; if (running.get()) &#123; String newVersion = fetchNewVersion(); String oldVersion = version.get(); if (versionChanged(oldVersion, newVersion)) &#123; version.set(newVersion); refresher.refresh(); &#125; &#125; &#125; private String fetchNewVersion() &#123; CompositePropertySource propertySource = (CompositePropertySource) locator.locate(environment); return (String) propertySource.getProperty(&quot;config.client.version&quot;); &#125; private static boolean versionChanged(String oldVersion, String newVersion) &#123; return !hasText(oldVersion) &amp;&amp; hasText(newVersion) || hasText(oldVersion) &amp;&amp; !oldVersion.equals(newVersion); &#125; @Override public void close() &#123; running.compareAndSet(true, false); &#125;&#125; 직접 구현한 Git Backend spring-cloud-config-client Watch이다. commit을 할때마다 refresh가 잘 되는걸 확인했다. Scheduled annotation을 사용했기 때문에 Configuration이나 Application 클래스에 EnableScheduling annotation을 달아주어야 한다. 5. Issue 등록 / PR 까지Default Backend를 git으로 사용하고 있는데 Git Watch가 없는게 이상하기도 하고 ConfigClientWatch에 대해 Vault만을 위한 것이라고도 명시하지 않아 Issue를 등록했다. https://github.com/spring-cloud/spring-cloud-config/issues/1378 이슈 등록 후에 별다른 피드백이 없길래 프로젝트를 위해 만들었던 ConfigGitClientWatch를 수정하여 PR까지 올렸다. https://github.com/spring-cloud/spring-cloud-config/pull/1390 하지만 이게 필요한지 아직 확실하지 않다는 코멘트와 함께 PR은 closed되었고 이슈에는 waiting for votes 라벨이 달렸다.혹시 Git Watch가 필요하다 생각되신 분들은 이슈에 ThumbsUp 버튼 한번씩 클릭해주시면 감사하겠습니다 ㅎㅎ Source Codehttps://github.com/dlsrb6342/blog-sample/tree/master/spring-cloud-config-auto-refresh위 레포에 올려두었다. gradle 멀티모듈로 server/client를 만들고 config server는 같은 레포를 바라보고 있지만 config client가 label을 config로 지정하여 config branch를 볼 수 있게 하였다.","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"https://dlsrb6342.github.io/categories/spring-cloud/"},{"name":"spring-cloud-config","slug":"spring-cloud/spring-cloud-config","permalink":"https://dlsrb6342.github.io/categories/spring-cloud/spring-cloud-config/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://dlsrb6342.github.io/tags/spring/"},{"name":"spring-cloud","slug":"spring-cloud","permalink":"https://dlsrb6342.github.io/tags/spring-cloud/"}]},{"title":"Effective Java 3rd ITEM 50","slug":"Effective-Java-3rd-ITEM-50","date":"2019-06-27T08:58:54.000Z","updated":"2021-01-30T08:34:59.162Z","comments":true,"path":"2019/06/27/Effective-Java-3rd-ITEM-50/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/27/Effective-Java-3rd-ITEM-50/","excerpt":"","text":"ITEM 50. Make defensive copies when needed클라이언트가 클래스의 불변식을 깨뜨릴 수 있기 때문에 방어적으로 프로그래밍해야 한다. 가변 필드클래스가 가변 필드를 가질 경우, 외부에서 내부를 수정하는 일이 발생할 수 있으므로 주의해야 한다.1234567891011121314public final class Period &#123; private final Date start; private final Date end; // 생성자 public Period(Date start, Date end) &#123; this.start = start; this.end = end; &#125; public Date start() &#123; return start; &#125; public Date end() &#123; return end; &#125;&#125;위 Period 클래스는 불변으로 만들고자 설계되었다. 하지만 Date가 가변이기에 start, end의 필드가 외부에서 수정될 수 있는 위험이 있다. 생성자1234Date start = new Date();Date end = new Date();Period p = new Period(start, end);end.setYear(78); 이렇게 생성자로 넘겨준 end 값을 외부에서 수정해버리면 Period 내부의 end 값도 수정되어버린다. 따라서 생성자에서 가변 객체를 넘겨 받았을때는 Defensive Copy를 해야 한다.1234public Period(Date start, Date end) &#123; this.start = new Date(start.getTime()); this.end = new Date(end.getTime());&#125; 접근 메서드Period가 제공하는 접근 메서드 start(), end()로도 내부 값을 수정할 수가 있다.1234Date start = new Date();Date end = new Date();Period p = new Period(start, end);p.end().setYear(78);이렇게 내부 가변 객체를 꺼내 수정하는 것이 가능하기 때문에 접근 메서드도 Defensive Copy를 반환해야 한다.12public end() &#123; return new Date(end.getTime()); &#125;public start() &#123; return new Date(start.getTime()); &#125;물론 모든 경우에 Defensive copy를 해야 하는 것은 아니다. 클라이언트가 잘못 수정할 일이 없음을 신뢰한다면 Defensive copy 대신 해당 구성요소 수정 시에 책임이 클라이언트에 있다는 사실을 명시해주면 된다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"8. Methods","slug":"Effective-Java-3rd/8-Methods","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/8-Methods/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 49","slug":"Effective-Java-3rd-ITEM-49","date":"2019-06-26T10:38:46.000Z","updated":"2021-01-30T08:34:59.160Z","comments":true,"path":"2019/06/26/Effective-Java-3rd-ITEM-49/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/26/Effective-Java-3rd-ITEM-49/","excerpt":"","text":"ITEM 49. Check parameters for validity메서드와 생성자는 대부분 매개변수들이 특정 조건을 만족하기를 바란다.따라서 메서드 로직이 실행되기 전에, 즉 메서드의 시작 부분에서 매개변수의 조건을 확인한다면 잘못된 값이 넘어왔을 때 깔끔하게 예외를 던질 수 있다. 오류는 가능한 한 빨리 잡아야 한다. public / protected methodpublic / protected 메서드는 던지는 예외에 대해 문서화해야 한다. 어떤 이유로 어떤 예외를 던지는지 javadoc의 @throws 태그를 사용해 작성해주어야 한다.123456789/** ...* @throws ArithmeticException if m is less than or equal to 0*/public BigInteger mod(BigInteger m) &#123; if (m.signum() &lt;= 0) throw new ArithmeticException(&quot;Modulus &lt;= 0: &quot; + m); ... // Do the computation&#125; Objects.requireNonNulljava7에 추가된 Objects.requireNonNull을 사용하면 null 검사를 수동으로 하지 않아도 된다. 원하는 예외 메시지도 작성할 수 있고 입력 값을 그대로 반환하므로 값을 사용하는 동시에 검사도 가능하다.1this.strategy = Objects.requireNonNull(strategy, &quot;strategy&quot;);java9에서 checkFromIndexSize, checkFromToIndex, checkIndex도 추가되었는데 예외 메시지 지정은 할 수 없고 리스트와 배열에서만 사용 가능하다. private methodassert문으로 매개변수 유효성을 검증할 수 있다.1234567// Private helper function for a recursive sortprivate static void sort(long a[], int offset, int length) &#123; assert a != null; assert offset &gt;= 0 &amp;&amp; offset &lt;= a.length; assert length &gt;= 0 &amp;&amp; length &lt;= a.length - offset; ... // Do the computation&#125; 특징 실패 시 AssertionError를 던진다. 런타임에 아무런 효과가 없고 성능 저하도 없다. 런타임에 영향을 주려면 실행 시에 -ea / –enableassertions를 넣어주어야 한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"8. Methods","slug":"Effective-Java-3rd/8-Methods","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/8-Methods/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 48","slug":"Effective-Java-3rd-ITEM-48","date":"2019-06-26T09:55:41.000Z","updated":"2021-01-30T08:34:59.159Z","comments":true,"path":"2019/06/26/Effective-Java-3rd-ITEM-48/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/26/Effective-Java-3rd-ITEM-48/","excerpt":"","text":"ITEM 48. Use caution when making streams parallel동시성 프로그래밍을 할 때는 안전성(safety)과 응답 가능(liveness) 상태를 유지하기 위해 얘서야 하는데, 병렬 스트림 파이프라인 프로그래밍에서도 다를 바 없다. 데이터 소스 / limit()데이터 소스가 Stream.iterable이거나 중간 연산으로 limit()가 들어가 있다면 병렬화로는 성능 개선을 기대할 수 없다.Stream.iterable은 스트림 라이브러리가 병렬화할 방법을 찾지 못하기 때문이고, limit()은 CPU 코어가 남는다면 limit 갯수 이상으로 처리하고 필요없으면 버리게 되는데 그 이상으로 처리되는 원소들이 오래 걸릴 수 있기 때문이다. 자료구조대체로 ArrayList, HashMap, HashSet, ConcurrentHashMap이나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋게 나타난다.이 자료구조들은 데이터를 다수의 스레드로 분배하기 좋다. 이 나누는 작업은 Spliterator가 담당한다. 또 이 자료구조들은 원소들을 순차적으로 실행할 때 참조 지역성(locality of reference)가 뛰어나다. 참조 지역성이 좋으면 다량의 데이터를 벌크 연산을 병렬화할 때 캐시에 올리는 시간을 줄일 수 있다. 종단연산종단연산 또한 병렬 수행 효율에 큰 영향을 끼친다. min, max, count, sum이나 Stream의 reduce 메서드들같은 Reduction이 가장 적합한 종단 연산이고 collect 메서드같은 Mutable reduction이 병렬화에 적합하지 않다. 스트림을 잘못 병렬화하면 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.병렬화하는 것이 좋아보이더라도 수정 후에 성능지표를 확인하고 확실해졌을 때만 병렬화를 사용하자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"7. Lambdas and Streams","slug":"Effective-Java-3rd/7-Lambdas-and-Streams","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/7-Lambdas-and-Streams/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 47","slug":"Effective-Java-3rd-ITEM-47","date":"2019-06-25T11:58:26.000Z","updated":"2021-01-30T08:34:59.158Z","comments":true,"path":"2019/06/25/Effective-Java-3rd-ITEM-47/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/25/Effective-Java-3rd-ITEM-47/","excerpt":"","text":"ITEM 47. Prefer Collection to Stream as a return typeStream 인터페이스는 Iterable 인터페이스를 확장하지 않았기 때문에 for-each 문에서 사용할 수 없다.모든 API에서 Collection을 리턴한다면 Stream으로 짜려는 클라이언트가 불편하게 된다.=&gt; 스트림에서만 사용한다면 Stream=&gt; 반복문 사용이 필요하다면 Iterable=&gt; 둘다 지원해야 한다면 Collection을 재정의! 어댑터 사용123456789// stream -&gt; iterablepublic static &lt;E&gt; Iterable&lt;E&gt; iterableOf(Stream&lt;E&gt; stream) &#123; return stream::iterator;&#125;// iterable -&gt; streampublic static &lt;E&gt; Stream&lt;E&gt; streamOf(Iterable&lt;E&gt; iterable) &#123; return StreamSupport.stream(iterable.spliterator(), false);&#125; 한가지 return type으로 정해져 있다면 클라이언트는 위 두가지 어댑터를 사용해야 한다. Collection return컬렉션은 Iterable의 하위 타입이며 stream 메서드도 제공하기 때문에 두 요구사항을 모두 충족할 수 있다.반환할 시퀀스가 덩치가 크지 않다면 ArrayList나 HashSet같은 표준 컬력센 구현체를 쓰는게 최선이다.덩치가 크다면 직접 전용 컬렉션을 구현해 반환하자. 속도면에서도 어댑터 사용보다 전용 컬렉션을 사용하는것이 더 빠르다.전용 컬렉션을 구현해서 사용한 예시이다. 입력 집합의 멱집합을 전용 컬렉션에 담아 반환한다.1234567891011121314151617181920212223242526public class PowerSet &#123; public static final &lt;E&gt; Collection&lt;Set&lt;E&gt;&gt; of(Set&lt;E&gt; s) &#123; List&lt;E&gt; src = new ArrayList&lt;&gt;(s); if (src.size() &gt; 30) throw new IllegalArgumentException(&quot;Set too big&quot; + s); return new AbstractList&lt;Set&lt;E&gt;&gt;() &#123; @Override public int size() &#123; return 1 &lt;&lt; src.size(); // 2 to the power srcSize &#125; @Override public boolean contains(Object o) &#123; return o instanceof Set &amp;&amp; src.containsAll((Set)o); &#125; @Override public Set&lt;E&gt; get(int index) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(); for (int i = 0; index != 0; i++, index &gt;&gt;=1) if ((index &amp; 1) == 1) result.add(src.get(i)); return result; &#125; &#125;; &#125;&#125;","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"7. Lambdas and Streams","slug":"Effective-Java-3rd/7-Lambdas-and-Streams","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/7-Lambdas-and-Streams/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 46","slug":"Effective-Java-3rd-ITEM-46","date":"2019-06-25T11:32:19.000Z","updated":"2021-01-30T08:34:59.157Z","comments":true,"path":"2019/06/25/Effective-Java-3rd-ITEM-46/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/25/Effective-Java-3rd-ITEM-46/","excerpt":"","text":"ITEM 46. Prefer side-effect-free functions in streams스트림은 그저 또 하나의 API가 아닌, 함수형 프로그래밍에 기초한 패러다임이다. 스트림이 제공하는 표현력, 속도, 병렬성을 얻으려는 API는 말할 것도 없고 이 함수형 패러다임도 함께 받아들여야 한다. 스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분이다. 각 변환 단계에서 이전 단계의 결과를 받아 처리하는 순수 함수가 적용되어야 한다. 순수 함수란 입력값만이 결과에 영향을 주는 함수를 말한다. 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않아야 한다. 스트림을 사용할 때 java.util.stream.Collectors는 아주 중요한 클래스이다. 스트림의 원소들을 객체 하나에 취합해주는 총 43개의 메서드를 가지고 있다.1234List&lt;String&gt; topTen = freq.keySet().stream() .sorted(comparing(freq::get)).reserved() .limit(10) .collect(toList());여기서 쓰인 toList()가 Collectors 클래스에 있는 함수이다. toList(), toSet(), toMap(), groupingBy(), joining()같은 대표적인 것이 있고 나머지 42개의 메서드는 직접 클래스를 확인해보자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"7. Lambdas and Streams","slug":"Effective-Java-3rd/7-Lambdas-and-Streams","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/7-Lambdas-and-Streams/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 45","slug":"Effective-Java-3rd-ITEM-45","date":"2019-06-25T11:03:04.000Z","updated":"2021-01-30T08:34:59.156Z","comments":true,"path":"2019/06/25/Effective-Java-3rd-ITEM-45/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/25/Effective-Java-3rd-ITEM-45/","excerpt":"","text":"ITEM 45. Use streams judiciously스트림 APIjava8에 다량의 데이터 처리 작업을 돕고자 추가되었다. 스트림 안의 데이터 원소들은 객체 참조나 int, long, double의 기본 타입 값이다. 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다. 메서드 연쇄를 지원하는 fluent API이다. 스트림 파이프라인 소스 스트림에서 시작해 종단 연산으로 끝난다. 중간 연산들은 스트림을 변환하는 역할을 한다. 지연 평가(lazy evaluation)된다. 평가는 종단 연산이 호출될 때 이뤄진다.-&gt; 지연 평가이기에 무한 스트림을 다룰 수 있다. 기본적으로느 순차적으로 수행되는데 병렬로 실행하려면 parallel 메서드를 호출해주면 된다. 스트림과 맞는 시퀀스 원소들의 시퀀스를 일관되게 반환한다. 원소들의 시퀀스를 필터링한다. 원소들의 시퀀스를 하나의 연산을 사용해 결합한다. 원소들의 시퀀스를 컬렉션에 모은다. 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다. 스트림 API는 모든 계산을 할 수 있지만 모두 스트림으로 해야 한다는 것은 아니다. 스트림을 사용했을 때 읽기 어렵고 유지보수가 힘들어질 수 있다. 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 더 나아 보일 때만 반영하자. 스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 나은 쪽을 선택하자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"7. Lambdas and Streams","slug":"Effective-Java-3rd/7-Lambdas-and-Streams","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/7-Lambdas-and-Streams/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 44","slug":"Effective-Java-3rd-ITEM-44","date":"2019-06-20T13:50:02.000Z","updated":"2021-01-30T08:34:59.155Z","comments":true,"path":"2019/06/20/Effective-Java-3rd-ITEM-44/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/20/Effective-Java-3rd-ITEM-44/","excerpt":"","text":"ITEM 44. Favor the use of standard functional interfacesFunctional Interfaces람다가 추가되기 전, 상위 클래스의 기본 메서드를 재정의해 원하는 동작을 구현하는 템플릿 메서드 패턴을 많이 사용했다. 하지만 람다가 추가되면서 함수 객체를 받는 정적 팩터리나 생성자를 제공하는 방식으로 많이 대체되었다. LinkedHashMap을 보면, removeEldestEntry를 재정의하여 오래된 원소를 제거할 수가 있다.123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return size() &gt; 100;&#125;size가 100이 넘어가면 오래된 원소를 제거하도록 재정의하였다. 만약 LinkedHashMap을 람다를 이용해 다시 구현한다면 removeEldestEntry를 함수 객체로 받는 정적 팩터리나 생성자를 제공했을 것이다. java.util.functionjava.util.function 패키지를 보면 표준 함수형 인터페이스들이 총 43개 구현되어있다. 필요한 용도에 맞는게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용하자.https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html 직접 구현?전용 함수형 인터페이스를 구현해야 하는지 고민이라면 아래 3가지 중 하나 이상을 만족하는지 확인하고 생각해봐야 한다. 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다. 반드시 따라야 하는 규약이 있다. 유용한 디폴트 메서드를 제공할 수 있다. Comparator&lt;T&gt;가 대표적인 예시이다. 이름 자체로 용도를 훌륭히 설명해주고 있고 규약을 가지며 여러 디폴트 메서드를 담고 있다.만약 함수형 인터페이스를 직접 구현하기로 했다면 반드시 @FunctionalInterface annotation을 사용하자. 이 클래스가 람다를 위해 설계된 것임을 알릴 수 있고 누군가 추상 메서드를 추가하지 못하게 막아주는 역할도 한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"7. Lambdas and Streams","slug":"Effective-Java-3rd/7-Lambdas-and-Streams","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/7-Lambdas-and-Streams/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 43","slug":"Effective-Java-3rd-ITEM-43","date":"2019-06-20T13:33:40.000Z","updated":"2021-01-30T08:34:59.154Z","comments":true,"path":"2019/06/20/Effective-Java-3rd-ITEM-43/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/20/Effective-Java-3rd-ITEM-43/","excerpt":"","text":"ITEM 43. Prefer method references to lambdasMethod ReferencesMethod references는 자바에서 함수 객체를 람다보다 간결하게 만드는 방법이다.12map.merge(key, 1, (count, incr) -&gt; count + incr);map.merge(key, 1, Integer::sum);첫번째 줄을 method references를 이용해 두번째 줄로 간결하고 보기 좋게 줄일 수 있다. 12service.execute(GoshThisClassNameIsHumongous::action);service.execute(() -&gt; action()); 하지만 위 코드처럼 람다가 더 간결할 때도 있고, 어떤 람다에서는 매개변수의 이름이 프로그래머에게 좋은 가이드가 되기도 하기 때문에 길이는 더 길지만 읽기 쉽고 유지보수가 쉬울 수 있다. Method References 유형 메서드 참조 유형 예 같은 기능을 하는 람다 정적 Integer::parseInt str -&gt; Integer.parseInt(str) 한정적(인스턴스) Instant.now()::isAfter Instant then = Instant.now(); t -&gt; then.isAfter(t) 비한정적(인스턴스) String::toLowerCase str -&gt; str.toLowerCase() 클래스 생성자 TreeMap&lt;K,V&gt;::new () -&gt; new TreeMap&lt;K,V&gt;() 배열 생성자 int[]::new len -&gt; new int[len] 메서드 참조는 람다의 간단명료한 대안이 될 수 있다. 메서드 참조가 더 짧고 명확하다면 메서드 참조를 쓰고, 아니라면 람다를 쓰자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"7. Lambdas and Streams","slug":"Effective-Java-3rd/7-Lambdas-and-Streams","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/7-Lambdas-and-Streams/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 42","slug":"Effective-Java-3rd-ITEM-42","date":"2019-06-19T14:50:15.000Z","updated":"2021-01-30T08:34:59.153Z","comments":true,"path":"2019/06/19/Effective-Java-3rd-ITEM-42/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/19/Effective-Java-3rd-ITEM-42/","excerpt":"","text":"ITEM 42. Prefer lambdas to anonymous classes익명 클래스12345Collections.sort(words, new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return Integer.compare(s1.length(), s2.length()); &#125;&#125;) 문자열 리스트를 길이순으로 정렬하는 코드이다. 이 코드에서 Comparator 인터페이스를 익명클래스로 구현했다. 하지만 익명 클래스는 코드가 너무 길어 자바는 함수형 프로그래밍에 적합하지 않았다. 람다Java8에 들어오면서 추상 메서드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라 불리고 람다식을 사용해 만들 수 있게 되었다.123Collections.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));Collections.sort(words, comparingInt(String::length));words.sort(comparingInt(String::length));위 익명클래스를 람다로 바꾼 코드이다. 간결하고 명확하다. s1, s2에 대해서는 컴파일러가 타입을 추론해주기 때문에 프로그래머가 굳이 알 필요가 없고 명시해줄 필요도 없다. 타입을 명시해야 코드가 명확해질 때만 제외하고는 람다의 모든 매개변수 타입은 생략하자. 주의할점람다는 이름이 없고 문서화도 할 수 없다. 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 3줄 이상이면 람다를 쓰지 말아야 한다.람다는 함수형 인터페이스에서만 가능하고 추상 클래스나 추상 메서드가 여러개인 인터페이스를 구현할때는 익명 클래스를 사용해야 한다.또 람다는 자기 자신을 참조할 수가 없다. 람다 내에서의 this 키워드는 바깥 인스턴스를 가리킨다. 만약 자신을 참조해야 한다면 익명 클래스를 써야 한다.람다는 직렬화 형태가 구현별로 다를 수 있기 때문에 직렬화하는 일은 삼가야 한다. 직렬화가 필요한 함수 객체가 있다면 private static 중첩 클래스를 사용하자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"7. Lambdas and Streams","slug":"Effective-Java-3rd/7-Lambdas-and-Streams","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/7-Lambdas-and-Streams/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 41","slug":"Effective-Java-3rd-ITEM-41","date":"2019-06-19T14:27:04.000Z","updated":"2021-01-30T08:34:59.152Z","comments":true,"path":"2019/06/19/Effective-Java-3rd-ITEM-41/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/19/Effective-Java-3rd-ITEM-41/","excerpt":"","text":"ITEM 41. Use marker interfaces to define typesMarker Interface란 아무 메서드를 담고 있지 않고 자신을 구현한 클래스가 특정 속성을 가짐을 표시하는 인터페이스를 의미한다. Serializable Interface가 좋은 예로, Serializable을 구현한 클래스는 ObjectOutputStream을 통해 쓸 수 있다, 즉 직렬화할 수 있다. Marker Interface가 좋은점 Marker Interface는 자신을 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있지만 Marker Annotation은 아니다. 적용 대상을 더 정밀하게 지정할 수 있다. 클래스에만 적용하고 싶은 마커가 있다면 Marker Interface를 사용하면 된다. Marker Annotation이 좋은점 Annotation 시스템의 지원을 받는다. Annotation을 사용하는 프레임워크에서는 Marker Annotation을 사용하는 것이 일관성 유지에 좋을 것이다. Marker Interface? Marker Annotation?클래스와 인터페이스 외의 프로그램 요소에는 Marker Annotation을 사용할 수 밖에 없고, 클래스나 인터페이스에 적용하려 한다면 “이 마킹이 된 객체를 매개변수로 받은 메서드를 작성할 일이 있을까?”의 대답이 “그렇다”라면 Marker Interface를 사용하자!”","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"6. Enums and Annotations","slug":"Effective-Java-3rd/6-Enums-and-Annotations","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/6-Enums-and-Annotations/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 40","slug":"Effective-Java-3rd-ITEM-40","date":"2019-06-19T14:11:25.000Z","updated":"2021-01-30T08:34:59.151Z","comments":true,"path":"2019/06/19/Effective-Java-3rd-ITEM-40/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/19/Effective-Java-3rd-ITEM-40/","excerpt":"","text":"ITEM 40. Consistently use the Override annotation1234567public class Bigram &#123; public boolean equals(Bigram b) &#123; return b.first == first &amp;&amp; b.second == second; &#125;&#125; Bigram 클래스는 equals() 메서드를 Overriding하려 했지만 매개변수를 Object가 아닌 Bigram으로 선언해서 Overriding이 아닌 Overloading해버렸다. 만약 재정의한 메서드에 @Override annotation을 넣어줬더라면 컴파일러가 오류를 내줬겠지만 생략했기 때문에 올바르게 수정하기 어렵다.그러므로 상위 클래스의 메서드를 재정의하려는 모든 메서드에 @Override annotation을 달자!추상 클래스나 인터페이스를 생략해도 괜찮지만 모든 재정의 메서드에는 @Override annotation을 달아주는 것이 좋다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"6. Enums and Annotations","slug":"Effective-Java-3rd/6-Enums-and-Annotations","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/6-Enums-and-Annotations/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 39","slug":"Effective-Java-3rd-ITEM-39","date":"2019-06-16T05:53:46.000Z","updated":"2021-01-30T08:34:59.150Z","comments":true,"path":"2019/06/16/Effective-Java-3rd-ITEM-39/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/16/Effective-Java-3rd-ITEM-39/","excerpt":"","text":"ITEM 39. Prefer annotations to naming patternsNaming Patterns전통적으로 무언가 특별히 다뤄야할 프로그램 요소에는 구분되는 naming patterns을 사용해왔다. 예를 들어 JUnit3에서는 메서드 이름을 test로 시작하게 했다. 단점 오타가 있으면 무시하고 지나친다. 올바른 프로그램 요소에서만 사용되리라 보증할 방법이 없다. JUnit의 경우, 메서드만 가능한데 클래스에 Test를 붙이고 그 안에 메서드들이 실행되길 기대할 수도 있다. 프로그램 요소를 매개변수로 전달할 방법이 없다. Annotationsmeta-annotationsannotation 선언에 다는 annotation을 meta-annotation이라고 한다. Retention123456789101112131415161718192021public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; Retention은 위 RetentionPolicy 값을 들고 있다. 해당 annotation을 언제까지 유지해야 하는지를 뜻한다. Target123456789101112131415161718192021222324252627282930313233343536373839public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; Target은 위 ElementType을 들고 있고 annotation이 어디에 사용가능한지를 뜻한다. Repeatable1234567891011@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123; /** * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the * repeatable annotation type. * @return the containing annotation type */ Class&lt;? extends Annotation&gt; value();&#125; Repeatable은 하나의 프로그램 요소에 같은 Annotation을 여러개 달 수 있음을 뜻한다. Repeatable의 value로는 반복 가능하게 만든 annotation을 반환하는 ‘컨테이너 annotation’을 넣어줘야 한다. 컨테이너 annotation에는 반복된 annotation의 배열을 return하는 value 메서드를 정의해야 한다. Annotation 처리 도구보통 Annotation은 클래스나 메서드에 직접적인 영향을 주지는 않고 그저 처리 도구에게 추가 정보를 제공하는 역할만 한다. Annotation 처리 도구는 원하는 annotation이 달려있는 프로그램 요소를 특별하게 처리해주는 역할이다. Annotation으로 할 수 있는 일은 naming pattern으로 처리할 이유는 없다. Annotation을 사용하도록 하자!","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"6. Enums and Annotations","slug":"Effective-Java-3rd/6-Enums-and-Annotations","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/6-Enums-and-Annotations/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 38","slug":"Effective-Java-3rd-ITEM-38","date":"2019-06-16T04:09:32.000Z","updated":"2021-01-30T08:34:59.149Z","comments":true,"path":"2019/06/16/Effective-Java-3rd-ITEM-38/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/16/Effective-Java-3rd-ITEM-38/","excerpt":"","text":"ITEM 38. Emulate extensible enums with interfaces열거 타입은 확장할 수가 없다. 대부분의 상황에서 열거 타입을 확장하는건 좋은 생각이 아니지만 연산 코드와 같은 상황에서는 필요하다. Operation임의의 인터페이스를 추가하고 열거 타입이 그 인터페이스의 표준 구현체 역할을 한다면 확장의 효과를 낼 수 있다.1234567891011121314151617181920public interface Operation &#123; double apply(double x, double y);&#125;public enum BasicOperation implements Operation &#123; PLUS(&quot;+&quot;) &#123; public double apply(double x, double y) &#123; return x + y; &#125; &#125;, MINUS(&quot;-&quot;) &#123; public double apply(double x, double y) &#123; return x - y; &#125; &#125;, TIMES(&quot;*&quot;) &#123; public double apply(double x, double y) &#123; return x * y; &#125; &#125;, DIVIDE(&quot;/&quot;) &#123; public double apply(double x, double y) &#123; return x / y; &#125; &#125;; ...&#125;Operation 인터페이스를 만들고 BasicOperation이 그를 구현했다. Operation 인터페이스를 구현한 다른 열거 타입을 만든다면 확장의 효과를 낼 수 있다.12345678910public enum ExtendedOperation implements Operation &#123; EXP(&quot;^&quot;) &#123; public double apply(double x, double y) &#123; return Math.pow(x, y); &#125; &#125;, REMAINDER(&quot;%&quot;) &#123; public double apply(double x, double y) &#123; return x % y; &#125; &#125;; ...&#125;추가한 열거타입 ExtendedOperation이다. 새로 추가되었지만 기존에 Operation 인터페이스를 사용하도록 작성되어있는 곳이면 어디든 사용 가능하다. 한가지 사소한 문제가 있는데 바로 열거 타입끼리 구현을 상속할 수는 없다는 점이다. 공유되는 부분이 적은 경우는 괜찮지만 많다면 도우미 클래스나 정적 메서드로 분리해서 코드 중복을 피할 수 있을 것이다. 참고java.nio.file.LinkOption","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"6. Enums and Annotations","slug":"Effective-Java-3rd/6-Enums-and-Annotations","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/6-Enums-and-Annotations/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 37","slug":"Effective-Java-3rd-ITEM-37","date":"2019-06-16T03:37:48.000Z","updated":"2021-01-30T08:34:59.148Z","comments":true,"path":"2019/06/16/Effective-Java-3rd-ITEM-37/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/16/Effective-Java-3rd-ITEM-37/","excerpt":"","text":"ITEM 37. Use EnumMap instead of ordinal indexingordinal 인덱싱12Set&lt;Plant&gt;[] plantsByLifeCycle = ...;plantsByLifeCycle[p.lifeCycle.ordinal()].add(p); 이런 식으로 배열이나 리스트의 인덱스로 ordinal() 메서드를 사용한 코들들이 있다.이런 코드의 문제점은 정확한 정숫값을 사용한다는 것을 직접 보증해야 한다는 점이다. 정수는 타입 안전하지 않기 때문에 잘못된 값을 사용할 수도 있다.잘못된 값을 사용해도 아무 문제가 없는듯이 동작하거나 ArrayIndexOutOfBoundsException을 던질 것이다. EnumMap12EnumMap&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt; plantsByLifeCycle = ...;plantsByLifeCycle.get(p.lifeCycle).add(p); 열거타입을 키로 사용한 EnumMap이다. 더 짧고 명료하고 안전하고 내부에서는 배열을 사용하기 때문에 성능도 비등하다.123456789101112131415161718192021222324public class EnumMap&lt;K extends Enum&lt;K&gt;, V&gt; extends AbstractMap&lt;K, V&gt; implements java.io.Serializable, Cloneable&#123; /** * The &lt;tt&gt;Class&lt;/tt&gt; object for the enum type of all the keys of this map. * * @serial */ private final Class&lt;K&gt; keyType; /** * All of the values comprising K. (Cached for performance.) */ private transient K[] keyUniverse; /** * Array representation of this map. The ith element is the value * to which universe[i] is currently mapped, or null if it isn&#x27;t * mapped to anything, or NULL if it&#x27;s mapped to null. */ private transient Object[] vals; ...&#125;=&gt; Map의 타입안전성과 배열의 성능을 모두 얻어낸 것. 그러니 EnumMap을 사용하자!","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"6. Enums and Annotations","slug":"Effective-Java-3rd/6-Enums-and-Annotations","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/6-Enums-and-Annotations/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 36","slug":"Effective-Java-3rd-ITEM-36","date":"2019-06-15T15:57:29.000Z","updated":"2021-01-30T08:34:59.147Z","comments":true,"path":"2019/06/16/Effective-Java-3rd-ITEM-36/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/16/Effective-Java-3rd-ITEM-36/","excerpt":"","text":"ITEM 35. Use EnumSet instead of bit fields비트 필드1234567891011public class Text &#123; public static final int STYLE_BOLD = 1 &lt;&lt; 0; // 1 public static final int STYLE_ITALIC = 1 &lt;&lt; 1; // 2 public static final int STYLE_UNDERLINE = 1 &lt;&lt; 2; // 4 public static final int STYLE_STRIKETHROUGH = 1 &lt;&lt; 3; // 8 // Parameter is bitwise OR of zero or more STYLE_constants public void applyStyles(int styles) &#123; ... &#125;&#125;text.applyStyles(STYLE_BOLD | STYLE_ITALIC); 열거 값들이 단독이 아닌 집합으로 사용될 경우, 예전에는 정수 열거 상수에 2의 거듭 제곱 값을 할당하여 사용했었다. 장점 비트별 연산을 사용해 집합 연산이 효율적이다. 단점 정수 열거 상수의 모든 단점을 그대로 지닌다. 비트 필드 값이 그대로 출력되면 해석하기 어렵다. 비트 필드의 모든 원소를 순회하기 어렵다. 최대 몇 비트가 필요한지 예측하여 적절한 타입(int나 long)을 선택해야 한다. EnumSet12345678public class Text &#123; public enum Style &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125; // Any Set could be passed in, but EnumSet is clearly best public void applyStyles(Set&lt;Style&gt; styles) &#123; ... &#125;&#125;text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC)); 열거 타입 상수의 값으로 구성된 집합을 표현한다. Set 인터페이스를 완벽히 구현하며 타입 안전하다. 다른 Set 구현체와도 함께 사용할 수 있다. 내부 구현은 비트 벡터로 되어있어서 원소 64개 이하라면 long 변수 하나로 표현하여 비트 필드에 비견되는 성능을 보여준다. removeAll() retainAll()같은 대량 작업은 효율적으로 처리할 수 있게 구현되어있다. 직접 비트를 다룰 때 겪는 오류들에서 해방된다. 깔끔! EnumSet을 사용하자!","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"6. Enums and Annotations","slug":"Effective-Java-3rd/6-Enums-and-Annotations","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/6-Enums-and-Annotations/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 35","slug":"Effective-Java-3rd-ITEM-35","date":"2019-06-15T15:51:13.000Z","updated":"2021-01-30T08:34:59.146Z","comments":true,"path":"2019/06/16/Effective-Java-3rd-ITEM-35/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/16/Effective-Java-3rd-ITEM-35/","excerpt":"","text":"ITEM 34. Use instance fields instead of ordinals1234567891011121314/** * Returns the ordinal of this enumeration constant (its position * in its enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this method. It is * designed for use by sophisticated enum-based data structures, such * as &#123;@link java.util.EnumSet&#125; and &#123;@link java.util.EnumMap&#125;. * * @return the ordinal of this enumeration constant */public final int ordinal() &#123; return ordinal;&#125; 모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal() 메서드를 제공한다. 하지만 ordianl() 메서드의 문서에 적혀있는 것처럼 EnumSet과 EnumMap 같이 열거 타입 기반의 범용 자료구조에 쓸 목적이 아니라면 이 메서드를 사용해서는 안된다. 열거 타입 상수에 연결된 정수 값을 얻고자 한다면 직접 인스턴스 필드에 저장해서 사용하자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"6. Enums and Annotations","slug":"Effective-Java-3rd/6-Enums-and-Annotations","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/6-Enums-and-Annotations/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 34","slug":"Effective-Java-3rd-ITEM-34","date":"2019-06-13T12:46:03.000Z","updated":"2021-01-30T08:34:59.145Z","comments":true,"path":"2019/06/13/Effective-Java-3rd-ITEM-34/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/13/Effective-Java-3rd-ITEM-34/","excerpt":"","text":"ITEM 34. Use enums instead of int constants정수 열거 패턴1. 타입 안전성1234567public static final int APPLE_FUJI = 0;public static final int APPLE_PIPPIN = 1;public static final int APPLE_GRANNY_SMITH = 2;public static final int ORANGE_NAVEL = 0;public static final int ORANGE_TEMPLE = 1;public static final int ORANGE_BLOOD = 2; 정수 열거 패턴은 타입 안전을 보장하지 않는다. 오렌지용 상수와 사과용 상수를 서로 잘못 쓰더라도 컴파일러가 경고해주지 않는다. 오렌지를 건네야 할 메서드에 사과가 들어갈 수도 있고 동등 연산자(==)로 비교해도 컴파일러가 잡아주지 못한다. 2. 상수의 이름자바가 정수 열거 패턴을 위한 별도 namespace를 지원하지 않기 때문에 접두어로 구분해야 한다. 예를 들어 수은(원소) / 수성(행성)은 둘다 영어로 mercury이기 때문에 접두어를 붙여서 ELEMENT_MERCURY / PLANET_MERCURY로 구분해야 한다. 3. 깨지기 쉽다평범한 정수 상수를 나열한 것이라 컴파일하면 그 값이 클라이언트 파일에도 그대로 새겨진다. 만약 상수의 값이 바뀌면 클라이언트도 반드시 다시 컴파일해야 한다. 하지 않을 경우, 엉뚱한 동작을 하게 될 것이다. 4. 문자열 출력정수 상수는 문자열로 출력하기 까다롭다. 출력하거나 디버거로 보면 그저 숫자로만 보이기 때문에 tracking에 도움이 되기 어렵다. 또 같은 상수 그룹 내에서 순회를 하거나 갯수를 알 수 있는 방법이 없다. 5. 문자열 상수정수 상수가 출력이 어려운 점을 보완하기 위해 문자열 열거 패턴을 사용하기도 하지만 문자열 열거 패턴이 더 나쁘다. 상수의 의미는 볼 수 있지만 문자열 상수의 이름 대신 문자열 값을 그대로 사용하게 만들수도 있다. 이렇게 문자열 값 그대로 쓴 코드는 오타를 확인할 수도 없어 자연스레 런타임 버그로 이어진다. 문자열 비교에 따른 성능 저하도 있다. 열거 타입자바의 열거 타입은 다른 언어의 (정숫값만 가지는) 열거 타입과 다르게 완전한 형태의 클래스이다. 열거 타입 자체는 클래스이며 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 가지고 있는 것이다. 열거 타입은 외부에서 접근 가능한 생성자를 제공하지 않아 인스턴스가 딱 하나씩만 존재한다. 싱글턴은 상수(원소)가 하나뿐인 열거 타입이라 할 수 있고 열거타입은 싱글턴을 일반화한 형태라고 볼 수 있다. 장점 타입 안정성을 보장한다. 각각의 namespace를 가지고 있어 이름이 같은 상수도 공존 가능하다. 필드의 이름일뿐이라 클라이언트로 컴파일되어 각인되지 않는다. toString 메서드가 출력하기에 적합한 문자열을 내어준다. 임의의 메서드나 필드를 추가할 수 있다. 대신 열거 타입은 불변이기 때문에 필드도 final이어야 한다. interface 구현이 가능하다. 상수 하나를 제거해도 문제가 없다. 클라이언트에서는 다시 컴파일하거나 런타임 중에 에러가 발생할 수 있지만 유용한 메시지를 출력할 것이다. 추상 메서드를 선언하고 상수별로 다르게 동작하는 코드를 구현할 수 있다. -&gt; 상수별 메서드 구현 상수 이름을 입력받아 그 이름에 해당하는 상수를 반환하는 valueOf(String) 메서드가 자동 생성된다. 만약 toString()을 재정의했다면 fromString(String)도 정의해주면 좋다.모든 열거 타입에서 사용 가능한 fromString(String) code이다. 1234567private static final Map&lt;String, Operation&gt; stringToEnum = Stream.of(values()).collect( toMap(Object::toString, e -&gt; e));public static Optional&lt;Operation&gt; fromString(String symbol) &#123; return Optional.ofNullable(stringToEnum.get(symbol));&#125; 단점 열거 타입의 정적 필드 중 열거 타입의 생성자에서 접근할 수 있는 것은 상수의 변수뿐이다. 열거 타입의 생성자가 실행되는 시점에는 정적 필드들이 초기화되기 전이기 때문이다. 열거 타입 생성자에서 같은 열거 타입의 다른 상수에도 접근할 수 없다. 상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다. switch 문으로 열거 타입의 상수별 동작을 구현하는 것은 적합하지 않다. switch 문을 사용하면 간결하지만 관리 관점에서 위험하다. 새로운 값이 추가되었을때 잊지 말고 case 문을 추가해주어야 한다. 하지만 기존 열거 타입에 상수별 동작을 혼합해 넣을 때는 switch 문이 좋은 선택이 될 수 있다. 추가하려는 메서드가 의미상 열거 타입에 속하지 않는다면 이 방식을 적용하는 게 좋다. 종종 쓰이지만 열거 타입 안에 포함할 만큼 유용하지 않은 경우도 마찬가지다. 열거 타입은 언제?필요한 원소를 컴파일 타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자. 물론 열거 타입에 정의한 상수 개수가 영원히 고정 불변일 필요는 없다. 상수가 추가돼도 잘 호환되도록 설계되어있다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"6. Enums and Annotations","slug":"Effective-Java-3rd/6-Enums-and-Annotations","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/6-Enums-and-Annotations/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 33","slug":"Effective-Java-3rd-ITEM-33","date":"2019-06-11T13:26:14.000Z","updated":"2021-01-30T08:34:59.144Z","comments":true,"path":"2019/06/11/Effective-Java-3rd-ITEM-33/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/11/Effective-Java-3rd-ITEM-33/","excerpt":"","text":"ITEM 33. Consider typesafe heterogeneous containers제네릭은 Set&lt;E&gt; Map&lt;K,V&gt; ThreadLocal&lt;T&gt; AtomicReference&lt;T&gt; 등의 단일 원소 컨테이너에도 흔히 쓰인다. 이런 상황에서는 매개변수화되는 대상은 컨테이너 자신이다. 따라서 하나의 컨테이너에서 매개변수화 할 수 있는 타입의 수는 제한된다. Map&lt;K,V&gt;에서는 K와 V 2개로 제한 / Set&lt;E&gt;에서는 E 1개로 제한. 하지만 이보다 더 유연한 수단이 필요할 때가 있다. 이럴땐 컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하면 된다.=&gt; 타입 안전 이중 컨테이너 패턴 타입 안전 이중 컨테이너예시로 타입별로 즐겨 찾는 인스턴스를 저장하는 Favorites class를 보자.12345678910public class Favorites &#123; private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;&gt;(); public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123; favorites.put(Objects.requireNonNull(type), instance); &#125; public &lt;T&gt; T getFavoirte(Class&lt;T&gt; type) &#123; return type.cast(favorites.get(type)); &#125;&#125;각 타입의 Class 객체를 매개변수화 키로 사용한 것인데 이는 class 리터럴의 타입이 Class&lt;T&gt;이기 때문에 사용할 수 있는 것이다. 메서드들이 주고 받는 class 리터럴을 타입 토큰이라 한다. favorites 맵의 값 타입이 Object이기 때문에 getFavoirte() 시에 형변환이 필요하다. 따라서 여기서는 Class의 cast 메서드를 이용해 동적 형변환하였다. 여기서 중요한 점은 Favorites의 instance들은 타입 안전하다는 것이다. getFavorite(String.class)를 했을때 String이 아닌 타입의 인스턴스를 반환할 일이 절대 없다.=&gt; Favorites class는 타입 안전 이중 컨테이너 Favorites class의 제약1. 악의적 클라이언트1f.putFavorite((Class)Integer.class, &quot;Heellllooo&quot;) 만약 악의적인 클라인트가 Class 객체를 제네릭이 아닌 raw type으로 넘긴다면 타입 안전성이 깨지게 된다. 위 예시에서 보듯이 raw type을 사용하면 Integer.class 타입으로 String 값을 넘겨줄 수 있게 된다. 이것을 예방하려면 putFavorite(type, instance) 메서드에서 넣기전에 instance의 타입을 type과 같은지 확인해주면 된다. Collections의 checkedSet, checkedList, checkedMap이 이렇게 타입을 확인해주는 컬렉션 레퍼들이다. Collections.CheckedCollection.class code 2. 실체화 불가 타입Favorites 클래스에는 실체화 불가 타입을 사용할 수 없다. List&lt;String&gt; 같은 제네릭을 사용할 수 없다는 것이다. List&lt;String&gt;이나 List&lt;Integer&gt; 등등 모두 List.class로 같은 Class 객체를 공유한다. 따라서 실체화 불가 타입은 Favorites 클래스에서 사용할 수 없다. 슈퍼 타입 토큰..? spring framework의 ParameterizedTypeReference로 가능하긴 하지만 완벽하진 않다. 한정적 타입 토큰Favorites의 키 타입은 비한정적 타입 토큰이지만 타입을 제한하고 싶다면 한정적 타입 토큰으로 바꿀 수 있다. Class&lt;? extends SuperClass&gt;로 선언하면 된다.반환 하는 객체는 Class&lt;? extends SuperClass&gt; 타입으로 형변환이 필요한데 이때 Class 클래스에 있는 asSubClass 메서드로 쉽게 형변환 해줄 수 있다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"5. Generics","slug":"Effective-Java-3rd/5-Generics","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/5-Generics/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 32","slug":"Effective-Java-3rd-ITEM-32","date":"2019-06-09T10:05:36.000Z","updated":"2021-01-30T08:34:59.143Z","comments":true,"path":"2019/06/09/Effective-Java-3rd-ITEM-32/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/09/Effective-Java-3rd-ITEM-32/","excerpt":"","text":"ITEM 32. Combine generics and varargs judiciously가변인수 메서드는 제네릭과 자바5에서 같이 추가되었다. 하지만 서로 잘 어울리지는 못한다. 가변인수가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해준다. 가변인수를 담기위한 배열을 자동으로 생성하는데 그 배열을 클라이언트에 노출하는 문제가 있다. 그 결과 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 컴파일 경고가 발생한다.123456staticf void dangerous(List&lt;String&gt;... stringLists) &#123; List&lt;Integer&gt; intList = List.of(42); Object[] objects = stringLists; objects[0] = intList; // 힙 오염 발생 String s = stringLists[0].get(0); // ClassCastException&#125;이 메서드에서는 마지막 줄에 컴파일러가 자동 생성한 보이지 않는 형변환이 있다. 이렇게 매개변수화 타입의 변수가 타입이 다른 객체를 참조하여 힙 오염이 발생하면 컴파일러가 자동생성한 형변환에서 ClassCastException이 발생할 수 있다.=&gt; 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 타입 안정성이 깨진다.12345@SafeVarargs@SuppressWarnings(&quot;varargs&quot;)public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125;제네릭 배열을 직접 생성하는 건 허용하지 않으면서 제네릭 varargs 매개변수를 받는 메서드를 선언할 수 있게 한 이유는 위 코드처럼 실무에 매우 유용하게 사용할 수 있기 때문이다. SafeVarargs annotation자바7에서 @SafeVarargs 어노테이션이 추가되면서 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다. @SafeVarargs는 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치이다. 메서드가 안전한지 확신할 수 있는 근거 메서드가 이 배열에 아무것도 저장하지 않는다. 그 배열(혹은 복제본)의 참조가 밖으로 노출되지 않는다. varargs 매개변수 배열이 호출자로부터 그 메서드로 순수하게 인수들을 전달하는 일만 해야 한다. 123static &lt;T&gt; T[] toArray(T... args) &#123; return args;&#125; 위 메서드처럼 자신의 varargs 매개변수 배열을 그대로 반환하면 힙 오염을 이 메서드를 호출한 쪽의 콜스택으로까지 전이하는 결과를 낳을 수 있다.@SafeVarargs는 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 달아야 한다. 이 말은 안전하지 않는 가변인수 메서드는 절대 작성해서는 안된다는 뜻이다.@SafeVarargs는 재정의할 수 없는 메서드에만 달아야 한다. java8에서는 static 메서드나 final 메서드에만 달 수 있었고 java9부터는 private 메서드에도 허용되었다. with Listvarargs 매개변수를 List로 변경하는 방법도 있다. 매개변수 부분만 List로 변경해주면 된다. 호출하는 클라이언트에서는 List.of()를 사용하면 쉽게 임의의 개수를 인수로 넘겨줄 수 있다.이 방식은 직접 @SafeVarargs를 달지 않아도 되며 안전한지를 판단할 필요도 없다. 다만 클라이언트 코드가 살짝 지저분해지고 속도가 조금 느릴 수 있다는 점이다. 하지만 결과 코드는 제네릭만 사용하므로 타입 안전하다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"5. Generics","slug":"Effective-Java-3rd/5-Generics","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/5-Generics/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 31","slug":"Effective-Java-3rd-ITEM-31","date":"2019-06-08T06:47:16.000Z","updated":"2021-01-30T08:34:59.141Z","comments":true,"path":"2019/06/08/Effective-Java-3rd-ITEM-31/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/08/Effective-Java-3rd-ITEM-31/","excerpt":"","text":"ITEM 31. Use bounded wildcards to increase API flexibility매개변수화 타입은 불공변이기 때문에 이보다 유연한 무언가가 필요할 때가 있다. producer-extends123456789public void pushAll(Iterable&lt;E&gt; src) &#123; for (E e : src) push(e);&#125;// Number Stack에 Integer Iterable를 넣으려고 할 때Stack&lt;Number&gt; numStack = new Stack&lt;&gt;();Iterable&lt;Integer&gt; integers = ...;numStack.pushAll(integers); 위 코드는 Stack에 src의 모든 원소를 넣는 코드이다. Integer는 Number의 하위 타입이라 잘 동작할 것 같지만 불공변인 매개변수화 타입때문에 오류가 발생한다.pushAll의 입력 매개변수 타입을 E의 Iterable이 아닌 E의 하위타입의 Iterable일 필요가 있다.=&gt; Iterable&lt;? extends E&gt;123public void pushAll(Iterable&lt;? extends E&gt; src) &#123; ...;&#125; consumer-super123456789public void popAll(Collection&lt;E&gt; dst) &#123; while (!isEmpty()) dst.add(pop());&#125;// Number Stack을 Obejct Collection에 넣으려고 할 때Stack&lt;Number&gt; numStack = new Stack&lt;&gt;();Collection&lt;Object&gt; objects = ...;numStack.popAll(objects); 위 코드는 Stack에 있는 원소들을 모두 pop하여 Collection에 옮겨담는 코드이다. Number가 Object의 하위타입이기 때문에 잘 동작해야 하지만 불공변으로 인해 오류가 생긴다.popAll의 입력 매개변수의 타입을 E의 상위타입의 Collection으로 해줘야 한다.=&gt; Collection&lt;? super E&gt;123public void popAll(Collection&lt;? super E&gt; dst) &#123; ...&#125; 타입 매개변수와 와일드 카드12public static &lt;E&gt; void swap(List&lt;E&gt; list, int i, int j);public static void swap(List&lt;?&gt; list, int i, int j); 위 코드는 원소 swap을 하는 메소드를 2가지 방식으로 선언한 것이다. 이렇게 타입 매개변수와 와일드카드 둘 중 어느 것을 사용해도 괜찮을때가 많다. 이런 상황의 판단 기준은 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하는 것이 좋다. 따라서 public API라면 2번째 방식이 더 간단하고 좋다.1234// Error List&lt;?&gt;.set()public static void swap(List&lt;?&gt; list, int i, int j) &#123; list.set(i, list.set(j, list.get(i)));&#125;하지만 2번째 방식의 선언으로 메소드를 구현했을때 오류 메시지가 나올 것이다.와일드 카드를 사용한 List&lt;?&gt;에는 null 이외에 다른 값을 넣을 수 없기 때문이다. 이 때문에 와일드 카드 타입의 실제 타입을 알려주는 private 메서드가 필요하다.1234567public static void swap(List&lt;?&gt; list, int i, int j) &#123; swapHelper(list, i, j);&#125;private static &lt;E&gt; void swapHelper(List&lt;E&gt; list, int i, int j) &#123; list.set(i, list.set(j, list.get(i)));&#125;swapHelper 메서드는 List의 타입 매개변수를 알 수 있기 때문에 swap이 가능해진다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"5. Generics","slug":"Effective-Java-3rd/5-Generics","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/5-Generics/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 30","slug":"Effective-Java-3rd-ITEM-30","date":"2019-06-08T02:19:35.000Z","updated":"2021-01-30T08:34:59.139Z","comments":true,"path":"2019/06/08/Effective-Java-3rd-ITEM-30/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/08/Effective-Java-3rd-ITEM-30/","excerpt":"","text":"ITEM 30. Favor generic methods제네릭 메서드12345public static Set union(Set s1, Set s2) &#123; Set result = new HashSet(s1); result.addAll(s2); return result;&#125; 위와 같이 제네릭이 아닌 raw type으로 사용 시에는 unchecked 경고가 나온다. 또 클라이언트가 사용 시에 직접 타입 변환을 해야 하기 때문에 런타임 오류가 생길 수 있는 위험이 있다. 12345public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(); result.addAll(s2); return result;&#125; 제네릭 메서드로 만들면 경고 문구도 없고 타입 안전하고 쓰기도 쉽다. 제네릭 싱글턴 팩터리123456789private static final ReverseComparator rcInstance = new ReverseComparator();public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder() &#123; return (Comparator&lt;T&gt;) rcInstance;&#125;public static final Set EMPTY_SET = new EmptySet();public static final &lt;T&gt; Set&lt;T&gt; emptySet() &#123; return (EmptySet&lt;T&gt;) EMPTY_SET;&#125; 불변 객체를 여러 타입으로 활용할 수 있게 만들어야 할 때가 있다. 제네릭은 런타임에 타입이 소거되기 때문에 하나의 객체가 여러 타입으로든 매개변수화할 수 있다. 하지만 이렇게 하려면 요청한 타입 매개 변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리가 필요하다. 위 코드가 그 2가지 예시이고 이러한 패턴을 제네릭 싱글턴 팩터리라고 한다. Collections.reverseOrder()는 ReverseComparator를 매개 변수에 맞게 타입을 바꾸고 반환해주는 함수이다. Collections.emptySet()은 비어있는 EmptySet 객체를 매개 변수를 바꿔 반환해주는 함수이다. 재귀적 타입 한정자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정하는 것을 재귀적 타입 한정이라고 한다. Comparable&lt;T&gt; interface를 예시로 보겠다. Comparable&lt;T&gt;의 T는 비교할 수 있는 원소의 타입을 정의한다. Comparable을 구현한 원소의 컬렉션을 입력받는 메서드들은 정렬 / 탐색 / 최솟값 / 최대값을 구하는 식으로 사용되는데 이는 컬렉션의 모든 원소가 상호 기교 가능해야 된다.123public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c) &#123; ...&#125;위 코드 예시처럼 받을 수 있는 타입 매개변수로 Comparable을 구현한 타입만으로 제한하고 사용한다.제네릭 타입과 마찬가지로 클라이언트에서 입력 매개변수화 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다. 형변환을 해줘야 하는 메서드는 제네릭하게 만들자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"5. Generics","slug":"Effective-Java-3rd/5-Generics","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/5-Generics/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 29","slug":"Effective-Java-3rd-ITEM-29","date":"2019-06-06T12:44:48.000Z","updated":"2021-01-30T08:34:59.137Z","comments":true,"path":"2019/06/06/Effective-Java-3rd-ITEM-29/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/06/Effective-Java-3rd-ITEM-29/","excerpt":"","text":"ITEM 29. Favor generic types1234567891011public class Stack &#123; private Object[] elements; public Stack() &#123; elements = new Object[16]; &#125; public Object pop() &#123; ... &#125;&#125; 위 Stack class의 Object배열은 제네릭 타입으로 쓰는게 좋다. 지금 상태로는 스택에서 pop한 객체를 원하는 타입으로의 형변환이 필요해 런타임 오류가 생길 위험이 있다. 1234567891011public class Stack&lt;E&gt; &#123; private E[] elements; public Stack() &#123; elements = new E[16]; &#125; public E pop() &#123; ... &#125;&#125; 이렇게 제네릭 E를 써서 수정할 수 있다. 하지만 제네릭 타입은 배열로 만들 수 없기 때문에 elements = new E[16];에서 오류가 난다. 이것을 해결하는 방법은 2가지가 있다. 1. 비검사 형변환!123public Stack() &#123; elements = (E[]) new Object[16];&#125; 제네릭 타입 배열을 만들 수 없으니 Object 배열로 만들고 비검사 형변환을 해주는 것이다.elements 필드에는 항상 E 타입이 들어간다는 보장이 있기 때문에 이렇게 비검사 형변환을 해주고 @SuppressWarnings를 달아주자. 2. Object[]로!1234public class Stack&lt;E&gt; &#123; private Object[] elements; ...&#125; elements 필드를 Object[]로 쓰는 것이다. 이렇게 하면 pop() method에서 incompatible types 경고가 발생한다. E 타입을 반환해야 하는데 Object가 나오기 때문이다. 따라서 pop()할때 Object를 E 타입으로 형변환을 해줘야 한다. 하지만 이번엔 unchecked cast 경고가 나온다. 하지만 E 타입인 것을 보장할 수 있기 때문에 경고를 없애주기 위해 @SuppressWarnings을 넣어주자. 두 방법 모두 나름의 지지를 얻고 있다. 첫 번째는 배열을 E[]로 선언하기 때문에 가독성이 좋고 코드도 짧지만 힙오염이 발생할 수 있다. 두 번째 방법은 힙오염은 발생하지 않지만 배열에서 원소를 꺼낼때마다 형변환이 필요하다.위 예시인 Stack과 같은 대다수의 제네릭 타입은 타입 매개변수에 아무런 제약이 없어서 Stack&lt;int[]&gt;, Stack&lt;Object&gt;, Stack&lt;List&lt;String&gt;&gt;과 같이 사용할 수 있다. 단 int, double 등 기본 타입은 못 쓰니 대신 Boxing 타입을 사용하자.해당 클래스를 사용하는 입장에서 직접 형변환해야 하는 타입보다 제네릭 타입으로 쓰면 더 안전하고 쓰기 편하다.형변환 없이 사용할 수 있도록 제네릭으로 설계하자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"5. Generics","slug":"Effective-Java-3rd/5-Generics","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/5-Generics/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 28","slug":"Effective-Java-3rd-ITEM-28","date":"2019-06-06T11:00:56.000Z","updated":"2021-01-30T08:34:59.136Z","comments":true,"path":"2019/06/06/Effective-Java-3rd-ITEM-28/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/06/Effective-Java-3rd-ITEM-28/","excerpt":"","text":"ITEM 28. Prefer lists to arrays배열과 제네릭 타입의 차이공변 / 불공변배열은 공변(covariant)이고 제네릭은 불공변(invariant)이다.공변이란 하위 타입 배열이 상위 타입 배열의 하위 타입이 된다는 것이다. Sub[]은 Super[]의 하위 타입!제네릭에서는 List&lt;Sub&gt;이 List&lt;Super&gt;의 하위 타입이 아니다. 실체화배열은 런타임에도 자신의 원소의 타입을 확인하지만 제네릭 타입은 런타임에는 타입 정보가 소거되어 타입을 알 수 없다. 제네릭의 소거는 제네릭이 없는 버전과의 호환성을 위한 메커니즘이다. 배열과 제네릭의 호환제네릭 타입 배열new List&lt;E&gt;[], new List&lt;String&gt;[], new E[]와 같은 제네릭 타입의 배열은 생성할 수 없다.제네릭 타입의 배열 생성을 허용하면 타입이 안전하지 않다.12345List&lt;String&gt;[] stringLists = new List&lt;String&gt;[1]; //(1)List&lt;Integer&gt; intList = List.of(42); //(2)Object[] objects = stringLists; //(3)objects[0] = intList; //(4)String s = stringLists[0].get(0); //(5)위 코드는 제네릭 타입 배열 생성을 허용했을 때 발생하는 문제에 대한 코드이다.(1)에서 List&lt;String&gt; 배열을 만든다.(2)에서는 42 하나 들어있는 List&lt;Integer&gt;를 만들고(3)에서 List&lt;String&gt;[]을 Object[]에 넣는다. 배열은 공변이기 때문에 List&lt;String&gt;[]은 Object[]의 하위타입이 된다. 그래서 Object[]에 할당이 가능하다.(4)에서 Object[]의 원소로 List&lt;Integer&gt;를 넣어준다. 이것이 가능한 이유는 제네릭 타입의 소거로 인해 List&lt;String&gt;[] -&gt; List[], List&lt;Intger&gt; -&gt; List가 되기 때문이다.문제는 (5)에서 발생한다. List&lt;String&gt;을 넣기로 했던 stringLists에 List&lt;Integer&gt;가 들어있어서 stringLists[0].get(0)을 했을때 Integer(42)가 나온다. 이를 String에 받으려고 하기 때문에 ClassCastException이 발생한다. 제네릭 컬렉션은 자신의 원소 타입으로 배열을 반환하는게 보통 불가능하고 Object[]로 반환한다. 또 가변인수에 제네릭 타입을 넣어줄 수 없다. 가변인수를 배열로 만들게 되기 때문이다. 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우, 대부분은 배열인 E[] 대신 컬렉션인 List를 사용하면 해결된다. 코드가 조금 복잡해지고 성능이 살짝 나빠지지만 그 대신 타입 안전성이 보장되고 상호운용성이 좋아진다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"5. Generics","slug":"Effective-Java-3rd/5-Generics","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/5-Generics/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 27","slug":"Effective-Java-3rd-ITEM-27","date":"2019-06-06T10:21:27.000Z","updated":"2021-01-30T08:34:59.135Z","comments":true,"path":"2019/06/06/Effective-Java-3rd-ITEM-27/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/06/Effective-Java-3rd-ITEM-27/","excerpt":"","text":"ITEM 27. Eliminate unchecked warnings제네릭을 사용하다보면 비검사 경고가 많이 생기게 된다. 보통 컴파일러가 무엇이 잘못되었는지 친절하게 설명해주니 그에 따라 수정하자.최대한 모든 비검사 경고를 제거하다보면 코드의 타입 안정성이 보장된다. Suppress Warnings만약 경고를 제거할 수는 없지만 타입이 안전하다고 확신한다면 @SuppressWarnings(&quot;unchecked&quot;)를 달아 경고를 숨길 수 있다.@SuppressWarnings는 지역변수에도 달 수 있고 클래스 전체에도 달 수 있다. @SuppressWarnings을 달더라도 최대한 좁은 범위에 적용하자.이 어노테이션은 선언에만 달 수 있기 때문에 return 문에는 못 써서 따로 변수 선언이 필요할 수 있다. @SuppressWarnings을 사용할 때는 사용한 이유에 대해 항상 주석을 남겨 다른 사람에게 혼란을 주지 않아야 한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"5. Generics","slug":"Effective-Java-3rd/5-Generics","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/5-Generics/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 26","slug":"Effective-Java-3rd-ITEM-26","date":"2019-06-03T14:10:55.000Z","updated":"2021-01-30T08:34:59.135Z","comments":true,"path":"2019/06/03/Effective-Java-3rd-ITEM-26/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/03/Effective-Java-3rd-ITEM-26/","excerpt":"","text":"Generics 관련 용어 설명Generic은 Java5부터 사용할 수 있게 되었다. 4장에서 계속 쓰일 용어들을 정리한 것이다. 한글 용어 영문 용어 예시 매개변수화 타입 Parameterized Type List&lt;String&gt; 실제 타입 매개변수 Actual Type Parameter String 제네릭 타입 Generic Type List&lt;E&gt; 정규 타입 매개변수 Formal Type Parameter E 비한정적 와일드카드 타입 Unbounded Wildcard Type List&lt;?&gt; 로 타입 Raw Type List 한정적 타입 매개변수 Bounded Type Parameter &lt;E extends Number&gt; 재귀적 타입 한정 Recursive Type Bound &lt;T extends Comparable&lt;T&gt;&gt; 한정적 와일드카드 타입 Bounded Wildcare Type List&lt;? extends Number&gt; 제네릭 메서드 Generic Method static &lt;E&gt; List&lt;E&gt; asList(E[] a) 타입 토큰 Type Token String.class ITEM 26. Don’t use raw types클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다.=&gt; 제네릭 타입 Raw TypeRaw Type이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 제네릭을 사용하기 전 코드와 호환될 수 있도록 만든 것이다.12// Stamp를 위한 Collectionprivate final Collection stamps = ...;위 코드의 stamps는 Stamp 원소만 받고자 만든 것이지만 다른 원소가 들어가도 컴파일되고 실행된다. 1private final Collection&lt;Stamp&gt; stamps = ...; 제네릭을 활용하면 주석이 아닌 타입에 Stamp를 선언할 수 있다. 컴파일 타임에 다른 원소를 넣으려고 시도하는 것을 오류로 감지할 수 있다. Raw Type을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다. 절대로 써서는 안된다. 그저 하위 버전 호환성을 위해 존재할 뿐이다.List와 같은 Raw Type은 사용하면 안되지만 List&lt;Object&gt;처럼 모든 타입을 허용하는 매개변수화 타입은 사용 가능하다. Raw Type과의 차이는 List를 매개변수로 받는 메서드에 List&lt;String&gt;은 받을 수 있지만 List&lt;Object&gt;를 받는 메서드에는 List&lt;String&gt;을 받을 수 없다. 이유는 제네릭의 하위 타입 규칙 때문이다. List&lt;String&gt;은 List&lt;Object&gt;의 하위 타입이 아니기 때문이다. 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않을때는 Unbounded wildcard type(List&lt;?&gt;)을 사용하면 된다.Unbounded wildcard type에는 null을 제외한 어떤 원소도 넣을 수 없다. 이러한 제약이 불편하다면 Generic method / Bounded wildcard type을 사용하면 된다. Raw type을 써야하는 경우도 2가지 있다. class 리터럴에는 Raw type을 사용해야 한다. 예를 들어 List.class를 사용하고 List&lt;String&gt;.class는 허용되지 않는다. instanceof 연산자에서는 Raw type을 사용하는 것이 깔끔하다. Runtime에는 제네릭 타입에 대한 정보가 지워지므로 instanceof 연산자는 Unbounded wildcard type 이외에는 적용할 수 없다.그리고 Raw Type이든 Unbounded wildcare type이든 똑같이 동작한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"5. Generics","slug":"Effective-Java-3rd/5-Generics","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/5-Generics/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 25","slug":"Effective-Java-3rd-ITEM-25","date":"2019-06-03T13:53:51.000Z","updated":"2021-01-30T08:34:59.134Z","comments":true,"path":"2019/06/03/Effective-Java-3rd-ITEM-25/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/03/Effective-Java-3rd-ITEM-25/","excerpt":"","text":"ITEM 25. Limit source files to a single top-level class소스 파일 하나에 여러 톱레벨 클래스를 작성하지 말아야 한다.1234567891011121314// Main.javapublic class Main &#123; public static void main(String[] args) &#123; System.out.println(Utensil.NAME + Dessert.NAME); &#125;&#125;// Utensil.javaclass Utensil &#123; static final String NAME = &quot;pan&quot;; &#125;class Dessert &#123; static final String NAME = &quot;cake&quot;; &#125;// Dessert.javaclass Dessert &#123; static final String NAME = &quot;pie&quot;; &#125;class Utensil &#123; static final String NAME = &quot;pot&quot;; &#125;Main.java가 Utensil / Dessert를 참조하고 있고 Utensil.java에는 Utensil / Dessert가 선언되어있고 Dessert.java에도 Utensil / Dessert가 선언되어있다.만약 위 코드처럼 한 소스파일에 Utensil / Dessert가 같이 선언되어있고 우연히 같은 이름의 클래스를 가지고 있다면, 컴파일 순서에 따라 main함수의 결과가 다르게 나온다. javac Main.java Dessert.java를 실행하면 Utensil class와 Dessert class가 중복 정의되었다고 컴파일 에러가 날 것이다. javac Main.java나 javac Main.java Utensil.java를 실행하면 pancake가 출력될 것이다. javac Dessert.java Main.java를 실행하면 potpie가 출력될 것이다. 위처럼 컴파일 순서에 따라 결과가 달라지므로 반드시 바로 잡아야한다.해결책은 톱레벨 클래스를 하나하나 소스파일을 분리하면 된다. 굳이 한 파일에 담고 싶다면 정적 멤버 클래스를 사용할 수 있다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Resilience4j란","slug":"Resilience4j란","date":"2019-06-02T15:44:41.000Z","updated":"2021-01-30T08:34:59.263Z","comments":true,"path":"2019/06/03/Resilience4j란/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/03/Resilience4j%EB%9E%80/","excerpt":"","text":"이 글은 resilience4j 0.17.0 버전으로 작성되었다. 버전이 많이 올라감에 따라 많은 부분이 변경되었으므로 이 글보다는 아래 링크의 글들을 참고하는 것이 좋다. https://dlsrb6342.github.io/2019/12/09/Resilience4j-CircuitBreaker : resilience4j-circuitbreaker 1.2.0 버전에 맞춰 작성된 글이다. https://dlsrb6342.github.io/2019/12/12/Resilience4j-RateLimiter : resilience4j-ratelimiter 1.2.0 버전에 맞춰 작성된 글이다. Resilience4j Resilience4j is a lightweight, easy-to-use fault tolerance library inspired by Netflix Hystrix. Resilience4j는 Hystrix로부터 영감을 받은 fault tolerance library다. 사용하기 가볍고 다른 라이브러리 의존성이 없어 좋다. Hystrix는 다른 dependency를 많이 가지고도 있고 archaius라는 큰 라이브러리를 사용했지만 Resilience4j는 Vavr를 제외한 다른 library dependancy가 없다.Resilience4j에는 Circuit Breaker / Rate Limier / Bulkhead / Retry / Cache / Time Limiter 구현체들이 있다. 각각의 개념에 관해서는 아래 주제 별로 붙어있는 링크에서 확인할 수 있다. 이번 글에서는 코어 모듈에 대한 내용을 다루겠다. resilience4j-circuitbreakerhttps://martinfowler.com/bliki/CircuitBreaker.html Netflix Hystrix와 다른점 Hystrix is no longer in active development, and is currently in maintenance mode.For the cases where something like Hystrix makes sense, we intend to continue using Hystrix for existing applications, and to leverage open and active projects like resilience4j for new internal projects. We are beginning to recommend others do the same. Hystrix의 github에 가보면 README에 위와 같은 내용이 적혀있다. 이제 더 이상 개발되지 않고 maintenance만 하겠다고 되어있고 resilience4j를 사용하기를 추천하고 있다. 그래서 Netflix에서 왜 resilience4j를 추천하는지 그 둘의 차이점을 찾아보았다. Hystrix는 외부 API 요청을 HystrixCommand로 wrapping해서 사용해야 한다. 하지만 Resilience4j는 functional interface, lambda, method reference를 위한 higher-order functions(decorator)를 제공한다. 어떤 decorator를 사용할지 혹은 사용하지 않을지 선택할 수 있게 된다. Hystrix는 기본적으로 10개의 1-second window buckets에 실행 결과를 저장하고, bucket 하나가 끝나면 새로운 bucket을 만들고 기존 bucket은 없앤다. Resilience4j는 Ring Bit Buffer에 결과를 저장하고 성공한 요청은 0 bit로 실패한 요청은 1 bit로 저장한다. Ring Bit Buffer는 설정으로 조절 가능한 fixed-size를 갖고, long[] array에 bits를 저장한다. time winodw가 지났다고 실행 결과를 제거하지 않기 때문에 frequency가 낮든 높든 별다른 설정없이 CircuitBreaker를 이용할 수 있다. Hystrix는 CircuitBreaker가 half-open 상태일때 Circuit을 close할지 결정할 딱 한번의 요청을 수행한다. 하지만 Resilience4j는 요청의 수행 횟수와 threshold 값을 설정할 수 있다. RxJava operators를 지원한다. CircuitBreakerRegistry CircuitBreaker instance를 만들고 없애는 관리를 할 수 있는 class이다. 기본적으로 ConcurrentHashMap을 활용한 in-memory CircuitBreakerRegistry를 제공한다. CircuitBreakerConfig failureRateThreshold CirucitBreaker를 열지 결정하는 failure rate threshold percentage 값. default는 50 waitDurationInOpenState CircuitBreaker를 open한 상태를 유지하는 지속 기간을 의미한다. 이 기간 이후에 half-open 상태가 된다. default는 60seconds ringBufferSizeInHalfOpenState CircuitBreaker가 half-open 상태일때 RingBuffer의 사이즈. default는 10 ringBufferSizeInClosedState CircuitBreaker가 closed 상태일때 RingBuffer의 사이즈. default는 100 recordExceptions failure count를 증가시켜야하는 exception list ignoreExceptions failure count를 증가시키지 않고 무시하는 exception list recordFailure 어떠한 경우에 Failure Count를 증가시킬지 Predicate를 정의해 CircuitBreaker에 대한 Exception Handler를 재정의하는 것이다. true를 return할 경우, failure count를 증가시키게 된다. automaticTransitionFromOpenToHalfOpenEnabled waitDurationInOpenState 기간 이후에 ScheduledExecutorSerivce를 이용해 half-open으로 자동으로 전환해줄지 결정하는 값. default는 false resilience4j-ratelimiterhttps://stripe.com/blog/rate-limitersCircuitBreaker와 비슷한 API를 가지고 있다. In-memory RateLimiterRegistry를 제공하고 RateLimiterConfig로 설정할 수 있다. RateLimiterConfig timeoutDuration 요청을 허용해주기 전까지 기다리는 기간을 의미한다. default는 5초 limitForPeriod 하나의 period(limitRefreshPeriod 값을 사용)마다 허용하는 limit count. default는 50 limitRefreshPeriod limit count(limitForPeriod 값을 사용)가 refresh되는 period duration. 1ns 이상이어야 한다. default는 500ns resilience4j-bulkheadhttps://skife.org/architecture/fault-tolerance/2009/12/31/bulkheads.htmlhttps://github.com/Netflix/Hystrix/wiki/How-it-Works#Isolation Hystrix와 다른 점은 Hystrix는 각각의 dependecy 마다 Thread pool을 주고 Thread Pool size만큼 execution을 제한하고 있다면 resilience4j-bulkhead는 maxConcurrentCalls을 semaphore의 permits 값으로 주고 semaphore를 이용해 제한한다.다른 구현 모듈과 비슷하게 In-memory BulkheadRegistry를 제공한다. BulkheadConfig maxConcurrentCalls Bulkhead가 허용할 최대 concurrent call의 값. default는 25 maxWaitTime Thread가 semaphore를 획득할 때까지 기다리는 timeout 값이다. 값이 0이면 semaphore를 획득할 수 없는 상황에는 기다리지 않고 바로 요청을 막게 된다. default는 0 Dynamic Reconfiguration bulkhead 모듈은 다른 모듈과 다르게 changeConfig() 함수를 제공한다. 하지만 이미 현재 semaphore를 얻기 위해 기다리고 있는 Thread에게는 바뀐 maxWaitTime이 적용되지 않는다. resilience4j-retryRetry는 Registry는 따로 없고 Retry retry = Retry.ofDefaults(&quot;id&quot;); 이런 식으로 생성한다. RetryConfig maxAttempts 최대 retry 시도 횟수. default는 3 waitDuration 시도 실패 후 기다리는 시간을 의미하고 10ms 이상이어야 한다. default는 500ms. retryOnResult response에 따라 재시도를 할지 말지 결정하는 Predicate. retryOnException 어떤 exception이 발생했을때 재시도를 할지 결정하는 Predicate. retryExceptions 재시도를 할 Exception 클래스 리스트. ignoreExceptions 재시도를 하지 않을 Exception 클래스 리스트. retryOnException과 retryExceptions, ignoreExceptions 이 3개를 조합해서 exceptionPredicate를 만들어 retry할 상황을 결정한다. resilience4j-cacheresilience4j-cache는 javax.cache.Cache를 wrapping해서 사용한다. javax.cache.Cache instance를 만들고 그 instance를 io.github.resilience4j.cache.Cache로 wrapping한다.123456789// Create a CacheContext by wrapping a JCache instance.javax.cache.Cache&lt;String, String&gt; cacheInstance = Caching.getCache(&quot;cacheName&quot;, String.class, String.class);Cache&lt;String, String&gt; cacheContext = Cache.of(cacheInstance);// Decorate your call to BackendService.doSomething()CheckedFunction1&lt;String, String&gt; cachedFunction = Decorators.ofCheckedSupplier(() -&gt; backendService.doSomething()) .withCache(cacheContext) .decorate();String value = Try.of(() -&gt; cachedFunction.apply(&quot;cacheKey&quot;)).get(); resilience4j-timelimiterTimeLimiter는 future supplier의 time limit을 정하는 API이다. TimeLimiterConfig timeoutDuration 실행 timeout 값이다. default는 1초 cancelRunningFuture timeout 발생 후 future를 취소할지 결정하는 boolean 값. default는 true","categories":[{"name":"resilience4j","slug":"resilience4j","permalink":"https://dlsrb6342.github.io/categories/resilience4j/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"resilience4j","slug":"resilience4j","permalink":"https://dlsrb6342.github.io/tags/resilience4j/"}]},{"title":"Effective Java 3rd ITEM 24","slug":"Effective-Java-3rd-ITEM-24","date":"2019-06-02T09:06:08.000Z","updated":"2021-01-30T08:34:59.133Z","comments":true,"path":"2019/06/02/Effective-Java-3rd-ITEM-24/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/02/Effective-Java-3rd-ITEM-24/","excerpt":"","text":"ITEM 24. Favor static member classes over nonstatic중첩 클래스는 다른 클래스 안에 정의된 클래스를 말한다. 자신을 감싼 바깥 클래스에서만 쓰여야 하며 그 외로 쓰인다면 톱레벨 클래스로 작성해야 한다. 정적 멤버 클래스정적 멤버 클래스는 다른 클래스 안에 선언되어있는 점과 바깥 클래스의 private 멤버에 접근할 수 있다는 점을 제외하고는 보통의 클래스와 같다.정적 멤버 클래스는 바깥 클래스와 함께 쓰일 때만 유용한 public 클래스로 쓰인다. 비정적 멤버 클래스비정적 멤버 클래스의 가장 큰 특징은 바깥 클래스의 인스턴스에 비정적 멤버 클래스의 인스턴스가 연결되어있다는 점이다. 그래서 바깥 클래스명.this 형태로 바깥 인스턴스의 메서드를 호출할 수 있다.따라서 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없기 때문에, 바깥 인스턴스와 멤버 클래스가 독립적이라면 정적 멤버 클래스로 작성해야 한다.비정적 멤버 클래스의 인스턴스와 바깥 인스턴스 사이의 관계는 멤버 클래스 인스턴스가 생길 때 멤버 클래스 인스턴스 안에 만들어진다. 이 때문에 메모리 공간을 차지하게 되고 생성 시간 또한 더 걸린다. 비정적 멤버 클래스로 작성하면 바깥 인스턴스의 숨은 외부 참조를 갖게 되면서 가바지 컬렉션이 바깥 인스턴스를 수거하지 못하는 경우도 발생할 수 있다.따라서 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 정적 멤버 클래스로 작성하자. 익명 클래스익명 클래스는 바깥 클래스의 멤버가 아니다. 쓰이는 시점에 선언과 동시에 인스턴스도 만들어진다. 또 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다. 정적 문맥에서라도 상수 변수 이외의 정적 멤버는 가질 수 없다.익명 클래스는 여러 인터페이스를 구현할 수 없고 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수도 없다. 클래스 이름이 필요한 instanceof 검사도 수행할 수 없다.Lambda가 나오기 전에 작은 함수 객체나 처리 객체를 만드는데 익명 클래스가 많이 쓰였다. 지역 클래스지역변수를 선언할 수 있는 곳이면 실질적으로 어디서든 선언할 수 있다. 유효 범위도 지역변수와 같다. 멤버 클래스처럼 이름이 있고 반복 사용 가능하고, 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있고, 정적 멤버는 가질 수 없다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 23","slug":"Effective-Java-3rd-ITEM-23","date":"2019-06-02T08:29:13.000Z","updated":"2021-01-30T08:34:59.132Z","comments":true,"path":"2019/06/02/Effective-Java-3rd-ITEM-23/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/02/Effective-Java-3rd-ITEM-23/","excerpt":"","text":"ITEM 23. Prefer class hierarchies to tagged classes태그 달린 클래스태그 달린 클래스란 내부에 enum type을 가지고 enum 값에 따라 인스턴스가 의미하는 바가 달라지는 클래스를 이야기한다.1234567891011121314151617class Figure &#123; enum Shape &#123; RECTANGLE, CIRCLE &#125;; final Shape shape; // For rectangle double length; double width; // For circle double radius double area() &#123; switch(shape) &#123; ... &#125; &#125;&#125;이러한 클래스는 태그마다 동작이 달라지는 method에는 switch 문이 필요하고 각각이 필요한 필드들을 함께 가지고 있어야 한다. 심지어 관련없는 필드들은 초기화를 하지 않아 final 선언도 불가하다.만약 switch문에서 한가지 태그를 빠뜨렸다면 컴파일 타임이 아닌 런타임에 오류가 생길 것이다.태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율 적이다. 클래스 계층구조계층 구조의 root가 될 추상 클래스를 정의하고, 태그 값에 따라 동작이 달라지는 메서드들을 추상 메서드로 빼주면 된다. 위 Figure에서는 area() 함수가 그에 해당한다.1234567891011121314151617181920212223abstract class Figure &#123; abstract double area();&#125;class Circle extends Figure &#123; final double radius; Circle(double radius) &#123; this.radius = radius; &#125; @Override double area() &#123; return Math.PI * (radius * radius); &#125;&#125; class Rectangle extends Figure &#123; final double length; final double width; Rectangle(double length, double width) &#123; this.length = length; this.width = width; &#125; @Override double area() &#123; return length * width; &#125;&#125;계층구조로 작성했을 때는 새로운 타입을 추가하더라도 컴파일 타임에서 추상 메서드 구현 여부를 확인해주기 때문에 런타임 오류가 발생할 일도 없다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 22","slug":"Effective-Java-3rd-ITEM-22","date":"2019-06-02T07:41:07.000Z","updated":"2021-01-30T08:34:59.131Z","comments":true,"path":"2019/06/02/Effective-Java-3rd-ITEM-22/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/02/Effective-Java-3rd-ITEM-22/","excerpt":"","text":"ITEM 22. Use interfaces only to define types클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것이다. 인터페이스는 이 용도로만 활용해야 한다. 상수 인터페이스상수 인터페이스는 인터페이스를 잘못 사용한 예이다.클래스의 내부 구현에 해당하는 상수를 인터페이스에 구현하는 것은 내부 구현을 클래스의 API로 노출하는 행위다. 상수를 공개할 목적이라면 특정 클래스에 관련된 상수이면 그 클래스에, 열거타입으로 가능하다면 열거타입으로, 아니라면 유틸리티 클래스로 공개하는 것이 좋다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 21","slug":"Effective-Java-3rd-ITEM-21","date":"2019-06-02T07:13:52.000Z","updated":"2021-01-30T08:34:59.130Z","comments":true,"path":"2019/06/02/Effective-Java-3rd-ITEM-21/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/02/Effective-Java-3rd-ITEM-21/","excerpt":"","text":"ITEM 21. Design interfaces for posterityJava8에 와서 Interface에 Default method를 추가해 인터페이스에 메서드를 추가하는 방법이 생겼지만 이 방법도 안전하진 않다.Java7 이전의 구현 클래스들은 인터페이스에 메서드가 추가될 일은 영원히 없다라는 가정 하에 작성되었다. 그렇기 때문에 Default method를 선언하면 해당 method를 재정의하지 않은 모든 구현 클래스에서 Default method가 쓰이게 된다. 이 과정에서 모든 구현 클래스에 Default method가 아무 문제없이 적용될거라는 보장이 없다. Java CollectionJava8의 Collection에는 Lambda를 활용하기 위한 Default method가 다수 추가되었다.이중 removeIf()는 Predicate를 받아 모든 원소를 test해서 true이면 삭제하는 Collection의 Default method이다. 범용적으로 잘 구현된 코드이지만 apache commons-collections의 SynchronizedCollection의 동기화 문제를 해결해주지 못한다.SynchronizedCollection은 모든 메서드를 호출할 때 lock을 통해 동기화 관리를 해주고 있지만 removeIf()의 Default method를 사용하면 동기화를 해주지 못한다.123456789/** * @since 4.4*/@Overridepublic boolean removeIf(final Predicate&lt;? super E&gt; filter) &#123; synchronized (lock) &#123; return decorated().removeIf(filter); &#125;&#125;현재 4.3까지 release되어있지만 4.4부터 removeIf()를 구현해두었다. Interface 설계Default method를 기존 인터페이스에 추가하는 일은 꼭 필요하지 않다면 피해야 한다. Default method는 기존 구현체에 런타임 오류를 일으킬 수도 있고 기존 구현 클래스와 충돌할 수 있기 때문이다.인터페이스를 설계할 때는 Default method가 생겼더라도 세심한 주의를 기울이고 최소한 3가지는 직접 구현해봐야 결함을 찾아낼 수 있다.생각할 수 있는 모든 상황에서 불변식을 해치지 않는 Default method를 만들기는 어려운 법이다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 20","slug":"Effective-Java-3rd-ITEM-20","date":"2019-06-01T09:46:49.000Z","updated":"2021-01-30T08:34:59.129Z","comments":true,"path":"2019/06/01/Effective-Java-3rd-ITEM-20/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/01/Effective-Java-3rd-ITEM-20/","excerpt":"","text":"ITEM 20. Prefer interfaces to abstract classes자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스이다.이 둘의 가장 큰 차이는 추상클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다. 자바는 단일 상속만 지원하기 때문에, 추상 클래스 방식은 새로운 타입을 정의하는 데 커다란 제약을 안게 되는 셈이다.반면 인터페이스는 어떤 클래스를 상속했든 같은 타입으로 취급된다. 인터페이스의 장점 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.새로운 인터페이스가 요구하는 메서드를 추가하고 implement만 선언하면 된다.Comparable, Iterable, AutoCloseable 인터페이스가 추가됐을 때 표준 라이브러리의 기존 클래스가 이 인터페이스들을 구현한 채 새로 릴리즈됐다.반면 추상클래스를 새로 끼워넣는 일은 클래스 계층구조상 어려운 일이다. 인터페이스는 믹스인 정의에 안성맞춤이다.믹스인(mixin)이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 ‘주된 타입’ 외에도 특정 선택적 행위를 제공한다고 선언할 수 있다. 기능을 향상시키는 안전하고 강력한 수단이다. 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.계층을 엄격히 구분하기 어려운 개념일 때 인터페이스가 유용하다. 예를 들어 Singer / SongWriter가 있다.12345678public interface Singer &#123; AudioClip sing(Song s); &#125;public interface SongWriter &#123; Song compose(int chartPosition); &#125;public interface SingerSongWriter &#123; AudioClip sing(Song s); Song compose(int chartPosition);&#125; 이러한 구조를 클래스로 만들려면 가능한 조합이 2^n개가 된다. 추상 골격 구현 클래스추상 골격 구현 클래스를 제공하여 추상 클래스의 장점도 취할 수 있다.인터페이스로는 디폴트 메서드와 타입을 정의하고 골격 구현 클래스에서 나머지 메서드를 구현한다.이렇게 하면 골격 구현 클래스를 상속하는 것만으로 인터페이스 구현의 대부분이 완료된다. AbstractCollection들이 좋은 예이다.인터페이스의 기반 메서드들은 골격 구현 클래스의 추상 메서드가 되고 기반 메서들을 사용해 직접 구현할 수 있는 메서드는 모두 디폴트 메서드를 제공한다.단 equals / hashCode는 인터페이스의 디폴트 메서드로 제공하면 안되고 골격 구현 클래스에서 구현해야 한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 19","slug":"Effective-Java-3rd-ITEM-19","date":"2019-06-01T08:15:57.000Z","updated":"2021-01-30T08:34:59.127Z","comments":true,"path":"2019/06/01/Effective-Java-3rd-ITEM-19/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/01/Effective-Java-3rd-ITEM-19/","excerpt":"","text":"ITEM 19. Design and document for inheritance or else prohibit it상속을 고려한 설계와 문서화상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.클래스의 공개된 메서드에서 자신의 또 다른 메서드를 호출할 수도 있다.이 호출되는 메서드가 재정의 가능 메서드라면 이 사실을 API 설명에 적시해야 한다.문서로 남기는 것 뿐만 아니라 효율적인 하위 클래스 작성을 위해 클래스 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.protected로 노출할 메서드를 결정하는 것은 실제 하위 클래스를 만들어 시험해보는 것이 가장 좋다.꼭 필요한 protected 멤버를 찾을 수 있고 혹은 필요하지 않지만 protected로 선언된 멤버도 찾을 수 있다.그러므로 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.상속용 클래스의 생성자는 직접/간접적으로 재정의 가능 메서드를 호출해서는 안된다.만약 하위 클래스 생성자보다 먼저 재정의 가능 메서드가 호출되면 의도대로 동작하지 않을 수 있다.Cloneable과 Serializable 인터페이스를 구현한 클래스는 상속할 수 없게 하는것이 일반적이다.이런 클래스를 상속하는 것은 프로그래머에게 큰 부담일 수 있다.이 클래스를 상속하는 하위 클래스에서 이 인터페이스들을 구현하게 하는 방법도 있다.위 인터페이스 구현 시, clone / readObject 도 생성자와 비슷한 효과를 낸다.그러므로 clone / readObject도 생성와 같이 직접/간접적으로 재정의 가능 메서드를 호출해서는 안된다.또 Serializable 구현한 클래스의 readResolve / writeReplace는 private가 아닌 protected이어야 한다.private일 경우, 하위 클래스에서 무시되기 때문이다.상속용으로 설계되지 않은 클래스는 상속을 금지해야 한다. (ITEM 18 참고)","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 18","slug":"Effective-Java-3rd-ITEM-18","date":"2019-06-01T06:25:45.000Z","updated":"2021-01-30T08:34:59.126Z","comments":true,"path":"2019/06/01/Effective-Java-3rd-ITEM-18/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/01/Effective-Java-3rd-ITEM-18/","excerpt":"","text":"ITEM 18. Favor composition over inheritance메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.메서드 재정의에 의한 문제상위 클래스 구현에 따라 하위 클래스의 동작이 달라질 수 있다.상위 클래스는 릴리즈마다 내부 구현이 달라질 수 있으며, 그 여파로 하위 클래스가 오동작할 수 있다.만약 컬렉션을 상속하여 원소 추가 시에 검증 로직이 들어간 클래스가 있다면다음 릴리즈에 컬렉션에 원소 추가 메서드가 새로 만들어지면 검증 로직을 타지 않은 원소가 들어갈 수 있다. 새로운 메서드 추가에 의한 문제메서드 재정의보다는 안전하지만 문제가 있다.만약 상의 클래스에 새 메서드가 추가되었는데, 하위 클래스의 새로운 메서드와 시그니처가 같고 반환 타입만 다르다면 컴파일조차 되지 않는다. 상속이 아닌 컴포지션 Composition : 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하는 방법. Forwarding : 새 클래스의 인스턴스 메서드들이 기존 클래스의 대응하는 메서드를 호출 Wrapper Class : 기존 클래스의 인스턴스를 감싸고 있는 새로운 클래스 레퍼 클래스는 거의 단점이 없지만 콜백 프레임워크와는 어울리지 않는다.내부 객체가 자신을 감싸고 있는 레퍼의 존재를 몰라 레퍼 인스턴스가 아닌 내부 객체를 넘겨주게 된다. Guava에 모든 컬렉션 인터페이스용 전달 메서드를 구현해둔 클래스가 있다. 컴포지션을 써야 할 상황에서 상속을 사용하는건 내부 구현을 불필요하게 노출한다.예를 들어 Properties는 HashTable을 상속하고 있는데,Properties.getProperty(key)와 Properties.get(key) 두 가지 방법으로 value를 가져올 수 있다.getProperty()는 Properties의 기본 동작이고 get()은 HashTable로부터 받은 메서드라 결과도 다를 수 있다. 컴포지션 대신 상속을 사용하기로 결정하기 전! 하위 클래스가 정말 상위 클래스인가? 확장하려는 클래스의 API에 결함이 없는가? 결함이 있다면, 이 결함이 확장 클래스의 API까지 전파돼도 괜찮은가?","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 17","slug":"Effective-Java-3rd-ITEM-17","date":"2019-06-01T05:32:00.000Z","updated":"2021-01-30T08:34:59.125Z","comments":true,"path":"2019/06/01/Effective-Java-3rd-ITEM-17/","link":"","permalink":"https://dlsrb6342.github.io/2019/06/01/Effective-Java-3rd-ITEM-17/","excerpt":"","text":"ITEM 17. Minimize mutability불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다.String, Boxing Class, BigInteger, BigDecimal이 자바 라이브러리에 있는 불변 클래스이다. 클래스를 불변으로 만드는 5가지 규칙 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다. 클래스를 확장할 수 없도록 한다. 클래스를 final로 선언하는 방법이 있다. 모든 필드를 final로 선언한다. 모든 필드를 private를 선언한다. 자신 외에는 내부의 가변 객체에 접근할 수 없도록 한다. 생성자 / 접근자 / readObject 모두 방어적 복사를 수행하라. 불변 클래스의 장점불변 객체는 단순하다.불변 객체는 생성 시점의 상태를 파괴될 때까지 그대로 간직한다.불변 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않아도 영원히 불변으로 남는다.하지만 가변 객체는 언제 변할지 몰라 복잡한 상태에 놓일 수 있다. 불변 객체는 근본적으로 Thread Safe하여 따로 동기화할 필요가 없다.여러 Thread에서 동시에 사용해도 훼손되지 않는다.불변 클래스는 클래스를 Thread Safe하게 만드는 가장 쉬운 방법이다. 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.예를 들어 BigInteger는 부호와 크기를 사용하는데 negate()는 크기는 그대로 사용하고 부호만 바꿔 새로운 BigInteger를 생성한다.그 결과 새로 만든 BigInteger는 원본 인스턴스가 가리키는 내부 배열을 그대로 가진다.12345678public class BigInteger extends Number implements Comparable&lt;BigInteger&gt; &#123; final int signum; final int[] mag; public BigInteger negate() &#123; return new BigInteger(this.mag, -this.signum); &#125;&#125; 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.값이 바뀌지 않는 구성요소들로만 이뤄진 객체라면 그 구조가 복잡하더라도 불변을 유지하기 수월하다. 불변 객체는 그 자체로 실패 원자성을 제공한다.실패 원자성이란 ‘메서드에서 예외가 발생한 후에도 그 객체는 여전히 호출 전과 같은 유효한 상태여야 한다’를 뜻한다.불변 객체는 상태가 절대 변하지 않으니 불일치 상태에 빠질 가능성이 없다. 불변클래스의 단점값이 다르면 반드시 독립된 객체로 만들어야 한다.값의 가짓수가 많다면 처리하는데 큰 비용이 든다.예를 들어, 백만 비트의 BigInteger의 비트 하나를 바꾸려 한다면 하나의 비트를 바꾸기 위해 백만 비트짜리 인스턴스를 새로 만들게 된다.이러한 연산에서 발생하는 문제에 대처하는 방법은 가변 동반 클래스를 제공하는 것이다.예를 들어 BigInteger는 모듈러 지수같은 다단계 연산 속도를 높이기 위해 MutableBigInteger를 package-private으로 두고 있다.String에서는 StringBuilder와 StringBuffer가 있다. 클래스를 상속하지 못하게 만드는 방법. final Class로 선언. 모든 생서자를 private or package-private로 선언하고 정적 팩터리를 제공. 정적 팩터리로 구현했을 경우, 가변 동반 클래스같은 다수의 구현 클래스를 만들어 활용할 수 있고객체 캐싱과 같은 기능 추가에도 유연하기 때문에 이 방식이 최선일 때가 많다.클랙스는 꼭 필요한 경우가 아니라면 불변이어야 한다. 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.확실한 이유가 없다면 그 어떤 초기화 메서드도 public으로 제공해서는 안된다. 복잡성만 커지고 성능 이점은 거의 없다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"spring cloud gateway 구조","slug":"spring-cloud-gateway-구조","date":"2019-05-14T14:11:51.000Z","updated":"2021-01-30T08:34:59.273Z","comments":true,"path":"2019/05/14/spring-cloud-gateway-구조/","link":"","permalink":"https://dlsrb6342.github.io/2019/05/14/spring-cloud-gateway-%EA%B5%AC%EC%A1%B0/","excerpt":"","text":"https://cloud.spring.io/spring-cloud-gateway/spring-cloud-gateway.html#gateway-how-it-works spring-cloud-gateway의 공식문서 how it works를 보다가 조금더 자세하게 Diagram을 그려봤다. 1. ReactorHttpHandlerAdapter.apply(request, response)HttpServerRequest와 HttpServerResponse를 HttpWebHandlerAdapter에 ReactorServerRequest / ReactorServerResponse로 NettyBufferFactory와 함께 wrapping해 전달해준다. 2. HttpWebHandlerAdapterReactorHttpHandlerAdapter로부터 받은 ReactorServerRequest / ReactorServerResponse를 ServerWebExchange로 만들어 DispatcherHandler에게 넘겨준다. 3. DispatcherHandlerHandlerMappings - RouterFunction / RequestMapping / RoutePredicateHandlerMapping HandlerMapping에 WebFlux가 지원하는 RouterFounction과 RequestMapping이 있고 그 이외의 spring-cloud-gateway의 RoutePredicateHandlerMapping이 있다. Gateway로 들어오는 request는 RoutePredicateHandlerMapping이 handler를 찾게 된다. RoutePredicateHandlerMapping.getHandler(ServerWebExchange).getHandlerInternal(ServerWebExchange) 4. RoutePredicateHandlerMappinggetHandlerInternal() lookupRoute() method를 통해 Route마다 설정된 Predicate를 적용해 알맞은 Route instance를 찾는다. 여기서 찾은 Route instance를 ServerWebExchange에 attribute로 넣어주고 GlobalFilter를 가지고 있는 FilteringWebHandler를 return한다. FilteringWebHandler는 spring-web이 아닌 spring-cloud-gateway에 속한 class를 의미한다. https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/server/handler/FilteringWebHandler.java https://github.com/spring-cloud/spring-cloud-gateway/blob/master/spring-cloud-gateway-core/src/main/java/org/springframework/cloud/gateway/handler/FilteringWebHandler.java 5. DispatcherHandlerinvokeHandler() RoutePredicateHandlerMapping에서 return 받은 FilteringWebHandler를 지원하는 handlerAdapter를 찾고 handling한다. FilteringWebHandler를 지원하는 handlerAdapter는 SimpleHandlerAdapter이다. 6. SimpleHandlerAdapterSimpleHandlerAdapter.handle()은 항상 Mono.empty()를 return한다.그러므로 DispatcherHandler는 handlerAdapter로부터 return받아 handleResult를 call하게 되는데 값이 empty이기 때문에 DispatcherHandler.resultHandlers는 아무 일도 하지 않게 된다. 7. FilteringWebHandlerhandle() Route instance에서 GatewayFilter를 가져와 GlobalFilters와 Order에 따라 chaning해서 수행하게 된다. For example as GatewayFilter, AddRequestHeaderGatewayFilterFactory, and so on.. NettyWriteResponseFilter NettyWriteResponseFilter는proxy한 reponse를 ServerWebExchange.response에 쓰는 역할을 한다. And Finally HttpServerResponse will be passed.","categories":[{"name":"spring-cloud","slug":"spring-cloud","permalink":"https://dlsrb6342.github.io/categories/spring-cloud/"},{"name":"spring-cloud-gateway","slug":"spring-cloud/spring-cloud-gateway","permalink":"https://dlsrb6342.github.io/categories/spring-cloud/spring-cloud-gateway/"}],"tags":[{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://dlsrb6342.github.io/tags/spring/"},{"name":"spring-cloud","slug":"spring-cloud","permalink":"https://dlsrb6342.github.io/tags/spring-cloud/"}]},{"title":"Effective Java 3rd ITEM 16","slug":"Effective-Java-3rd-ITEM-16","date":"2019-05-14T13:43:47.000Z","updated":"2021-01-30T08:34:59.124Z","comments":true,"path":"2019/05/14/Effective-Java-3rd-ITEM-16/","link":"","permalink":"https://dlsrb6342.github.io/2019/05/14/Effective-Java-3rd-ITEM-16/","excerpt":"","text":"ITEM 16. In public classes, use accessor methods, not public fields패키지 바깥에서 접근할 수 있는 클래스라면 접근자(getter, setter)를 제공해서 클래스 내부 구현을 언제든 수정할 수 있는 유연성을 갖게 해야 한다.하지만 package-private / private 중첩 클래스라면 필드를 public으로 노출하는 것이 오히려 깔끔할 수 있다.어차피 클라이언트도 내부 패키지 안에 있기 때문에 수정에 대한 유연성이 유지된다. public 클래스의 필드가 불변이라면 public으로 노출할 때의 단점이 줄긴 하지만 완전히 안심할수는 없다. API를 변경하지 않고는 표현 방식을 바꿀 수 없고 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점은 여전히 있다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 15","slug":"Effective-Java-3rd-ITEM-15","date":"2019-05-14T12:24:21.000Z","updated":"2021-01-30T08:34:59.123Z","comments":true,"path":"2019/05/14/Effective-Java-3rd-ITEM-15/","link":"","permalink":"https://dlsrb6342.github.io/2019/05/14/Effective-Java-3rd-ITEM-15/","excerpt":"","text":"ITEM 15. Minimize the accessibility of classes and members컴포넌트는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨겨서 설계해야 한다.오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 구현에는 전혀 관여하지 않는 이것을 정보 은닉, 캡슐화라고 한다. 정보 은닉의 장점 여러 컴포넌트를 병렬로 개발할 수 있기 때문에 시스템 개발 속도를 높인다. 컴포넌트 파악이 쉬워 디버깅하기 좋고, 다른 컴포넌트로 교체하기 쉽기 때문에 관리 비용을 낮춘다. 최적화할 컴포넌트를 정하고 해당 컴포넌트만 수정하면 되기 때문에 성능 최적화에 도움을 준다. 독자적으로 사용할 수 있는 컴포넌트라면 다른 환경에서도 유용하게 쓰일 수 있기 때문에 소프트웨어 재사용성을 높인다. 개별 컴포넌트의 단위 테스트가 가능하여 큰 시스템을 제작하는 난이도를 낮춰준다.Java에서의 정보 은닉은 클래스, 인터페이스, 멤버의 접근성을 명시하는 접근 제어 메커니즘이 핵심이다. 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.패키지 외부에서 쓸 이유가 없다면 package-private으로 선언하자.package-private로 선언된 클래스는 내부 구현이 되어 클라이언트를 고려하지 않고 언제든 수정이 가능해진다. 반면에 public으로 선언한다면 하위 호환을 고려해야 한다. 한 클래스에서만 사용하는 package-private 클래스는 private static으로 중첩시켜보자.private static으로 중첩시켜 넣으면 하나의 클래스에서만 접근할 수 있다. 메서드 재정의상위 클래스의 메서드를 재정의할 때는 접근 수준을 상위클래스에서보다 더 좁게 설정할 수 없다. 테스트를 위한 접근 범위 수정private 멤버를 package-private까지 풀어주는 것은 허용 가능하지만 그 이상은 안된다.테스트 코드를 테스트 대상과 같은 패키지에 두면 package-prviate 요소에 접근할 수 있다. public 클래스의 필드는 되도록 public이 아니어야 한다.public으로 선언하면 필드의 값을 제한할 수 없게 된다. 또한 필드가 수정될 때 다른 작업을 할 수 없게 되어 public 가변 필드를 갖는 클래스는 일반적으로 Thread safe 하지 않다. public static final 필드가 참조하는 객체는 불변이어야 한다.가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다. 자바 9의 모듈 시스템기존 4개의 접근 수준과 다르게 모듈에 적용되는 새로운 접근 수준이 있다.모듈은 자신에 속하는 패키지 중 공개할 패키지를 module-info.java에 선언한다. module-info에 선언되지 않은 클래스는 protected 혹은 public이더라도 모듈 외부에서는 접근할 수 없다. 하지만 꼭 필요한 경우가 아니라면 당분간은 사용하지 않는게 좋을 것 같다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"4. Classes and Interfaces","slug":"Effective-Java-3rd/4-Classes-and-Interfaces","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/4-Classes-and-Interfaces/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 14","slug":"Effective-Java-3rd-ITEM-14","date":"2019-05-03T11:39:03.000Z","updated":"2021-01-30T08:34:59.122Z","comments":true,"path":"2019/05/03/Effective-Java-3rd-ITEM-14/","link":"","permalink":"https://dlsrb6342.github.io/2019/05/03/Effective-Java-3rd-ITEM-14/","excerpt":"","text":"ITEM 14. Consider implementing ComparableComparable는 단순 동치성 비교와 순서비교를 해주는 Generic interface이다. 단순 동치성 비교를 지원한다는 점에서 Object.equals()와 비슷한 부분이 있다.한 클래스가 Comparable을 구현했다는 것은 인스턴스들이 자연적인 순서를 가진다는 것을 뜻한다. compareTo method 규약 두 객체 참조의 순서를 바꿔 비교해도 예상한 결과가 나와야 한다. 첫 번째가 두 번째보다 크고 두 번째가 세 번째보다 크면, 첫 번째는 세 번째보다 커야 한다. 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야 한다. -&gt; compareTo의 동치성 결과가 equals의 결과와 같아야 한다. 3번 규약을 지키지 않을 경우, 정렬된 컬렉션에서 의도한 동작과 다르게 동작할 수 있다.예를 들어 HashSet은 equals를 통해 비교하지만 TreeSet은 compareTo로 비교하기 때문에 같은 Set이지만 똑같은 원소들을 넣어도 다른 동작을 할 수 있다. 만약 핵심 필드가 여러 개일 경우, 그 순서를 정해서 순서대로 비교하자.12345678910public int compareTo(PhoneNumber pn) &#123; int result = Short.compare(this.areaCode, pn.areaCode); if (result == 0) &#123; result = Short.compare(this.prefix, pn.prefix); if (result == 0) &#123; result = Short.compare(this.lineNum, pn.lineNum); &#125; &#125; return result;&#125;12345678private static final Comparator&lt;PhoneNumber&gt; COMPARATOR = Comparator.comparingInt((PhoneNumber pn) -&gt; pn.areaCode) .thenComparingInt(pn -&gt; pn.prefix) .thenComparingInt(pn -&gt; pn.lineNum)public it compareTo(PhoneNumber pn) &#123; return COMPARATOR.compare(this, pn);&#125;핵심 필드를 하나하나 비교해서 0일 경우(같을 경우)에만 다음 필드를 비교하게 한 코드이다. 두 번째 코드는 java8 이후의 Comparator에 구현된 static 생성 메서드를 활용한 코드이다. 순서를 고려해야 하는 클래스라면 꼭 Comparable interface를 구현해서 정렬, 검색, 비교가 오작동하지 않도록 해야한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"3. Methods Common to All Objects","slug":"Effective-Java-3rd/3-Methods-Common-to-All-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/3-Methods-Common-to-All-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 13","slug":"Effective-Java-3rd-ITEM-13","date":"2019-05-01T02:58:40.000Z","updated":"2021-01-30T08:34:59.121Z","comments":true,"path":"2019/05/01/Effective-Java-3rd-ITEM-13/","link":"","permalink":"https://dlsrb6342.github.io/2019/05/01/Effective-Java-3rd-ITEM-13/","excerpt":"","text":"ITEM 13. Override clone judiciouslyCloneableCloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스이다.하지만 clone method는 Cloneable이 아닌 Object에 선언되어있고 그마저도 protected이다.그래서 Cloneable을 implement 한다고 해서 clone method를 호출할 수 있는것이 아니다.Cloneable은 Object의 protected method인 clone의 동작 방식을 결정한다. Cloneable을 구현한 클래스만 clone method를 수행할 수 있다. 강제성이 없다는 점만 제외하면 clone method는 Constructor Chaining과 비슷한 부분이 있다. 즉 clone method가 super.clone을 호출하지 않고 생성자를 호출해 얻은 인스턴스를 반환해도 문제될 것은 없지만 해당 클래스를 상속받은 하위 클래스에서 super.clone을 호출한다면 잘못된 클래스의 객체가 생성된다. 따라서 하위 클래스에서 super.clone을 호출할 가능성이 있다면 제대로된 clone 구현이 필요하다. 하위 클래스가 없는 final class의 경우, clone method 재정의에서 안전하다. final class의 clone method에서 super.clone을 호출하지 않는다면 Cloneable을 구현할 이유도 없다. 가변 객체를 가진 클래스1234public class Stack &#123; private Object[] elements; private int size = 0;&#125; 위 Stack 클래스는 elements라는 가변 객체를 참조하고 있다. 이 클래스의 clone method가 단순히 super.clone을 호출한다면 clone으로 생성된 객체의 elements와 기존 객체의 elements는 같은 배열을 참조하게 된다.따라서 clone으로 생성된 객체의 elements를 변경하면 기존 객체도 영향을 받게 된다.clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.123456789@Override public Stack clone() &#123; try &#123; Stack result = (Stack) super.clone(); result.elements = this.elements.clone(); return result; &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125;&#125;위 구현이 Stack의 제대로된 clone method이다. elements.clone()을 통해 elements 내부 정보 또한 복사해주어야 한다. CloneNotSupportedException은 발생할 일이 없지만 Checked Exception이기 때문에 사용하기 편하라고 handling 해주는게 좋다. 만약 elements field가 final이었다면 위 방식은 동작하지 않는다. final field에 새로운 값을 정의할 수 없기 때문이다. 이 상황에서 우린 Cloneable을 구현하기 위해 기존 구조를 바꿔야하는 문제점을 볼 수 있다. clone을 정확히 재정의하려면 그 객체의 내부 깊숙하게 숨어있는 모든 가변 객체를 복사하고 복제본이 가진 객체 참조 모두가 복사된 객체들을 가리키게 해야한다. 내부 복사는 주로 재귀적으로 clone을 호출해 구현하지만 너무 길면 StackOverflow를 발생시킬 수 있다.결론은 복제를 하고 싶다면 아래와 같이 복제 생성자(변환 생성자)나 복제 팩터리(변환 팩터리)를 사용하자.Collection 구현체들은 대부분 복제 생성자를 가지고 있다.복제 생성자나 복제 팩터리로 Cloneable/clone을 충분히 대치할 수 있다.12public Yum(Yum yum) &#123; ... &#125;;public static Yum newInstance(Yum yum) &#123; ... &#125;;","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"3. Methods Common to All Objects","slug":"Effective-Java-3rd/3-Methods-Common-to-All-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/3-Methods-Common-to-All-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 12","slug":"Effective-Java-3rd-ITEM-12","date":"2019-04-30T09:26:31.000Z","updated":"2021-01-30T08:34:59.120Z","comments":true,"path":"2019/04/30/Effective-Java-3rd-ITEM-12/","link":"","permalink":"https://dlsrb6342.github.io/2019/04/30/Effective-Java-3rd-ITEM-12/","excerpt":"","text":"ITEM 12. Always override toStringtoSting 규약 간결하면서 사람이 읽기 쉬운 형태의 유익한 정보를 반환하라. 모든 하위 클래스에서 이 메서드를 재정의하라. equals와 hashCode만큼 중요하진 않지만 잘 구현하면 사용하기 좋고 디버깅이 쉽다. 그 객체가 가진 주요 정보 모두를 반환하는게 좋다. 포맷을 명시하든 아니든 의도는 명확히 밝혀야 한다. toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"3. Methods Common to All Objects","slug":"Effective-Java-3rd/3-Methods-Common-to-All-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/3-Methods-Common-to-All-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 11","slug":"Effective-Java-3rd-ITEM-11","date":"2019-04-30T08:37:44.000Z","updated":"2021-01-30T08:34:59.119Z","comments":true,"path":"2019/04/30/Effective-Java-3rd-ITEM-11/","link":"","permalink":"https://dlsrb6342.github.io/2019/04/30/Effective-Java-3rd-ITEM-11/","excerpt":"","text":"ITEM 11. Always override hashCode when you override equalsequals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. hashCode 일반 규약 equals 비교에 사용되는 정보가 변경되지 않았다면, hashCode method는 항상 같은 값을 반환해야 한다. equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다. equals가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다를 필요는 없다. 하지만, 다른 값을 반환해야 HashTable의 성능이 좋아진다. hashCode 구현이상적인 해시 함수는 서로 다른 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다. 전형적인 hashCode123456@Override public int hashCode() &#123; int result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); return result;&#125; 전형적인 hashCode method이다. 31은 홀수이면서 소수이기도 하고 31 * i = (i &lt;&lt; 5) - i 와 같이 시프트연산과 뺄셈으로 최적화할 수 있어 사용하고 있다. 하지만 사용하는 이유는 명확하지는 않고 전통적으로 쓰고 있다. Objects를 활용한 hashCode123@Override public int hashCode() &#123; return Objects.hash(lineNum, prefix, areaCode);&#125; Objects 클래스에서 임의의 객체들을 받아 hash를 생성해주는 method가 있지만 성능이 느리다. 캐싱을 이용한 hashCode123456789101112private int hashCode;@Override public int hashCode() &#123; int result = hashCode; if (result == 0) &#123; result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); hashCode = result; &#125; return result;&#125; 클래스가 불변이고 해시코드를 계산하는 비용이 크다면 매번 계산하지 않고 캐싱하는 방식을 고려해야 한다. hashCode 주의사항성능을 높인다고 해시코드를 계산할 때 핵심 필드를 생략해서는 안된다.hashCode가 반환하는 값의 생성 규칙을 자세히 공표하지 말아야 한다. 추후 계산 방식을 바꿀 경우를 대비해야 한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"3. Methods Common to All Objects","slug":"Effective-Java-3rd/3-Methods-Common-to-All-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/3-Methods-Common-to-All-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 10","slug":"Effective-Java-3rd-ITEM-10","date":"2019-04-14T09:40:16.000Z","updated":"2021-01-30T08:34:59.118Z","comments":true,"path":"2019/04/14/Effective-Java-3rd-ITEM-10/","link":"","permalink":"https://dlsrb6342.github.io/2019/04/14/Effective-Java-3rd-ITEM-10/","excerpt":"","text":"ITEM 10. Obey the general contract when overriding equalsequals 규약을 어길 경우, 그 객체를 사용하는 다른 객체들(ex, Collections)에서 어떻게 동작할지 예측할 수 없다. equals를 재정의하지 않는 것이 최선인 상황1. 인스턴스가 본질적으로 고유할 때값을 표현하는게 아니라 동작하는 개체를 표현하는 클래스.Thread가 대표적인 예시로 Object의 equals를 쓰는게 옳다. 2. 논리적 동치성(logical equality)를 검사할 일이 없을 때인스턴스 내부의 논리성이 같은지 검사할 필요가 없을 경우에는 Object의 equals만으로도 충분하다. 3. 상위 클래스의 equals로 가능할 때Set -&gt; AbstractSet / List -&gt; AbstractList / Map -&gt; AbstractList 4. 클래스가 private / package-private이고 equals를 호출할 일이 없을 때 5. 값이 같은 인스턴스가 하나만 만들어질 때싱글톤 패턴이나 Enum의 경우와 같이 통제되어있는 상황에서는 equals를 정의할 필요가 없다. equals를 재정의해야 하는 상황1. 논리적 동치성을 비교해야 할 때주로 값 클래스(Value Object)일 경우가 논리적 동치성을 비교해야 할 상황이 많다.객체가 같은지를 비교하는 것이 아니라 값이 같은지 확인해야 하기 때문이다. 2. Map의 key / Set의 원소로 사용하고 싶을 때equals를 활용해서 원소를 확인하기 때문에 equals에 대한 정의가 필요하다.1234567891011121314151617181920212223242526/** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 동치관계1. 반사성(reflexivity)null이 아닌 모든 참조 값 x에 대해 x.equals(x)는 true이다. 2. 대칭성(symmetry)null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)와 y.equals(x)의 값은 같다. 3. 추이성(transitivity)null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y) = true이고 y.equals(z) = true이면 x.equals(z) = true이다.상위 클래스가 구체 클래스인 상황에서 하위 클래스에서 새로운 필드를 추가하게 되는 경우 추이성을 어길 수도 있다.상위 클래스가 추상 클래스인 경우에는 이런 일이 발생하지 않는다. 4. 일관성(consistency)null이 아닌 모든 참조 값 x, y에 대해 x, y에 대한 수정이 없다면 x.equals(y) 값은 변하지 않는다. 5. NonNullnull이 아닌 모든 참조 값 x에 대해 x.equals(null)은 항상 false이다. 양질의 equals 구현 방법1. == 연산자로 자기 자신의 참조인지 확인한다.성능 최적화용이다. 2. instanceof로 올바른 타입인지 확인한다.instanceof 사용 시, null check가 따로 필요없다. 3. 입력을 올바른 타입으로 형변환한다. 4. 핵심 필드들이 모두 일치하는지 하나 하나 검사한다.기본 타입은 == 연산자로, float / double은 Float.compare() / Double.compare()로, 배열은 Arrays.equals를 사용하자. equals 구현 시 주의사항1. equals를 재정의할 땐 hashCode도 반드시 재정의하자. 2. 너무 복잡하게 해결하려 들지 말자. 3. Object 외의 타입을 매개변수로 받는 equals method는 선언하지 말자.1234// Badpublic boolean equals(MyClass o) &#123; ...&#125; 참고https://projectlombok.org/features/EqualsAndHashCode","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"3. Methods Common to All Objects","slug":"Effective-Java-3rd/3-Methods-Common-to-All-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/3-Methods-Common-to-All-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 9","slug":"Effective-Java-3rd-ITEM-9","date":"2019-04-07T12:40:58.000Z","updated":"2021-01-30T08:34:59.178Z","comments":true,"path":"2019/04/07/Effective-Java-3rd-ITEM-9/","link":"","permalink":"https://dlsrb6342.github.io/2019/04/07/Effective-Java-3rd-ITEM-9/","excerpt":"","text":"ITEM 9. Prefer try-with-resources to try-finallytry-with-resourcesjava library에는 close method를 직접 호출해 닫아줘야하는 자원들이 많다.예를 들어, InputStream, OutputStream, Connection 등이 있다.모두 close method를 호출해주어야 하지만 놓치기 쉬워 보통 finalizer를 안전망으로 활용하고 있다.java 7 전에는 try-finally를 통해 자원이 제대로 닫힘을 보장하였다. 하지만 사용하는 자원이 여러개라면 try문이 겹쳐서 작성되게 된다.12345678910111213141516static void copy(String src, String dst) throws IOException &#123; InputStream in = new FileInputStream(src); try &#123; OutputStream out = new FileOutputStream(dst); try &#123; byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) &gt;= 0) out.write(buf, 0, n); &#125; finally &#123; out.close(); &#125; &#125; finally &#123; in.close(); &#125;&#125;알아보기 힘들고 코드가 지저분해지게 된다.또한 이 경우에는 finally문에서 발생한 Exception이 try문에서 발생한 Exception을 집어삼키게 된다.Stack trace에서는 try문 내부의 Exception에 관한 정보는 남지 않아 디버깅을 어렵게 한다. 위와 같은 예제에 try-with-resouces 구문을 적용하게 되면 반드시 닫아줘야하는 자원들을 쉽게 관리할 수 있다.try-with-resouces를 사용하기 위해서는 해당 자원이 AutoCloseable interface가 구현되어 있어야 한다.123456789static void copy(String src, String dst) throws IOException &#123; try (InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst)) &#123; byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) &gt;= 0) out.write(buf, 0, n); &#125;&#125;위 try-finally 예제를 try-with-resources로 구현한 예제이다. 깔끔하고 디버깅에도 훨씬 좋다.try-with-resouces에도 catch 구문은 똑같이 사용할 수 있다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"2. Objects","slug":"Effective-Java-3rd/2-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/2-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 8","slug":"Effective-Java-3rd-ITEM-8","date":"2019-04-07T11:51:32.000Z","updated":"2021-01-30T08:34:59.178Z","comments":true,"path":"2019/04/07/Effective-Java-3rd-ITEM-8/","link":"","permalink":"https://dlsrb6342.github.io/2019/04/07/Effective-Java-3rd-ITEM-8/","excerpt":"","text":"ITEM 8. Avoid finalizers and cleanersFinalizers and CleanersFinalizer는 예측불가능하고 상황에 따라 위험할 수 있어 일반적으로 불필요하다.Java 9에서 Finalizer의 대안으로 cleaner를 소개했지만 그또한 여전히 예측할 수 없고 느리다. 1. 수행 시점객체에 접근할 수 없게 된 후, 언제 finalizer나 cleaner가 실행될지 알 수 없다.이는 GC 알고리즘마다 천차만별이며 환경마다 다르게 동작할 수 있다.Finalizer의 경우, 어떤 스레드가 수행할지 명시되어 있지 않아 낮은 우선순위로 인해 계속 Queue에 쌓여갈 수 있다. 2. 수행 여부Finalizer나 Cleaner는 수행여부를 보장하지 않아 종료 작업이 전혀 수행되지 못한채 프로그램이 종료될 수 있다.예를 들어 DB의 lock 해제를 Finalizer나 Cleaner에게 맡겼다면 점점 시스템이 멈출 것이다ㅣ. 3. 수행 중 발생한 예외Finalizer 수행 중 발생한 예외는 무시되며 다른 작업이 남아있더라도 그 순간 종료된다.마무리가 덜 된 상태의 객체가 남아있을 수 있어 이러한 객체를 사용하게 되면 어떻게 동작할지 예측할 수 없다.예외가 발생해도 Stack trace를 출력하지 않고 그대로 진행된다. Cleaner의 경우, 자신의 스레드를 통제하기 때문에 이러한 문제는 발생하지 않는다. 4. 성능 문제AutoCloseable 객체를 try-with-resources로 생성하고 수거하기까지는 12ns가 걸렸고Finalizer를 사용해서 생성 / 수거를 하기까지는 550ns가 걸렸다. Finalizer가 GC의 효율을 떨어뜨리기 때문이다. 5. 보안 문제생성자나 직렬화 과정(readObject / readResolve)에서 예외가 발생하면 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행되게 할 수 있다.이러한 일그러진 객체 생성을 막으려면 생성자에서 예외를 던지는 것으로 충분하지만 finalizer가 있다면 그렇지 않다.final 클래스로 만들면 하위클래스를 만들 수 없게 되어 안전하지만 final이 아닐 경우, 빈 finalize method를 만들고 final로 선언하면 된다. AutoCloseable파일이나 자원을 담고 있는 객체는 finalizer / cleaner가 아닌 AutoCloseable을 구현해주면 된다.예외가 발생해도 제대로 종료될 수 있도록 try-with-resources를 사용해야 한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"2. Objects","slug":"Effective-Java-3rd/2-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/2-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 7","slug":"Effective-Java-3rd-ITEM-7","date":"2019-03-23T05:42:04.000Z","updated":"2021-01-30T08:34:59.177Z","comments":true,"path":"2019/03/23/Effective-Java-3rd-ITEM-7/","link":"","permalink":"https://dlsrb6342.github.io/2019/03/23/Effective-Java-3rd-ITEM-7/","excerpt":"","text":"ITEM 7. Eliminate obsolete object references직접 메모리를 관리하는 경우123456789101112131415public class Stack &#123; private Object[] elements; private int size = 0; public void push(Object e) &#123; // stack이 꽉 찼을 경우, 공간을 2배 증가시킨다. ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if (size == 0) throw new EmptyStackException(); return elements[--size]; &#125; 직접 메모리를 관리하는 경우에는 GC 입장에서 어떤 객체가 활성영역인지 비활성영역인지 알 길이 없다.비활성영역 객체가 하나 살아있게 될 경우, 그 객체를 참조하는 모든 객체들 또한 GC에서 처리할 수 없게 되어 메모리 누수가 발생할 수 있다.따라서 직접 메모리를 관리할 때는 사용하지 않는 객체에 대해서는 null 처리를 해야 한다.위의 Stack 예시에서는 직접 elements라는 Object 배열을 관리하고 있다. pop()을 호출했을 때, elements의 마지막에서 객체 하나를 꺼내 반환하고 있다.하지만 null 처리를 하지않아 elements 배열에 아직 들어있는 상태이므로 마지막에 있던 원소가 더 이상 사용하지 않는 상태인지 GC 입장에서 판단할 수가 없다.123Object result = elements[--size];elements[size] = null;return result;따라서 위 코드처럼 마지막 element를 꺼내고 null 처리해야 메모리누수를 방지할 수 있을 것으로 보인다. 캐시객체 참조를 캐시에 넣어두고 잊는 경우 메모리 누수의 위험이 있다.외부에서 키에 대한 참조가 살아있는 동안에만 캐시가 필요하다면 WeakHashMap을 사용하도록 권장한다.쓰지 않은 캐시 엔트리에 대한 정리는 Background Theard로 정리하거나 LinkedHashMap.removeEldestEntry 같은 새 엔트리를 추가할 때 정리하는 방식이 있다. Listner or CallbackCallback을 등록만 하고 명확히 해지하지 않는다면 계속 쌓일 것이다.이 경우에도 Callback을 weak reference로 저장하면 해결할 수 있다. (WeakHashMap) 참고GC Reference https://gogorchg.tistory.com/entry/Java-WeakReference-SoftReferernce-StrongReferenceWeakHashMap https://anyuneed.tistory.com/entry/JAVA-WeakHashMap%EC%9D%98-%EC%82%AC%EC%9A%A9","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"2. Objects","slug":"Effective-Java-3rd/2-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/2-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 6","slug":"Effective-Java-3rd-ITEM-6","date":"2019-03-11T12:42:43.000Z","updated":"2021-01-30T08:34:59.171Z","comments":true,"path":"2019/03/11/Effective-Java-3rd-ITEM-6/","link":"","permalink":"https://dlsrb6342.github.io/2019/03/11/Effective-Java-3rd-ITEM-6/","excerpt":"","text":"ITEM 6. Avoid creating unnecessary objects.String12String s1 = new String(&quot;bikini&quot;);String s2 = &quot;bikini&quot;; 위의 s1 / s2 모두 같은 결과를 가져오지만s1의 경우, 호출될 때마다 String 인스턴스 객체를 계속 생성하게 된다.s2의 경우에는, 똑같은 문자열 리터럴을 사용하는 경우 객체 재사용이 보장된다. Static Factory Method12Boolean b1 = new Boolean(&quot;true&quot;);Boolean b2 = Boolean.valueOf(&quot;true&quot;); 위 String의 경우와 비슷한 예제이다. b1은 항상 새로운 객체를 생성하게 되고b2는 static factory method를 사용하기 때문에 같은 객체를 사용하게 된다.b1에서 사용한 생성자는 java 9에서 deprecated되었다. 생성 비용이 높은 객체String을 정규표현식으로 확인하는 방법은 String.matches method가 있다.하지만 이 method는 내부적으로 호출될 때마다 Pattern 인스턴스를 새로 생성하게 된다.Pattern은 인스턴스 생성 비용이 높기 때문에 Pattern 인스턴스를 직접 생성해두고 재사용하는 것이 좋다.1234567public class RegexExample &#123; private static final Pattern PATTERN = Pattern.compile(&quot;...&quot;); public static boolean isMatch(String s) &#123; return PATTERN.matcher(s).matches(); &#125;&#125; Adaptor(?)Adaptor는 뒷단 객체만 관리하면 되므로 뒷단 객체 하나당 Adaptor 하나를 가지게 된다.예를 들어, Map 인터페이스의 keySet method는 Map의 모든 key를 Set에 담아 return한다. 여기서 Map이 뒷단 객체, key가 담긴 Set이 Adaptor를 의미한다.keySet이 호출될때마다 매번 같은 Set 인스턴스를 return한다. 모두가 똑같은 Map 인터페이스를 대변하기 때문에 매번 같은 인스턴스를 return하는 것이다.물론 keySet이 계속 다른 객체를 반환해도 되지만, 그럴 필요도 이득도 없다.Adaptor는 Gamma95 design pattern과 관련된 내용이다. 정확히 다 이해하지 못했다. Auto Boxing123456private static long sum() &#123; Long sum = 0L; for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) sum += i; return sum;&#125; 위의 과정에서 sum 변수가 Long(Wrapper Class)로 선언되었기 때문에 sum += i;가 호출될 때마다 i를 Long으로 Auto Boxing하게 된다.Wrapper Class가 아닌 primitive type을 사용하여 의도치 않은 Auto Boxing을 주의해야 한다. 참고ITEM 60의 방어적 복사와 비교.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"2. Objects","slug":"Effective-Java-3rd/2-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/2-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 5","slug":"Effective-Java-3rd-ITEM-5","date":"2019-03-10T08:08:28.000Z","updated":"2021-01-30T08:34:59.161Z","comments":true,"path":"2019/03/10/Effective-Java-3rd-ITEM-5/","link":"","permalink":"https://dlsrb6342.github.io/2019/03/10/Effective-Java-3rd-ITEM-5/","excerpt":"","text":"ITEM 5. Prefer dependency injection to hardwiring resources많은 클래스가 하나 이상의 의존성(자원)을 가진다. 책에서는 맞춤법 검사를 예로 들고 있다.SpellChecker는 Dictionary라는 의존성(자원)을 필요로 한다. 잘못 구현한 예1. Utility Class123456public class SpellChecker &#123; private static final Lexicon dictionary = ...; private SpellChecker() &#123; &#125;; // static methods...&#125; 2. Singleton1234567public class SpellChecker &#123; private final Lexicon dictionary = ...; private SpellChecker() &#123; &#125;; public static SpellChecker INSTANCE = new SpellChecker(); // static methods...&#125; 위의 두 방식 모두 dictionary field가 고정적이다.다양한 사전을 적용할 필요가 있을때 사용하기 어렵다.이렇게 사용하는 자원(사전)에 따라 동작이 달라진다면 Utility Class나 Singleton은 적합하지 않다. 의존성 주입12345678public class SpellChecker &#123; private final Lexicon dictionary; public SpellChecker(Lexicon dictionary) &#123; this.dictionary = dictionary; &#125; // methods...&#125; 인스턴스를 생성할 때 필요한 자원(사전)을 넘겨주는 방식이다.의존 객체 주입 방식은 자원이 몇개이든 관계가 어떻든 잘 동작한다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"2. Objects","slug":"Effective-Java-3rd/2-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/2-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 4","slug":"Effective-Java-3rd-ITEM-4","date":"2019-03-10T07:34:32.000Z","updated":"2021-01-30T08:34:59.151Z","comments":true,"path":"2019/03/10/Effective-Java-3rd-ITEM-4/","link":"","permalink":"https://dlsrb6342.github.io/2019/03/10/Effective-Java-3rd-ITEM-4/","excerpt":"","text":"ITEM 4. Use Private Constructor for NoninstantiabilityUtility Class java.lang.Math / java.util.Arrays - 기본 타입값, 관련 메서드를 모아놓은 classjava.util.Collections - 특정 인터페이스를 구현하는 객체를 생성해주는 static method를 모아놓은 classfinal class - final class를 상속해서 하위 클래스에 method를 넣는것이 불가능하기 때문에 final class 관련 메서드를 모아놓은 class 위의 3가지의 경우 static method와 static field로만 이루어진 Utility class를 만들게 된다.Utility class는 인스턴스로 만들기 위해 설계된 것이 아니기 때문에 인스턴스 생성을 막을 필요가 있다.NoArgsConstructor가 기본 생성자로 생성되기 때문에 사용자 입장에서 구분할 수 없다. Abstract Class추상 클래스로 만들더라도 해당 클래스를 상속하여 인스턴스를 만들면 되기 때문에 인스턴스화를 막을 수 없다. Private Constructor12345public class Utils &#123; private Utils() &#123; throw new AssertionError(); &#125;&#125; Private Constructor를 추가하여 자동 생성되는 기본 생성자를 안생기게 해준다.생성자를 호출할 수 없기 때문에 인스턴스화를 막을 수 있고 AssertionError를 던져 내부에서도 사용하지 않도록 해준다.이 방식은 상속을 불가능하게 하는 효과도 있다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"2. Objects","slug":"Effective-Java-3rd/2-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/2-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 3","slug":"Effective-Java-3rd-ITEM-3","date":"2019-03-01T03:34:57.000Z","updated":"2021-01-30T08:34:59.138Z","comments":true,"path":"2019/03/01/Effective-Java-3rd-ITEM-3/","link":"","permalink":"https://dlsrb6342.github.io/2019/03/01/Effective-Java-3rd-ITEM-3/","excerpt":"","text":"ITEM 3. Singleton with Private Constructor or Enum함수와 같은 stateless 객체나 설상 유일해야 하는 컴포넌트를 보통 Singleton으로 만든다.그러나 Singleton으로 만들면 mock으로 대체하기가 어려워져 테스트하기가 어려워질 수 있다. Singleton 생성 방식1. Private Constructor1234public class Elvis &#123; public static final Elvis INSTANCE = new Elvis(); private Elvis() &#123; &#125;&#125; static final field인 INSTANCE를 초기화할때 private constructor가 사용된다.private constructor 밖에 없기 때문에 다른 인스턴스를 만들 수 없다.이 방식의 장점은 해당 클래스가 Singleton이라는 것을 명확히 API에 드러난다는 점이다. 2. Static Factory Method12345public class Elvis &#123; private static final Elvis INSTANCE = new Elvis(); private Elvis() &#123; &#125; public static Elvis getInstance() &#123; return INSTANCE; &#125;&#125; 위의 1. Private Constructor와 다른 점은 static final field인 INSTANCE를 private로 지정했다는 점이다.그리고 static method인 getInstance()를 통해 항상 같은 인스턴스를 return하게 된다.이 방식의 장점은 API는 바꾸지 않은채 Singleton이 아니게 변경할 수 있다는 점이다. Static Factory method의 구현만 바꾸면 가능하다. Static Factory method를 Generic Singleton Factory로 바꿀 수 있다(ITEM 30). method reference를 Supplier로 사용할 수 있다. Elvis::getInstance를 Supplier로 사용(ITEM 43, ITEM 44). 3. Enum123public enum Elvis &#123; INSTANCE;&#125; 1번 방식과 비슷하지만 더 간결하다.대부분의 상황에서는 Enum 방식이 가장 좋은 방법이다. 하지만 Singleton으로 만드려는 클래스가 Enum이 아닌 다른 클래스를 상속받아야 한다면 사용할 수 없다. Serialization위 3. Enum 방식의 경우는 추가 코드없이 직렬화가 가능하다.하지만 1, 2 방식은 직렬화에 사용된다면 직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 만들어진다.이를 해결하기 위해 readResolve method를 추가해주어야 한다.123private Object readResolve() &#123; return INSTANCE;&#125; 참고https://stackoverflow.com/questions/1168348/java-serialization-readobject-vs-readresolve","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"2. Objects","slug":"Effective-Java-3rd/2-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/2-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 2","slug":"Effective-Java-3rd-ITEM-2","date":"2019-02-24T07:19:37.000Z","updated":"2021-01-30T08:34:59.128Z","comments":true,"path":"2019/02/24/Effective-Java-3rd-ITEM-2/","link":"","permalink":"https://dlsrb6342.github.io/2019/02/24/Effective-Java-3rd-ITEM-2/","excerpt":"","text":"ITEM 2. If Constructor has many parameters, Use builder.Static factory method나 Constructor들은 매개변수가 많을 경우 대응이 어렵다. 대안1. 점층적 생성자 패턴(Telescoping Constructor Pattern)paramter를 하나씩 하나씩 늘려 Constructor를 여러 개 작성할 수 있겠지만 코드를 작성하거나 읽기 어려워진다. 2. JavaBeans PatternNoArgsConstructor로 생성 후, Setter를 활용해 객체 생성.단점으로는 하나의 객체를 만들때 여러 method를 호출하게 되고 모든 값이 정해지기 전까지는 일관성이 무너진 상태이다.-&gt; 객체를 Immutable한 상태로 만들기 어렵다. -&gt; Thread unsafe 3. Builder PatternTelescoping Constructor의 안전성과 JavaBeans의 가독성을 가진 PatternBuilder의 setter method들은 자기 자신을 반환하기 때문에 연쇄적 호출 가능-&gt; Fluent API / Method Chaining이라 한다. Builder Pattern은 계층적으로 설계된 클래스와 함께 쓰기도 좋다. 책에서는 예시로 Pizza를 보여줬지만 다른 예시를 만들어보았다. 123456789101112131415161718192021public abstract class Coffee &#123; public static enum Size &#123; TALL, GRANDE, VENTI &#125; final Size size; Coffee(Builder&lt;?&gt; builder) &#123; size = builder.size; &#125; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; &#123; Size size; public T size(Size size) &#123; this.size = size; return self(); &#125; abstract Coffee build(); protected abstract T self(); &#125;&#125; 공통된 변수 size를 가지는 Coffee라는 Class이다. Coffee의 하위 클래스에는 Cappucino, HazelnutAmericano가 있다.HazelnutAmericano는 syrup의 양을 필수 매개변수로 받고 Cappucino는 cinnamon을 넣을지 말지를 필수 매개변수로 받는다.1234567891011121314151617181920212223242526public class HazelnutAmericano extends Coffee &#123; private final int syrup; private HazelnutAmericano(Builder builder) &#123; super(builder); syrup = builder.syrup; &#125; public static class Builder extends Coffee.Builder&lt;Builder&gt; &#123; private final int syrup; public Builder(int syrup) &#123; this.syrup = syrup; &#125; @Override public HazelnutAmericano build() &#123; return new HazelnutAmericano(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125;&#125;1234567891011121314151617181920212223242526public class Cappuccino extends Coffee &#123; private final boolean cinnamon; Cappuccino(Builder builder) &#123; super(builder); cinnamon = builder.cinnamon; &#125; public static class Builder extends Coffee.Builder&lt;Builder&gt; &#123; private final boolean cinnamon; public Builder(boolean cinnamon) &#123; this.cinnamon = cinnamon; &#125; @Override public Cappuccino build() &#123; return new Cappuccino(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125;&#125;123456HazelnutAmericano hazelnutAmericano = new HazelnutAmericano.Builder(1) .size(Size.TALL) .build();Cappuccino cappuccino = new Cappuccino.Builder(true) .size(Size.VENTI) .build();위와 같이 계층적으로 빌더를 사용할 수 있다.Builder Pattern의 단점으로는 Builder를 생성해야 하는 비용이 든다는 것이 있다. 참고https://projectlombok.org/features/Builderhttps://projectlombok.org/features/experimental/SuperBuilder","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"2. Objects","slug":"Effective-Java-3rd/2-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/2-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Effective Java 3rd ITEM 1","slug":"Effective-Java-3rd-ITEM-1","date":"2019-02-24T05:52:10.000Z","updated":"2021-01-30T08:34:59.117Z","comments":true,"path":"2019/02/24/Effective-Java-3rd-ITEM-1/","link":"","permalink":"https://dlsrb6342.github.io/2019/02/24/Effective-Java-3rd-ITEM-1/","excerpt":"","text":"ITEM 1. Static Factory method not Constructor.Pros1. 이름을 가질 수 있다.이름으로 반활될 객체의 특성을 제대로 설명할 수 있다.하나의 signaure로는 Constructor는 하나밖에 만들 수 없지만 Static Factory는 이름을 가질 수 있기에 각각의 차이를 나타내는 이름으로 여러 개를 만들 수 있다. method signature - method name + method parameter (return type은 포함되지 않는다.) 2. 호출될 때마다 인스터스를 새로 생성하지는 않아도 된다.123Boolean.valueOf(boolean b) &#123; return b ? Boolean.TRUE : Boolean.FALSE;&#125; 미리 만들어 놓거나 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다.어느 인스턴스를 살아 있게 할지 통제할 수 있다. -&gt; instance-controlled class -&gt; 인스턴스 통제를 통해 Sigleton(ITEM 3), Noninstantiable(ITEM 4)를 만들 수 있다.Flyweight pattern 참고. 3. return 타입의 하위 타입 객체를 반환할 수 있다.반환할 객체의 클래스를 자유롭게 선택할 수 있는 유연성을 제공한다.인터페이스 기반 프레임워크! 인터페이스를 구현한 모든 클래스를 공개하는 것이 아닌 인터페이스만을 공개해 API를 작게 유지할 수 있다. java.util.CollectionsCollection에는 45개의 class가 있지만 Collections의 Static Factory method를 통해 객체를 얻는다. 또 이렇게 얻은 객체를 인터페이스만으로 다루게 된다. 4. parameter에 따라 다른 클래스의 객체를 반환할 수 있다.다른 클래스 - return 타입의 하위 타입만 가능. EnumSet - EnumSet은 Static Factory method로만 인스턴스를 제공하는데 원소 개수에 따라 RegularEnumSet / JumboEnumSet을 return한다.하지만 사용자 입장에서는 어떤 것이 return되었든 알 필요없이 EnumSet의 &gt;하위 클래스이면 문제없이 사용할 수 있다. 5. Static Factory method를 작성하는 시점에 반환할 객체의 클래스가 존재하지 않아도 된다.Serivce Provider Framework의 근본.Service Provider Framework는 Service Interface / Provider Registration API / Service Access API, 3가지 핵심 컴포넌트로 이뤄진다. 이외에도 Service Provider Interface가 있다.클라이언트가 Service Access API를 사용할때 조건을 명시하여 원하는 구현체를 반환받을 수 있다.서비스의 구현체가 Provider의 역할을 하고 이 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제한다. 이로써 클라이언테와 구현체를 분리해준다. JDBC - Connection(Service Interface) / DriverManager.registerDriver(Provider Registration API) / DriverManager.getConnection(Service Access API) / Drivcer(Service Provider Interface) Cons1. 상속 시에 필요한 public / protected 생성자가 없어 하위 클래스를 만들 수 없다.이 제약은 상속보다는 Composition(ITEM 18) / Immutable(IMEM 17)을 사용하도록 유도하여 장점일 수 있다. 2. Static Factory method는 프로그래머가 찾기 어렵다.API 문서를 잘 쓰고 method 이름도 규약에 맞게 작성하는게 좋다.","categories":[{"name":"Effective Java 3rd","slug":"Effective-Java-3rd","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/"},{"name":"2. Objects","slug":"Effective-Java-3rd/2-Objects","permalink":"https://dlsrb6342.github.io/categories/Effective-Java-3rd/2-Objects/"}],"tags":[{"name":"effective_java","slug":"effective-java","permalink":"https://dlsrb6342.github.io/tags/effective-java/"},{"name":"java","slug":"java","permalink":"https://dlsrb6342.github.io/tags/java/"}]},{"title":"Notes on Reactive Programming Part 1","slug":"Notes-on-Reactive-Programming-Part-1","date":"2018-10-09T10:02:53.000Z","updated":"2021-01-30T08:34:59.236Z","comments":true,"path":"2018/10/09/Notes-on-Reactive-Programming-Part-1/","link":"","permalink":"https://dlsrb6342.github.io/2018/10/09/Notes-on-Reactive-Programming-Part-1/","excerpt":"","text":"The Reactive Landscapespring blog를 보고 정리. 2016년 7월 글이다. What is itMicro Architecture에서 routing과 events의 변경 및 소비에 관한 programming style.Reactive Programming의 흐름을 spreadsheet에 비교. 변수 하나를 cell에 대입하고 cell이 변화했을때 그 cell을 참조하는 다른 cell도 변화가 일어남. The basic idea behind reactive programming is that there are certain datatypes that represent a value “over time”. Computations that involve these changing-over-time values will themselves have values that change over time.An easy way of reaching a first intuition about what it’s like is to imagine your program is a spreadsheet and all of your variables are cells. If any of the cells in a spreadsheet change, any cells that refer to that cell change as well. It’s just the same with FRP. Now imagine that some of the cells change on their own (or rather, are taken from the outside world) Reactive use cases (what is it good for?)External Service Calls대부분의 backend는 HTTP를 이용한 RESTful이기 때문에 blocking, synchronous하다.response는 여러 서비스들을 call하면서 그 응답에 따라 값이 변한다. 따라서 External Service Calls을 모아야 하는 상황에서 Reactive Programming으로 optimizing하기 좋다. Highly Concurrent Message Consumersmessage 하나를 event 하나로 바로 대응되기 때문에 Message Processing에는 Reactive Pattern이 어울린다. Reactive Programming in JavaDavid Karnok’s Generations of Reactive classificationReactor는 Reactive Streams을 Pivotal에서 만든 framework이다. Asynchronous sequence API로 Flux(N개)와 Mono(0, 1개)를 제공하고 Java 8 functional APIs로 만들어져있다. Reactor is a fully non-blocking reactive programming foundation for the JVM, with efficient demand management (in the form of managing “backpressure”). It integrates directly with the Java 8 functional APIs, notably CompletableFuture, Stream, and Duration. It offers composable asynchronous sequence APIs Flux (for [N] elements) and Mono (for [0|1] elements), extensively implementing the Reactive Streams specification. Why now? Well, it’s not (all) just a technology fad — people jumping on the bandwagon with the shiny new toys. The driver is efficient resource utilization, or in other words, spending less money on servers and data centres. 참고할만한 링크 spring blog 본문링크 Reactor Reactive Glossary","categories":[{"name":"Spring","slug":"Spring","permalink":"https://dlsrb6342.github.io/categories/Spring/"},{"name":"Reactor","slug":"Spring/Reactor","permalink":"https://dlsrb6342.github.io/categories/Spring/Reactor/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://dlsrb6342.github.io/tags/spring/"},{"name":"reactor","slug":"reactor","permalink":"https://dlsrb6342.github.io/tags/reactor/"}]},{"title":"첫 글","slug":"첫-글","date":"2018-10-07T10:42:01.000Z","updated":"2021-01-30T08:34:59.287Z","comments":true,"path":"2018/10/07/첫-글/","link":"","permalink":"https://dlsrb6342.github.io/2018/10/07/%EC%B2%AB-%EA%B8%80/","excerpt":"","text":"github 블로그 시작!수정 체크..","categories":[{"name":"temp","slug":"temp","permalink":"https://dlsrb6342.github.io/categories/temp/"}],"tags":[]}]}