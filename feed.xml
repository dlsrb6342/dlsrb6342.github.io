<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ododododo</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://dlsrb6342.github.io/"/>
  <updated>2021-02-07T09:38:56.270Z</updated>
  <id>https://dlsrb6342.github.io/</id>
  
  <author>
    <name>Ingyu Hwang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Cloud Stream with Spring Cloud Dataflow</title>
    <link href="https://dlsrb6342.github.io/2021/02/07/Spring-Cloud-Stream-with-Spring-Cloud-Dataflow/"/>
    <id>https://dlsrb6342.github.io/2021/02/07/Spring-Cloud-Stream-with-Spring-Cloud-Dataflow/</id>
    <published>2021-02-07T07:25:32.000Z</published>
    <updated>2021-02-07T09:38:56.270Z</updated>
    
    <content type="html"><![CDATA[<p>최근 회사에서 spring cloud dataflow 상에서 spring cloud stream을 사용하기로 결정해 여러가지 삽질을 한 것을 정리해보려 한다. 굉장히 다양한 삽질을 했으나 몇가지만 정리해보려고 한다.</p><h2 id="Functional-Style"><a href="#Functional-Style" class="headerlink" title="Functional Style"></a>Functional Style</h2><p>spring cloud stream app은 Functional Style, Annotation Based Style 2가지 방식으로 정의할 수 있다.<br><strong>Annotation Based Style로 작성하였을때는 정말 아무 문제없이 처리되었지만.. Functional Style로 바꾸니 바로 동작하지 않았다.</strong></p><ul><li><a href="https://cloud.spring.io/spring-cloud-stream/reference/html/spring-cloud-stream.html#spring_cloud_function">https://cloud.spring.io/spring-cloud-stream/reference/html/spring-cloud-stream.html#spring_cloud_function</a></li><li><a href="https://cloud.spring.io/spring-cloud-stream/reference/html/spring-cloud-stream.html#_annotation_based_support_legacy">https://cloud.spring.io/spring-cloud-stream/reference/html/spring-cloud-stream.html#_annotation_based_support_legacy</a> </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Annotation Based Style</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableBinding(Processor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleStreamApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="meta">@SendTo(Source.OUTPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Functional Style</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleStreamApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Function&lt;String, String&gt; <span class="title">toUpperCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str -&gt; str.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="원인"><a href="#원인" class="headerlink" title="원인"></a>원인</h3><p>원인부터 말하면 Annotation Based Style로 stream app을 작성했을때는 binding의 기본 이름이 <code>input</code>, <code>output</code>으로 정해지지만 Functional Style은 정의한 Function의 이름에 따라 달라진다.  </p><p>이 부분에 대해 부가 설명을 하자면..</p><ul><li>Annotation Based Style에 쓰이는 <code>@StreamListener</code>와 <code>@SendTo</code> annotation에 들어가는 값에 따라 binding의 이름이 정해지는데 보통 <code>Sink.INPUT</code>, <code>Source.OUTPUT</code>을 사용하기 때문에 기본 이름이라 칭했다.</li><li>Functional Style 는 동작하지 않았다라고 한 것은 사실 spring-cloud-dataflow에 올렸을 경우에 동작하지 않는다는 것을 의미한다. spring-cloud-dataflow의 경우, stream app의 input, output binding을 <code>input</code>, <code>output</code>이라는 값으로 정해져있다고 가정하고 app을 구동하기 때문에 이런 경우가 발생하는 것으로 파악했다.</li></ul><h3 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h3><p>해결책은 간단했다. <code>application.yml</code>에 binding의 이름을 정해주면 된다. 위 예시 코드에서는 Function의 이름이 <code>toUpperCase</code>이므로 input binding은 <code>toUpperCase-in-0</code>, output binding은 <code>toUpperCase-out-0</code>으로 생성되었을 것이다. 이걸 <code>input</code>, <code>output</code>으로 바꿔주기만 하면 된다. 나중에 본 것이지만 <a href="https://github.com/spring-cloud/spring-cloud-dataflow-samples">spring-cloud-dataflow-samples</a>에 예시가 잘 되어있었다.. ㅠㅠ<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">application.yml</span></span><br><span class="line"><span class="attr">spring.cloud.stream.function.bindings:</span></span><br><span class="line">  <span class="attr">toUpperCase-in-0:</span> <span class="string">input</span></span><br><span class="line">  <span class="attr">toUpperCase-out-0:</span> <span class="string">output</span></span><br></pre></td></tr></table></figure></p><h2 id="Header-Encoding"><a href="#Header-Encoding" class="headerlink" title="Header Encoding"></a>Header Encoding</h2><p>Stream Sample App 중에 header enricher라는 App이 있다. 입력한 SpEL에 따라 kafka record header에 값을 추가해주는 App인데 이 App을 통해 필요한 값을 헤더에 넣어주곤 했는데 stream definition을 따라 잘 전달되다가 <strong>어느 앱만 지나면 String으로 잘 전달되던 헤더 값이 <code>byte[]</code>로 표현됐다.</strong></p><h3 id="원인-1"><a href="#원인-1" class="headerlink" title="원인"></a>원인</h3><p>Dependencies Version의 문제였다. 내가 사용 중인 Kubernetes Cluster는 1.15.X 버전이기에 spring cloud dataflow는 2.5.3을 설치해서 사용했다. 또 spring cloud dataflow 2.5.3을 사용했기 때문에 spring cloud는 Hoxton.SR4를 사용했다.</p><ul><li><a href="https://dataflow.spring.io/docs/installation/kubernetes/compatibility/">https://dataflow.spring.io/docs/installation/kubernetes/compatibility/</a></li><li><a href="https://github.com/spring-cloud/spring-cloud-dataflow/releases/tag/v2.5.3.RELEASE">https://github.com/spring-cloud/spring-cloud-dataflow/releases/tag/v2.5.3.RELEASE</a></li></ul><p>이렇게 해서 버전을 다 맞춰 문제가 없을 줄 알았으나.. spring cloud dataflow 2.5.3을 설치해서 import 해둔 Sample App들의 버전이 문제였다.<br>내가 만든 Stream App들은 spring cloud Hoxton.SR4에 포함된 spring cloud stream 3.0.4.RELEASE를 사용했지만 미리 import된 Sample App들은 2.1.X 버전을 사용하고 있었다.</p><p>여기서 버전 차이로 인해 <code>BinderHeaderMapper</code>의 구현에 차이가 있었다. 그래서 하위 버전앱에서 추가된 헤더를 상위버전앱에서 제대로 읽지 못하는 이슈가 있는 것 같다.</p><h3 id="해결책-1"><a href="#해결책-1" class="headerlink" title="해결책"></a>해결책</h3><p>해결책으로는 3.0.X Version의 Sample App을 빌드하는 것과 하위 버전 앱을 원하는 버전으로 직접 빌드하는 것, 두가지가 있다. </p><p>Stream Sample App들은 2.1.X와 3.0.X가 다른 레포지토리에 관리되고 있다. 이걸 찾는 것도 힘들었다 ㅠㅠ</p><ul><li>3.0.X : <a href="https://github.com/spring-cloud/stream-applications">https://github.com/spring-cloud/stream-applications</a></li><li>2.1.X : <a href="https://github.com/spring-cloud-stream-app-starters">https://github.com/spring-cloud-stream-app-starters</a></li></ul><p>첫 번째 방법인 3.0.X Version을 사용하려면 <a href="https://github.com/spring-cloud/stream-applications/releases">Release Tag</a>에서 spring-cloud-datflow에 Bulk Import할 수 있는 url / file을 얻을 수 있다. 간단히 Import해서 사용하기만 하면 된다.</p><p>두 번째 방법인 직접 하위 버전 앱을 빌드하는 방법은 아래와 같이 dependencies를 추가하고 Configuration만 import해주면 된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 예시로 aggregator app을 빌드해보겠다.</span><br><span class="line">&#x2F;&#x2F; build.gradle</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#39;org.springframework.cloud.stream.app:spring-cloud-starter-stream-processor-aggregator:2.1.5.RELEASE&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AggregatorApplication.java</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@Import(AggregatorProcessorConfiguration.class)</span><br><span class="line">public class AggregatorApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(AggregatorApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Headers-with-Reactor"><a href="#Headers-with-Reactor" class="headerlink" title="Headers with Reactor"></a>Headers with Reactor</h2><blockquote><p><a href="https://docs.spring.io/spring-cloud-stream/docs/3.1.1/reference/html/spring-cloud-stream.html#_reactive_functions_support">https://docs.spring.io/spring-cloud-stream/docs/3.1.1/reference/html/spring-cloud-stream.html#_reactive_functions_support</a></p></blockquote><p>Stream Application은 Reactor를 사용해서 Reactive Programming model로 작성할 수 있다.<br>이 예시로 위에 말한 sample app 중에 httpclient(http-request)를 살펴보면 2.1.X의 httpclient는 내부에서 RestTemplate bean을 생성해서 요청을 보내고 있고 http-request-processor는 WebClient를 사용하고 있다.  </p><ul><li>2.1.X : <a href="https://github.com/spring-cloud-stream-app-starters/httpclient">https://github.com/spring-cloud-stream-app-starters/httpclient</a></li><li>3.0.X : <a href="https://github.com/spring-cloud/stream-applications/tree/master/applications/processor/http-request-processor">https://github.com/spring-cloud/stream-applications/tree/master/applications/processor/http-request-processor</a></li></ul><p><strong>그런데 reactor를 사용해 Function을 작성했을때 Header가 다음 App으로 전달되지 않았다.</strong></p><h3 id="원인-2"><a href="#원인-2" class="headerlink" title="원인"></a>원인</h3><p>아쉽게도 이 문제는 아직 원인을 파악하지 못했다. 내부의 Message build하는 로직을 많이 들여다봤는데도 Reactor로 되어있다보니 Debugging이 쉽지가 않았다.<br>아마 Message build 과정에서 헤더는 복사되지 않고 build하고 있는 것 같다. 원인을 아시는 분은 제보 부탁드립니다… ㅋㅋ</p><h3 id="해결책-2"><a href="#해결책-2" class="headerlink" title="해결책"></a>해결책</h3><p>원인을 못 찾았기 때문에 해결책이 깔끔하지는 않다. Message Build가 문제되는 것 같으니 직접 Message를 build했다. 이렇게 하면 다음 Stream으로 문제없이 헤더가 잘 전달된다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleStreamApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Flux&lt;Message&lt;String&gt;&gt;, Flux&lt;Message&lt;String&gt;&gt;&gt; reactiveToUpperCase() &#123;</span><br><span class="line">        <span class="keyword">return</span> messageFlux -&gt; messageFlux</span><br><span class="line">                .map(message -&gt; &#123;</span><br><span class="line">                    String payload = message.getPayload();</span><br><span class="line">                    <span class="keyword">return</span> MessageBuilder.createMessage(payload.toUpperCase(), message.getHeaders());</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Stream-App-Test"><a href="#Stream-App-Test" class="headerlink" title="Stream App Test"></a>Stream App Test</h2><p>Stream App은 Kafka 혹은 RabbitMQ를 필요로 한다. <strong>물론 테스트를 위해 TestContainer 혹은 Embedded Kafka 같은 방법을 선택할 수 있지만 여러 제한이 있어 사용하지 못했다. 그래서.. 테스트할 방법을 찾아야만 했다.</strong> 이번 삽질은 딱히 원인/해결책은 없고 Stream App을 테스트하는 방법을 소개하려고 한다. </p><p>Stream Sample Apps에서 사용하고 있는 테스트 방법을 사용했다. Kafka / RabbitMQ가 아닌 spring-cloud-stream의 test 구현체인 TestBinder를 사용하는 방법이다.</p><ul><li><a href="https://github.com/spring-cloud/stream-applications/blob/1e6a2e1f44f12619d4522e97a9f5e5869461cd8f/applications/stream-applications-core/pom.xml#L83-L89">https://github.com/spring-cloud/stream-applications/blob/1e6a2e1f44f12619d4522e97a9f5e5869461cd8f/applications/stream-applications-core/pom.xml#L83-L89</a></li></ul><p>maven에서는 위 링크와 같이 넣어주면 되지만 gradle은 아래와 같이 하면 된다. gradle을 많이 사용해보지 않는 나로서는 이것도 꽤나 찾기 힘들었다 ㅠㅠ<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="attr">group:</span> <span class="string">&#x27;org.springframework.cloud&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;spring-cloud-stream&#x27;</span>, <span class="attr">classifier:</span> <span class="string">&#x27;test-binder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>test-binder를 사용한 <code>toUpperCase</code> App에 대한 간단한 테스트 코드는 아래와 같다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleStreamApplicationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_toUpperCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(</span><br><span class="line">                TestChannelBinderConfiguration.getCompleteConfiguration(SampleStreamApplication.class))</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run()) &#123;</span><br><span class="line"></span><br><span class="line">            InputDestination processorInput = context.getBean(InputDestination.class);</span><br><span class="line">            OutputDestination processorOutput = context.getBean(OutputDestination.class);</span><br><span class="line"></span><br><span class="line">            String testStr = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">            <span class="keyword">final</span> Message&lt;Map&lt;String, String&gt;&gt; message = MessageBuilder.withPayload(testStr)</span><br><span class="line">                                                     .build();</span><br><span class="line"></span><br><span class="line">            processorInput.send(message);</span><br><span class="line">            Message&lt;<span class="keyword">byte</span>[]&gt; output = processorOutput.receive();</span><br><span class="line"></span><br><span class="line">            assertEquals(testStr.toUpperCase, <span class="keyword">new</span> String(output.getPayload()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></p><hr><p><br><br>spring cloud dataflow가 Task / Stream / Batch 를 관리하고 실행할 수 있다는 점에서 굉장히 좋아보여 사용하기로 했는데 생각보다 Reference가 부족해 조금 어려움을 겪었다. 전체적인 개념을 이해하는데에 시간이 오래 걸리긴 했지만 공식문서가 굉장히 잘 되어있어 도움이 됐다. 영어로 되어있더라도 건너뛰지 않아야겠다.<br>앞으로 spring cloud dataflow / spring cloud stream을 더 많이 사용할테니 삽질은 더 많아질 예정이다..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;최근 회사에서 spring cloud dataflow 상에서 spring cloud stream을 사용하기로 결정해 여러가지 삽질을 한 것을 정리해보려 한다. 굉장히 다양한 삽질을 했으나 몇가지만 정리해보려고 한다.&lt;/p&gt;
&lt;h2 id=&quot;Func
      
    
    </summary>
    
      <category term="spring-cloud-stream" scheme="https://dlsrb6342.github.io/categories/spring-cloud-stream/"/>
    
      <category term="spring-cloud-dataflow" scheme="https://dlsrb6342.github.io/categories/spring-cloud-stream/spring-cloud-dataflow/"/>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
      <category term="spring" scheme="https://dlsrb6342.github.io/tags/spring/"/>
    
      <category term="spring-cloud" scheme="https://dlsrb6342.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Gradle Multi Project with Multiple version of plugin</title>
    <link href="https://dlsrb6342.github.io/2021/01/30/Gradle-Multi-Project-with-Multiple-version-of-plugin/"/>
    <id>https://dlsrb6342.github.io/2021/01/30/Gradle-Multi-Project-with-Multiple-version-of-plugin/</id>
    <published>2021-01-30T06:58:19.000Z</published>
    <updated>2021-01-30T08:34:59.227Z</updated>
    
    <content type="html"><![CDATA[<p>gradle에서 spring boot dependencies 버전은 <code>org.springframework.boot</code> plugin으로 관리된다. 그런데 plugin의 경우 rootProject에서 버전을 명시해버리면 하위 프로젝트에서 버전을 변경해서 적용할 수 없다. 이 점 때문에 gradle에서 한가지 plugin을 다양한 버전으로 사용하는 것은 조금 불편하다..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.                             # 전체 프로젝트는 2.4.1</span><br><span class="line">├── build.gradle</span><br><span class="line">├── bar</span><br><span class="line">│   └── build.gradle</span><br><span class="line">├── foo</span><br><span class="line">│   └── build.gradle</span><br><span class="line">└── streams                   # streams 이하 모듈은 2.2.7.RELEASE</span><br><span class="line">    ├── build.gradle</span><br><span class="line">    ├── stream-baz</span><br><span class="line">    │   └── build.gradle</span><br><span class="line">    └── stream-qux</span><br><span class="line">        └── build.gradle</span><br></pre></td></tr></table></figure></p><p>이번 새 프로젝트는 특정 모듈에서만 spring boot 버전이 다르게 사용해야 하는 요구사항이 있었다. 위 프로젝트 구조에서 <code>streams</code> 아래 모듈에서만 2.2.7.RELEASE 버전의 spring boot를 사용해야 했다(나중에 글을 쓸 예정이지만 spring-cloud-dataflow를 사용하면서 어쩔 수 없는 상황이었다 ㅠㅠ). 대충 요구사항을 정리해보자면..</p><ol><li>spring-boot 버전은 <code>streams</code>에서는 2.2.7.RELEASE를, 나머지 모듈에서는 2.4.1을 사용한다.</li><li>Library/Plugin의 버전 관리는 하나의 파일에서 혹은 정리된 형태로 보기 쉽게 한다.  </li></ol><p>이 요구사항을 충족시키기 위해 몇가지 방법을 찾고 적용해봤다.</p><h2 id="1-Plugin-Version-in-classpath"><a href="#1-Plugin-Version-in-classpath" class="headerlink" title="1. Plugin Version in classpath"></a>1. Plugin Version in classpath</h2><p>첫 번째 방법은 classpath로 plugin version을 선언해두는 것이다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libraries.gradle</span></span><br><span class="line">ext.version = [</span><br><span class="line">        <span class="symbol">springBoot:</span> <span class="string">&#x27;2.4.1&#x27;</span>,</span><br><span class="line">        ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">ext.libraries = [</span><br><span class="line">        <span class="symbol">classpath:</span> [</span><br><span class="line">                <span class="symbol">springBootPlugin:</span> <span class="string">&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;ext.version.springBoot&#125;&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="symbol">dependency:</span> [</span><br><span class="line">                ....</span><br><span class="line">        ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">ext.streamsVersion = [</span><br><span class="line">        <span class="symbol">springBoot:</span> <span class="string">&#x27;2.2.7.RELEASE&#x27;</span>,</span><br><span class="line">        ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">ext.streamsLibraries = [</span><br><span class="line">        <span class="symbol">classpath:</span> [</span><br><span class="line">                <span class="symbol">springBootPlugin:</span> <span class="string">&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;ext.streamsVersion.springBoot&#125;&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="symbol">dependency:</span> [</span><br><span class="line">                ...</span><br><span class="line">        ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rootProject build.gradle</span></span><br><span class="line">subprojects &#123;</span><br><span class="line">    apply <span class="attr">from:</span> <span class="string">&quot;$&#123;rootDir&#125;/libraries.gradle&quot;</span></span><br><span class="line"></span><br><span class="line">    buildscript &#123;</span><br><span class="line">        dependencies &#123;</span><br><span class="line">            <span class="keyword">if</span> (project.displayName.contains(<span class="string">&quot;streams&quot;</span>)) &#123;</span><br><span class="line">                classpath <span class="string">&quot;$&#123;project.ext.streamsLibraries.classpath.springBootPlugin&#125;&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                classpath <span class="string">&quot;$&#123;project.ext.libraries.classpath.springBootPlugin&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub module builld.gradle</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;org.springframework.boot&#x27;</span></span><br></pre></td></tr></table></figure><br>이렇게 선언해놓으면 sub module들에서 plugin을 적용하기만 해도 원하는 버전으로 적용시킬 수 있다. </p><h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4><ul><li><code>libraries.gradle</code>에서 모든 버전 및 라이브러리 관리할 수 있다.</li><li>sub module에서는 버전에 대해 신경쓰지 않고 모든 것을 root project가 관리할 수 있다.</li></ul><h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h4><ul><li>plugin 적용 방법이 새로운 형식(<code>plugins &#123; id &#39;ID&#39; &#125;</code>)이 아닌 오래된 형식(<code>apply plugin &#39;ID&#39;</code>)을 사용해야 한다. </li></ul><h4 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h4><p>오래된 형식의 plugin 적용 방법을 사용하고 싶지 않아서 이 방법은 버려졌다. 물론 <code>subproject</code>, <code>allproject</code>에서는 <code>plugins</code>는 사용할 수 없고 <code>apply plugin</code>을 사용해야 한다. (<a href="https://stackoverflow.com/a/32353244/7018283">https://stackoverflow.com/a/32353244/7018283</a>)</p><h2 id="2-pluginManagement"><a href="#2-pluginManagement" class="headerlink" title="2. pluginManagement"></a>2. pluginManagement</h2><blockquote><p><a href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugin_management">https://docs.gradle.org/current/userguide/plugins.html#sec:plugin_management</a></p></blockquote><p>gradle에서 plugin 버전을 관리할 수 있는 방법을 공식적으로 지원한다. 그런데 이 방법은 무조건 <code>setting.gradle</code> 파일의 가장 처음에 작성되거나 <a href="https://docs.gradle.org/current/userguide/init_scripts.html#init_scripts">init scripts</a> 파일에 작성되어야 한다. </p><h4 id="결론-1"><a href="#결론-1" class="headerlink" title="결론"></a>결론</h4><p>하지만 이 방법으로는 내가 원하는 모듈 별로 서로 다른 버전의 plugin을 적용할 수는 없는 것 같다(할 수 있지만 방법을 못 찾은것일수도..). 만약 전체 프로젝트에서 version을 한가지만 사용하고 있다면 공식적으로 지원하는 방법이니 이걸 택했을 것 같다.</p><h2 id="3-gradle-properties에-plugin-버전-선언"><a href="#3-gradle-properties에-plugin-버전-선언" class="headerlink" title="3. gradle.properties에 plugin 버전 선언"></a>3. <code>gradle.properties</code>에 plugin 버전 선언</h2><p>이 방법은 plugin 버전을 <code>libraries.gradle</code>이 아닌 <code>gradle.properties</code>에 선언하는 방법이다. <code>plugins</code> 블록에서 버전을 변수로써 작성하려면 <code>libraries.gradle</code>에 선언한것은 동작하지 않고 <code>gradle.properties</code>에 선언되어 있어야 동작하기 때문이다. </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">//</span> <span class="string">gradle.properties</span></span><br><span class="line"><span class="attr">springBootVersion</span>=<span class="string">2.4.1</span></span><br><span class="line"><span class="attr">springBootVersionForStreams</span>=<span class="string">2.2.7.RELEASE</span></span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo/build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&quot;$&#123;springBootVersion&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// streams/build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&quot;$&#123;springBootVersionForStreams&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="장점-1"><a href="#장점-1" class="headerlink" title="장점"></a>장점</h4><ul><li><code>plugins</code> 블록을 사용하여 plugin을 적용할 수 있다. </li><li>버전 관리를 <code>gradle.properties</code>에서 할 수 있다. </li></ul><h4 id="단점-1"><a href="#단점-1" class="headerlink" title="단점"></a>단점</h4><ul><li>각 모듈에서 plugin을 적용할 때 항상 version을 명시해주어야 한다. </li><li>dependencies 관리는 <code>libraries.gradle</code>, plugin 관리는 <code>gradle.properties</code>로 나뉜다. 사실 이 점은 <code>gradle.properties</code>에 모두 맡겨도 된다.</li></ul><h4 id="결론-2"><a href="#결론-2" class="headerlink" title="결론"></a>결론</h4><p><code>plugins</code> 블록을 사용할 수 있다는 점과 버전 관리를 하나의 파일에서 할 수 있다는 점을 이유로 이 방법을 택했다.<br><br></p><hr><p><br><br>항상 maven만 사용해오다가 gradle을 큰 프로젝트에 사용해본 것은 처음이었는데 maven보다 자유도가 높은 느낌이었다. 그렇다보니 유명한 큰 오픈소스 프로젝트를 봐도 제각기 사용하는 방식이 달랐다. 이런 점이 gradle의 장점이기도 하고 단점이기도 한 것 같다.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://medium.com/@jsuch2362/gradle-dependency-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0-eb0c7c794b9c">https://medium.com/@jsuch2362/gradle-dependency-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0-eb0c7c794b9c</a></li><li><a href="https://gradle.org/">https://gradle.org/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gradle에서 spring boot dependencies 버전은 &lt;code&gt;org.springframework.boot&lt;/code&gt; plugin으로 관리된다. 그런데 plugin의 경우 rootProject에서 버전을 명시해버리면 하위 프로젝
      
    
    </summary>
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/categories/gradle/"/>
    
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Make git-branchcut with Go lang</title>
    <link href="https://dlsrb6342.github.io/2021/01/16/Make-git-branchcut-with-Go-lang/"/>
    <id>https://dlsrb6342.github.io/2021/01/16/Make-git-branchcut-with-Go-lang/</id>
    <published>2021-01-16T07:29:02.000Z</published>
    <updated>2021-01-30T08:34:59.228Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/dlsrb6342/git-branchcut">https://github.com/dlsrb6342/git-branchcut</a></p><p>업무/개인프로젝트/오픈소스 등에서 git을 사용하다 보니 나도 모르는새에 프로젝트마다 브랜치가 엄청 쌓여있었다. 이것들을 한번에 싹 지워버리고 싶었는데 내가 원하는 옵션으로 없앨 수 있는 방법을 찾지 못해 직접 만들었다.</p><p><img src="branches.jpg" alt="로컬에 쌓인 브랜치들.." width="300" /></p><h2 id="Git-Add-On"><a href="#Git-Add-On" class="headerlink" title="Git Add-On"></a>Git Add-On</h2><p>git addon으로 만들어서 <code>git [name] [option]</code> 이런식으로 사용하고 싶었다. 하지만 어떻게 만들고 어떻게 배포해야 할지 막막했기에 <a href="https://github.com/stevemao/awesome-git-addons">awesome-git-addons</a>에서 다른 프로젝트들을 많이 참고했다. </p><blockquote><p>무언가 필요할때 <code>awesome</code>을 붙여 검색하면 친절히 정리해둔 repository가 많이 있다. :)</p></blockquote><h2 id="Go-lang"><a href="#Go-lang" class="headerlink" title="Go lang"></a>Go lang</h2><p>참고했던 프로젝트들은 python, shell script, js, go 등 다양한 언어로 작성되어있었다.<br>이중에 난 예전부터 관심있었던 Go lang을 선택했다 (<a href="https://youtu.be/LJvEIjRBSDA">https://youtu.be/LJvEIjRBSDA</a> 이걸 보고 관심이 생겼다).</p><p>지금 생각해보면 여러 언어 중에 Go lang을 선택한건 굉장히 좋은 선택이었다. 다른 언어들에 대해 많이 알아보지는 않았지만 <a href="https://cobra.dev/">cobra</a>와 <a href="https://goreleaser.com/">goreleaser</a>는 내겐 혁명이었다.</p><h3 id="Cobra"><a href="#Cobra" class="headerlink" title="Cobra"></a>Cobra</h3><blockquote><p><a href="https://cobra.dev/">https://cobra.dev/</a></p></blockquote><p>Cobra는 Go lang의 CLI Framework이다. Subcommand / Flag 등 정말 간단한 작업으로 내가 만들었나 싶을정도로 Modern한 CLI를 만들어준다. </p><p>Kubernetes, Helm, Github CLI 등 굉장히 다양한 프로젝트에서 Cobra 를 사용 중이다. </p><ul><li>Subcommand의 Subcommand, 즉 Nested Subcommand도 지원한다.</li><li>Global / Local / Cascading 등 Flag의 Scope을 지원한다.</li><li>내가 command/flag마다 설명을 넣어둔다면 help를 자동생성해준다.</li></ul><p>예시 코드는 <a href="https://github.com/dlsrb6342/git-branchcut">git-branchcut</a>을 봐도 되고 공식 홈페이지 설명이 자세히 되어있다.   </p><p>내가 해본 CLI App들은 학부생 때 열심히 손으로 직접 만든 C언어 프로그램 밖에 없어서 그런지, Cobra를 써보고 많이 놀랐다. 물론 내가 Cobra를 깊게 사용해보진 않았지만 굉장히 강력한 프레임워크으로 보인다.  </p><p>만약 Go로 CLI를 만든다고 한다면 사용하지 않을 이유가 없는 것 같다.</p><h3 id="Goreleaser"><a href="#Goreleaser" class="headerlink" title="Goreleaser"></a>Goreleaser</h3><blockquote><p><a href="https://goreleaser.com/">https://goreleaser.com/</a></p></blockquote><p>Goreleaser는 Go lang project의 release automation 툴이다. 모든 설정은 <code>.goreleaser.yml</code>에 저장된다. </p><p>설치나 실행방법, 피쳐들은 너무 내용이 많아 다 설명할 수 없으니 Goreleaser 공식 홈페이지를 참고하면 될 것 같다.</p><p>Cobra를 처음 썼을 때와 비슷한 느낌을 받았다. 너무 편하고 쉽다. 처음 <code>git-branchcut</code>을 만들 때 만들기는 하는데 다른 사람들이 사용할 수 있게 어떻게 배포할까 라는 고민을 많이 했다.<br>그 고민들이 무색하게 Goreleaser는 config 몇줄 수정/추가하고 <code>goreleaser</code>만 입력해주면 Release Note, Executable files, Homebrew-tap recipe를 모두 만들어준다. <code>git-branchcut</code>을 사용하고 싶어하는 사람들이 이젠 쉽게 Executable files를 받을 수 있고 혹은 Homebrew를 통해서 설치할 수 있게 된 것이다.</p><h2 id="git-branchcut"><a href="#git-branchcut" class="headerlink" title="git-branchcut"></a>git-branchcut</h2><p>이제 내가 만든 git branchcut에 대해서 설명하려고 한다. 내가 원하는 기능은 딱 2가지였다. </p><ol><li>Outdated branch, 즉 새로운 커밋이 생긴지 오래된 브랜치 삭제.</li><li>Pattern, Branch 이름의 pattern으로 삭제.</li></ol><p>그래서 git branchcut은 일단 두가지 옵션을 제공한다. 지극히 내 요구사항에 의해 만들었으니..ㅎㅎ<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; git branchcut execute --help</span><br><span class="line">Cut branches</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  branchcut execute [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -o, --day-offset int       Day offset. Branches that is committed before day offset would be deleted</span><br><span class="line">      --dry-run              Only print branch list that would be delete, without deleting it.</span><br><span class="line">      --force                Allow deleting the branch irrespective of its merged status.</span><br><span class="line">  -h, --help                 help for execute</span><br><span class="line">  -m, --main-branch string   Default branch name (default &quot;main&quot;)</span><br><span class="line">  -p, --pattern string       Pattern for branch name</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">  -g, --executable-git-path string   The git executable to use (default &quot;git&quot;)</span><br></pre></td></tr></table></figure><br><code>--day-offset</code>으로 며칠 전 커밋된 브랜치를 살릴지 정할 수 있다. 예를 들어 <code>--day-offset 7</code>로 했다면 마지막 커밋이 7일 이내에 있는 브랜치만 살아남는다.<br><code>--pattern</code>으로 브랜치 이름의 Pattern을 지정할 수 있다. <code>--pattern &quot;feature/*&quot;</code>로 설정하면 “feature/“로 시작하는 브랜치들은 삭제된다. </p><p>두가지 옵션 모두 입력하였다면 두 조건을 모두 만족하는 브랜치만 삭제된다.<br><br></p><hr><p><br><br>이 프로젝트를 하면서 Go lang을 처음 사용하였는데 책을 보면서 공부하거나 심도있게 사용한 것은 아니어도 어렵지 않은 언어라는 느낌을 받았다. 나중에 만약 언어의 선택이 자유롭고 새로운 것을 도전하고 싶다면 Go lang을 선택할 것 같다. </p><p>이로써 내 로컬 git project들의 브랜치들은 깨끗하게 정리되었다! </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/dlsrb6342/git-branchcut&quot;&gt;https://github.com/dlsrb6342/git-branchcut&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;업무/개인프로젝트/오픈소스 등에서 git을 사용하다 보
      
    
    </summary>
    
      <category term="go" scheme="https://dlsrb6342.github.io/categories/go/"/>
    
      <category term="git" scheme="https://dlsrb6342.github.io/categories/go/git/"/>
    
    
      <category term="go" scheme="https://dlsrb6342.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Resilience4j RateLimiter</title>
    <link href="https://dlsrb6342.github.io/2019/12/12/Resilience4j-RateLimiter/"/>
    <id>https://dlsrb6342.github.io/2019/12/12/Resilience4j-RateLimiter/</id>
    <published>2019-12-11T15:43:22.000Z</published>
    <updated>2021-01-30T08:34:59.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Resilience4j-RateLimiter"><a href="#Resilience4j-RateLimiter" class="headerlink" title="Resilience4j RateLimiter"></a>Resilience4j RateLimiter</h1><p>RateLimiter 패턴이란 일정 시간동안의 요청의 수를 제한하는 것이다. 자세한 내용은 생략한다. <a href="https://en.wikipedia.org/wiki/Token_bucket">Token Bucket wiki</a>와 <a href="https://github.com/bbeck/token-bucket">Java token-bucket 구현체</a>를 보면 도움이 될 것이다.</p><h2 id="AtomicRateLimiter"><a href="#AtomicRateLimiter" class="headerlink" title="AtomicRateLimiter"></a>AtomicRateLimiter</h2><p>resilience4j의 RateLimiter는 AtomicRateLimiter와 SemaphoreRateLimiter 2가지로 구현되어있는데 default로 AtomicRateLimiter를 사용한다. AtomicRateLimiter는 RateLimiter가 생성된 시점부터의 모든 nanosecond를 cycle로 나눈다. </p><h3 id="Cycle"><a href="#Cycle" class="headerlink" title="Cycle"></a>Cycle</h3><p>Cycle은 RateLimiterConfig.limitRefreshPeriod 값만큼의 Duration을 가진다. RateLimiter는 각 Cycle이 시작할때마다 active permission의 수를 RateLimiterConfig.limitForPeriod 값으로 설정해준다.<br>호출하는 입장에서 바라봤을 때는 매 Cycle마다 active permission을 바꿔주는 것으로 보이겠지만 resilience4j의 AtomicRateLimiter는 RateLimiter를 사용하지 않는동안에는 refresh를 skip하는 성능 최적화가 되어있다.</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>AtomicRateLimiter는 내부에서 State 값을 AtomicReference로 관리하고 있다. State는 immutable한 객체이며 아래와 같은 값들을 갖는다.</p><ul><li>activeCycle : 가장 최근 호출에서 사용된 cycle number.</li><li>activePermissions : 현재 사용할 수 있는 permission의 수. 만약 reserve된 호출이 있다면 음수 값을 가질 수 있다.</li><li>nanosToWait : 최근 호출이 permission을 얻기 위해 기다려야 할 nanoseconds.</li></ul><h2 id="RateLimiterConfig"><a href="#RateLimiterConfig" class="headerlink" title="RateLimiterConfig"></a>RateLimiterConfig</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RateLimiterConfig.custom()</span><br><span class="line">                 .timeoutDuration(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">                 .limitRefreshPeriod(Duration.ofSeconds(<span class="number">2</span>))</span><br><span class="line">                 .limitForPeriod(<span class="number">100</span>)</span><br><span class="line">                 .writableStackTraceEnabled(<span class="keyword">true</span>)</span><br><span class="line">                 .build();</span><br></pre></td></tr></table></figure><p>RateLimiterConfig에는 timeoutDuration, limitRefreshPeriod, limitForPeriod, writableStackTraceEnabled이 있다.</p><ul><li>timeoutDuration : permission을 얻기 위해 thread가 기다릴 시간.</li><li>limitRefreshPeriod : limit가 refresh되는 period. </li><li>limitForPeriod : period마다 허용되는 permission의 수.</li><li>writableStackTraceEnabled : 호출이 permission을 얻지 못해 CallNotPermittedException이 발생했을때 Stack Trace를 출력할지 정하는 boolean 값.</li></ul><p>위의 예시에서는 2초동안 100개의 요청만 허용하면서 만약 permission이 부족할 경우, 1초 간은 기다리게 되는 설정이다. 또 CallNotPermittedException이 발생하면 Stack Trace까지 출력하게 된다.</p><h2 id="Weight-in-RateLimiter"><a href="#Weight-in-RateLimiter" class="headerlink" title="Weight in RateLimiter"></a>Weight in RateLimiter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter rateLimiter = RateLimiter.ofDefaults(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">rateLimiter.executeRunnable(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>현재 공식 문서에는 추가되어있지는 않지만 1.2.0 버전부터는 RateLimiter의 permission을 얻을 때, weight를 넣어서 호출할 수 있다. 위 예시에서 실행하고자 하는 Runnable Lambda 표현식은 permission 3개를 필요로 하게 된다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://resilience4j.readme.io/docs/ratelimiter">https://resilience4j.readme.io/docs/ratelimiter</a></li><li><a href="https://github.com/resilience4j/resilience4j">https://github.com/resilience4j/resilience4j</a></li><li><a href="https://en.wikipedia.org/wiki/Token_bucket">https://en.wikipedia.org/wiki/Token_bucket</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Resilience4j-RateLimiter&quot;&gt;&lt;a href=&quot;#Resilience4j-RateLimiter&quot; class=&quot;headerlink&quot; title=&quot;Resilience4j RateLimiter&quot;&gt;&lt;/a&gt;Resilience4j R
      
    
    </summary>
    
      <category term="resilience4j" scheme="https://dlsrb6342.github.io/categories/resilience4j/"/>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
      <category term="resilience4j" scheme="https://dlsrb6342.github.io/tags/resilience4j/"/>
    
  </entry>
  
  <entry>
    <title>Resilience4j CircuitBreaker</title>
    <link href="https://dlsrb6342.github.io/2019/12/09/Resilience4j-CircuitBreaker/"/>
    <id>https://dlsrb6342.github.io/2019/12/09/Resilience4j-CircuitBreaker/</id>
    <published>2019-12-09T14:11:48.000Z</published>
    <updated>2021-01-30T08:34:59.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Resilience4j-CircuitBreaker"><a href="#Resilience4j-CircuitBreaker" class="headerlink" title="Resilience4j CircuitBreaker"></a>Resilience4j CircuitBreaker</h1><p>resilience4j의 CircuitBreaker는 3개의 정상적인 state (CLOSED / OPEN / HALF_OPEN) 과 2개의 예외 state (DISABLED / FORCED_OPEN) 으로 구성된 finite state machine으로 구현되어있다.</p><h2 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h2><p>호출의 결과를 Store / Aggregation하기 위해 Sliding Window 를 사용하고 있고 Count Based 와 Time Based, 2 가지 종류가 있다. default로는 Count Based를 사용하고 있다.</p><h3 id="Count-Based-Sliding-Window"><a href="#Count-Based-Sliding-Window" class="headerlink" title="Count Based Sliding Window"></a>Count Based Sliding Window</h3><blockquote><p><a href="https://github.com/resilience4j/resilience4j/blob/master/resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/FixedSizeSlidingWindowMetrics.java">FixedSizeSlidingWindowMetrics.java</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count Based</span></span><br><span class="line">CircuitBreakerConfig.custom()</span><br><span class="line">                    .slidingWindowType(SlidingWindowType.COUNT_BASED)</span><br><span class="line">                    .slidingWindowSize(N)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>Count Based Sliding Window는 N개의 요청을 저장하고 aggregation해서 Circuit의 상태를 판단한다. N개의 Measurements를 가지고 있고 요청이 올때마다 가장 오래된 Measurement를 Total Aggregation에서 빼고 초기화한다.<br>요청이 있을 때마다 Total Aggregation을 업데이트하기 때문에 Circuit의 Snapshot을 얻는 것은 O(1)의 시간이 걸리고, Circuit을 위해 필요한 메모리는 N개의 Measurements를 가지기 때문에 O(N)이다.</p><h3 id="Time-Based-Sliding-Window"><a href="#Time-Based-Sliding-Window" class="headerlink" title="Time Based Sliding Window"></a>Time Based Sliding Window</h3><blockquote><p><a href="https://github.com/resilience4j/resilience4j/blob/master/resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/SlidingTimeWindowMetrics.java">SlidingTimeWindowMetrics.java</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Time Based</span></span><br><span class="line">CircuitBreakerConfig.custom()</span><br><span class="line">                    .slidingWindowType(SlidingWindowType.TIME_BASED)</span><br><span class="line">                    .slidingWindowSize(N)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>Time Based Sliding Window는 N개의 Partial Aggregation Circular Array로 구현되어있다. N초 동안의 요청을 저장하고 aggregation해서 Circuit의 상태를 판단한다. Partial Aggregation은 Bucket이라고 생각하면 되는데, 1초동안에 발생한 요청들에 대해 Aggregation해서 저장하고 있는 bucket이다.<br>요청의 결과를 각각 저장하는 것이 아닌 Partial Aggregation과 Total Aggregation에 저장한다. 시간이 지나 필요없어진 Partial Aggregation은 Total Aggregation에서 빼고 초기상태로 reset 된다.<br>Time Based Sliding Window도 Total Aggregation을 요청마다 업데이트하기 때문에 Circuit의 Snapshot을 얻는 것은 O(1)의 시간이 걸린다. 필요한 메모리는 N개의 Partial Aggregation과 1개의 Total Aggregation을 가지기 때문에 O(N) 이다.</p><h2 id="Threshold-for-Open-State"><a href="#Threshold-for-Open-State" class="headerlink" title="Threshold for Open State"></a>Threshold for Open State</h2><p>resilience4j에서는 CircuitBreakerStateMachine가 OPEN State로 전이되기 위한 threshold를 2가지 제공한다. 요청이 Exception을 던지고 실패한 비율에 대한 Failure Rate Threshold, 지정한 Duration보다 오래 걸린 요청의 비율에 대한 Slow Call Rate Threshold가 있다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Minimum Number of Calls</span></span><br><span class="line">CircuitBreakerConfig.custom()</span><br><span class="line">                    .minimumNumberOfCalls(<span class="number">10</span>)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><br>Failure Rate와 Slow Call Rate 모두 minimum number of calls보다 많은 요청이 있을 때부터 계산하기 시작한다. minimum number of calls보다 적은 요청만 들어왔다면 CircuitBreakerStateMachine은 OPEN 상태로 전이되지 않는다.<br>minimumNumberOfCalls를 지정할 때 주의할 점이 있다. 만약 COUNT_BASED Sliding Window를 사용하면서 Window Size를 minimumNumberOfCalls보다 작게 지정했다면 Window Size의 값이 minimumNumberOfCalls 값으로 사용된다.</p><h3 id="Failure-Rate-Threshold"><a href="#Failure-Rate-Threshold" class="headerlink" title="Failure Rate Threshold"></a>Failure Rate Threshold</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Failure Rate Config</span></span><br><span class="line">CircuitBreakerConfig.custom()</span><br><span class="line">                    .failureRateThreshold(<span class="number">80</span>)</span><br><span class="line">                    .recordExceptions(Exception.class)</span><br><span class="line">                    .ignoreExceptions(IllegalArgumentException.class)</span><br><span class="line">                    .recordException(throwable -&gt; throwable <span class="keyword">instanceof</span> Exception)</span><br><span class="line">                    .ignoreException(throwable -&gt; throwable <span class="keyword">instanceof</span> IllegalArgumentException)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>말그대로 실패한 요청에 대한 threshold이다. 기본값은 50이고 Failure Rate가 전체 요청의 50%를 넘게 되면 CircuitBreakerStateMachine의 State가 CLOSED에서 OPEN으로 전이된다.<br>기본으로는 모든 Exception이 Failure로 기록되지만 여러 가지 config 값을 넣어줄 수 있다. </p><ul><li>recordExceptions : 실패로 기록할 Exception list를 넣어줄 수 있다. 이 list에 속한 Exception은 ignoreExceptions에 포함되지 않는다면 모두 Failure로 기록된다.</li><li>ignoreExceptions : 실패나 성공으로 기록하지 않을 Exception list를 넣어줄 수 있다. 이 list에 속한 Exception은 Success도 아니고 Failure도 아닌 요청이 된다.</li><li>recordException : 실패로 기록할 Exception을 판단하는 <code>Predicate&lt;Throwable&gt;</code>을 설정할 수 있다.</li><li>ignoreException : 무시하고 넘어갈 Exception을 판단하는 <code>Predicate&lt;Throwable&gt;</code>을 설정할 수 있다.</li></ul><h3 id="Slow-Call-Rate-Threshold"><a href="#Slow-Call-Rate-Threshold" class="headerlink" title="Slow Call Rate Threshold"></a>Slow Call Rate Threshold</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Slow Call Rate Config</span></span><br><span class="line">CircuitBreakerConfig.custom()</span><br><span class="line">                    .slowCallDurationThreshold(Duration.ofSeconds(<span class="number">3</span>))</span><br><span class="line">                    .slowCallRateThreshold(<span class="number">80</span>)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>Slow Call에 대한 threshold 이다. slow call duration threshold를 설정할 수 있고 이 값보다 더 오래 걸린 요청에 대해서는 slow call로 기록하게 된다. 이렇게 기록된 slow call이 전체 요청에서 slow call rate threshold보다 높게 되면 CircuitBreakerStateMachine의 State가 OPEN으로 전이된다.<br>기본값으로는 slowCallDurationThreshold는 60초, slowCallRateThreshold는 100%로 되어있다. 그렇기 때문에 따로 설정을 넣어주지 않는다면 slow call에 의한 OPEN State 전이는 Disable된 것이나 마찬가지이다.</p><h2 id="CircuitBreaker-State"><a href="#CircuitBreaker-State" class="headerlink" title="CircuitBreaker State"></a>CircuitBreaker State</h2><p>CircuitBreaker의 State는 AtomicReference에 저장된다. 또 State를 update할 때, atomic operation을 사용하고 Sliding Window에 요청을 기록하거나 SnapShot을 읽는 작업들이 모두 synchronized되어있기 때문에 CircuitBreaker는 thread safe하다. </p><h3 id="Half-Open-State"><a href="#Half-Open-State" class="headerlink" title="Half Open State"></a>Half Open State</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Permitted Calls in Half Open State</span></span><br><span class="line">CircuitBreakerConfig.custom()</span><br><span class="line">                    .permittedNumberOfCallsInHalfOpenState(<span class="number">80</span>)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>resilience4j의 CircuitBreaker는 HALF_OPEN state일 때, 다시 CLOSED나 OPEN으로 전이하기 위한 테스트 요청의 수를 정할 수 있다. CLOSED state의 Sliding Window는 TIME_BASED와 COUNT_BASED 2가지 종류를 지원하는 것과는 달리 HALF_OPEN state의 Sliding Window는 COUNT_BASED 만 지원하고 있다.<br>permittedNumberOfCallsInHalfOpenState 값으로 HALF_OPEN state의 Sliding Window의 size를 지정할 수 있다. CLOSED state와 마찬가지로 minimumNumberOfCalls 값에 영향을 받으며 이때도 Window Size가 minimumNumberOfCalls보다 작으면 Window Size의 값을 minimumNumberOfCalls 값으로 사용한다.</p><h3 id="Disabled-and-Forced-Open-State"><a href="#Disabled-and-Forced-Open-State" class="headerlink" title="Disabled and Forced Open State"></a>Disabled and Forced Open State</h3><p>DISABLED State는 모든 요청을 허용하는 상태이고 FORCED_OPEN은 모든 요청을 거부하는 상태이다. 이 두 상태 모두 아무런 CircuitBreaker Event를 발생시키지 않고, metrics 또한 기록하지 않는다. 또 DISABLED나 FORCED_OPEN state에서 다른 state로 전이되는 방법은 직접 상태 전이를 trigger하거나 CircuitBreaker를 reset해야 한다.</p><h2 id="Other-Configs"><a href="#Other-Configs" class="headerlink" title="Other Configs"></a>Other Configs</h2><p>이외에도 writableStackTraceEnabled, automaticTransitionFromOpenToHalfOpenEnabled, waitIntervalFunctionInOpenState 등의 설정이 있다. </p><ul><li>writableStackTraceEnabled : Circuit Open으로 인해 CallNotPermittedException이 발생했을때 Stack Trace를 출력할지 정하는 boolean 값이다.</li><li>waitIntervalFunctionInOpenState : 고정된 wait duration이 아닌 Circuit open 후에 CLOSED State로의 전이를 위해 시도한 횟수로 wait duration을 설정해주는 Function을 넣어줄 수 있다.</li><li>automaticTransitionFromOpenToHalfOpenEnabled : OPEN State에서 HALF_OPEN State로의 전이는 이 설정이 false일 경우, 다음 요청이 들어왔을 때 전이된다. 하지만 이 설정이 true라면 waitDurationInOpenState 시간 이후에 바로 HALF_OPEN State로 전이된다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://resilience4j.readme.io/docs/circuitbreaker">https://resilience4j.readme.io/docs/circuitbreaker</a></li><li><a href="https://github.com/resilience4j/resilience4j">https://github.com/resilience4j/resilience4j</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Resilience4j-CircuitBreaker&quot;&gt;&lt;a href=&quot;#Resilience4j-CircuitBreaker&quot; class=&quot;headerlink&quot; title=&quot;Resilience4j CircuitBreaker&quot;&gt;&lt;/a&gt;Resil
      
    
    </summary>
    
      <category term="resilience4j" scheme="https://dlsrb6342.github.io/categories/resilience4j/"/>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
      <category term="resilience4j" scheme="https://dlsrb6342.github.io/tags/resilience4j/"/>
    
  </entry>
  
  <entry>
    <title>Resilience4j Contribution (오픈소스 Contribution의 시작)</title>
    <link href="https://dlsrb6342.github.io/2019/12/09/Resilience4j-Contribution/"/>
    <id>https://dlsrb6342.github.io/2019/12/09/Resilience4j-Contribution/</id>
    <published>2019-12-08T16:15:28.000Z</published>
    <updated>2021-01-30T08:34:59.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Resilience4j-Contribution"><a href="#Resilience4j-Contribution" class="headerlink" title="Resilience4j Contribution"></a>Resilience4j Contribution</h1><p>resilience4j를 처음 알게 되고 사용한 지 6~7개월 정도 지났다. 그 당시 새로 진행하고 있던 프로젝트에 적용할 CircuitBreaker 구현체를 찾고 있었고 지난 프로젝트에 사용한 Hystrix가 maintenance 모드에 들어갔기에 resilience4j를 사용했다. Hystrix와의 차이점은 지난 <a href="https://dlsrb6342.github.io/2019/06/03/Resilience4j%EB%9E%80/#Netflix-Hystrix%EC%99%80-%EB%8B%A4%EB%A5%B8%EC%A0%90">포스트</a>에 작성해두었다. 그리고 7개월이 지난 지금은 resilience4j의 maintainer로 활동 중이다.</p><h2 id="시작"><a href="#시작" class="headerlink" title="시작."></a>시작.</h2><p>resilience4j에 처음으로 한 contribution은 오타 수정이다. resilience4j를 사용해보기 위해 guide나 javadoc을 꼼꼼하게 다 읽어보았고, 그러다 보니 보이는 오타들이 있었다. 이슈를 남기기보다는 간단한 문서 수정이기에 바로 PR을 올렸었다.</p><ul><li><a href="https://github.com/resilience4j/resilience4j/pull/482">https://github.com/resilience4j/resilience4j/pull/482</a></li><li><a href="https://github.com/resilience4j/resilience4j/pull/535">https://github.com/resilience4j/resilience4j/pull/535</a></li></ul><p>작은 수정들이었지만 내가 Open Source Contribution에 흥미를 갖게 해주는 계기가 되었다. 이후에는 resilience4j에 올라오는 이슈들을 하나하나 다 읽어보고 혹시나 내가 기여할 수 있는 부분이 있는지 찾아보았다. 이 시기에 진행하고 있던 프로젝트에 resilience4j를 사용하고 있었으므로 사용 중에 불편했던 점이 생기기도 했고 여러 트러블 슈팅 경험도 생겨서 이슈에 코멘트를 달아주고 해결 방법에 대해 대화를 나누는 일들이 많아졌다.</p><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud."></a>Spring Cloud.</h2><p>진행 중인 프로젝트가 spring-cloud의 library들을 많이 사용했었다. 이전 포스트들을 보면 알겠지만 spring-cloud-gateway / spring-cloud-sleuth / spring-cloud-config 등에 대한 글을 몇 개 작성했었고 spring-cloud-gateway에는 여러 커밋을 하기도 했다. 이 시기에 참 열심히 살았던 것 같다. 퇴근해서는 오픈 소스만 쳐다봤고 contribution 자체가 재밌었다.</p><img src="/2019/12/09/Resilience4j-Contribution/spring-cloud-gateway.png" class="" title="spring-cloud-gateway contribution"><p>spring-cloud 이야기를 꺼낸 이유는 resilience4j에 첫 소스 코드에 대한 커밋은 spring-cloud 덕분이었기 때문이다. 이 당시(2019.06)에는 spring-cloud-circuitbreaker가 아직 incubating 중이었기 때문에 resilience4j를 spring-cloud와 사용하기에 불편함이 있었다. 이에 대해 똑같은 생각을 했던 사람이 이슈를 남겼고 코멘트로 트러블 슈팅을 했던 경험을 공유했다.</p><ul><li><a href="https://github.com/resilience4j/resilience4j/issues/546">https://github.com/resilience4j/resilience4j/issues/546</a></li></ul><p>이에 resilience4j maintainer가 PR을 해줄 수 있냐고 물었고 난 정말 기쁜 마음으로 코드를 짜고 컨트리뷰팅을 했다. 이 이슈에 대한 <a href="https://github.com/resilience4j/resilience4j/pull/550">PR</a>은 7월 말에 처음 open 하였고 9월초에 머지되었다. 한 달이 넘는 기간, 46개의 코멘트를 주고받으며 리뷰를 받고 머지될 수 있었다. 중간중간 다른 이슈들에 대해서도 PR을 보냈고 여러 PR들이 머지되었다.</p><h2 id="초대"><a href="#초대" class="headerlink" title="초대."></a>초대.</h2><p>여러 가지 이슈도 만들고 PR을 보내가며 커밋을 6개 정도 쌓아 갔을 때쯤, resilience4j maintainer로부터 slack에 초대를 받았다. resilience4j maintaining을 위한 채널이었다.</p><ul><li><a href="https://github.com/resilience4j/resilience4j/pull/606#issuecomment-530386425">https://github.com/resilience4j/resilience4j/pull/606#issuecomment-530386425</a></li></ul><p>resilience4j maintainer로써 활동하게 된 것이다. 이 초대를 받고 resilience4j의 member가 된 것이 9월 중순이었으니 resilience4j에 관심을 갖고 여러 contribution을 한 지 3개월 만에 member가 될 수 있었다.</p><img src="/2019/12/09/Resilience4j-Contribution/contribution.png" class="" title="Resilience4j Contribution"><h2 id="이후"><a href="#이후" class="headerlink" title="이후."></a>이후.</h2><p>resilience4j의 member가 되고 난 이후에는, 사실 commit은 많이 하지 못했다. 약간의 번아웃이 오기도 했고 여러 가지 개인 사정으로 인해 많은 시간을 쏟지 못했다. commit은 못했지만 그 대신 issue에 대해 답변을 준다거나 PR을 리뷰해주는 등 resilience4j가 더 성숙해지고 커질 수 있도록 노력했다. 6월 v0.16.0이던 프로젝트가 이젠 v1.2.0을 달고 릴리즈 되었고 spring-cloud-circuitbreaker에서 다른 CircuitBreaker 구현체들은 제외하고 resilience4j만을 지원하는 등, 정말 많은 성장을 한 것 같다. 처음 resilience4j를 만나고 간단한 <a href="https://dlsrb6342.github.io/2019/06/03/Resilience4j%EB%9E%80/">포스트</a>를 작성했었는데 이제는 많은 설정들이 달라졌고 추가되었다. 이 부분에 대해서는 이어질 포스트들에서 다뤄볼 예정이고 앞으로의 버전 릴리즈 시에도 변경사항에 대한 포스트를 작성해볼 생각이다.</p><h2 id="Open-Source-Contributing"><a href="#Open-Source-Contributing" class="headerlink" title="Open Source Contributing."></a>Open Source Contributing.</h2><p>나에게는 굉장히 신선한 경험이었다. spring-cloud-gateway에서 받은 PR 리뷰도 그렇고 resilience4j에서 받은 리뷰 모두 내가 생각하지 못했던 부분에 대한 리뷰를 받을 수 있었다. 라이브러리 개발자가 아닌 서비스 개발자로서 개발해왔기 때문에 내가 만든 코드를 사용하는 유저들에 대한 생각을 하지 못했다. 이런 내가 고려하지 못했던, 놓쳤던 부분들에 대한 리뷰들이 나를 더욱 Open Source Contribution에 빠져들게 했고 한층 더 성장시켜주었다. 직장에 다니고 대학 시절과는 다르게 개발이 일이 되면서 흥미나 의욕을 조금씩 잃어가는 느낌이 있었는데 Open Source Contribution을 하면서 대학 시절보다도 더 의욕이 넘치게 된 것 같다.<br>Open Source Contribution를 처음 시작하려고 하는 분들에게는 쉽게 생각하자고 말씀드리고 싶다. 나도 처음엔 얼굴에 철판을 깔았는지 이슈를 올리고 아무 PR이나 보내고 이슈에 코멘트를 달고 많이 나대고 다녔었다. 그러다 보니 contribution 자체가 어렵지 않게 느껴졌고 편하고 쉽게 생각할 수 있게 되었다. 또 시작하려고 할 때 뭐부터 해야 하지 라고 생각이 들 때는 문서를 꼼꼼하게 읽고 파악하는 것과 조금이라도 직접 사용해보는 것이 중요해 보인다. 그래야 PR도 자신 있게 올릴 수 있고 문제점이 눈에 들어오기도 하는 것 같다. 더 많은 사람들이 오픈 소스를 그저 사용해보는 것만이 아닌 여러 가지 방법으로 기여하면서 나와 비슷한 경험들을 했으면 좋겠다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Resilience4j-Contribution&quot;&gt;&lt;a href=&quot;#Resilience4j-Contribution&quot; class=&quot;headerlink&quot; title=&quot;Resilience4j Contribution&quot;&gt;&lt;/a&gt;Resilience4
      
    
    </summary>
    
      <category term="resilience4j" scheme="https://dlsrb6342.github.io/categories/resilience4j/"/>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
      <category term="resilience4j" scheme="https://dlsrb6342.github.io/tags/resilience4j/"/>
    
  </entry>
  
  <entry>
    <title>Reactor-Tools 사용해보기</title>
    <link href="https://dlsrb6342.github.io/2019/11/23/Reactor-Tools-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/"/>
    <id>https://dlsrb6342.github.io/2019/11/23/Reactor-Tools-사용해보기/</id>
    <published>2019-11-23T03:57:51.000Z</published>
    <updated>2021-01-30T08:34:59.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A set of tools to improve Project Reactor’s debugging and development experience.</p></blockquote><p>reactor-tools란 Reactor 라이브러리를 사용했을 때, 디버깅과 개발을 용이하게 해주기 위한 툴이다. 얼마 전까지는 reactor-core가 아닌 <a href="https://github.com/reactor/reactor-tools">별도의 프로젝트</a>로 관리되었으나 reactor-core 3.3.0 버전에 맞춰서 reactor-core에 migration 되었고 3.3.0.RELEASE에서 릴리즈되었다.</p><p>spring-boot에서 reactor-tools를 사용하려면 spring-boot 버전을 2.2.0 이상으로 올려줘야 한다. 예시 코드에서는 spring-boot 2.2.1을 사용하였다. 예시 코드는 <a href="https://github.com/dlsrb6342/blog-sample/tree/master/reactor-tools-demo">https://github.com/dlsrb6342/blog-sample/tree/master/reactor-tools-demo</a> 에 올라가 있다.</p><p>reactor-tools를 활성화하는 방법은 아주 간단하다. SpringApplication이 실행되기 전에 init 해주기만 하면 된다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactorToolsDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReactorDebugAgent.init();</span><br><span class="line">        SpringApplication.run(ReactorToolsDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>ReactorDebugAgent</code>는 Call Site Info를 넣어주는 java agent이다. Runtime Cost없이 실행되기 때문에 Production에서도 사용 가능하다고 하다. reactor의 call chain을 bytecode 레벨에서 아래와 같이 바꿔준다고 한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># FROM</span><br><span class="line">Flux.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    .single();</span><br><span class="line"></span><br><span class="line"># TO</span><br><span class="line">Flux flux = Flux.range(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">flux = Hooks.addCallSiteInfo(flux, <span class="string">&quot;Flux.range\n foo.Bar.baz(Bar.java:21)&quot;</span>));</span><br><span class="line">flux = flux.single();</span><br><span class="line">flux = Hooks.addCallSiteInfo(flux, <span class="string">&quot;Flux.single\n foo.Bar.baz(Bar.java:22)&quot;</span>));</span><br></pre></td></tr></table></figure><br><code>ReactorDebugAgent</code>를 init 해주고 나서 Exception을 발생시키면 아래와 같이 call chain을 확인해볼 수 있다. 확실히 어디서 어떤 call이 이어지면서 Exception이 발생했는지 한눈에 알 수 있었다. 물론 call chain info 밑에 Stack Trace도 출력된다. </p><img src="/2019/11/23/Reactor-Tools-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/callChainInfo.png" class="" title="call chain info"><p>Reactive Programming의 단점 중 하나인 Debugging이 어려운 점을 reactor-tools가 해결해줄 것으로 보인다. 또 조금만 더 기다리면 IntelliJ 2019.3에서는 Reactor에 대한 지원을 강화한다고 한다. 관련된 내용은 <a href="https://blog.jetbrains.com/idea/2019/10/whats-new-in-intellij-idea-2019-3-eap6-improved-reactor-support-and-a-huge-pack-of-fixes/">여기</a>에서 확인해볼 수 있다. </p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://spring.io/blog/2019/03/28/reactor-debugging-experience">https://spring.io/blog/2019/03/28/reactor-debugging-experience</a></li><li><a href="https://github.com/reactor/reactor-core/tree/master/reactor-tools">https://github.com/reactor/reactor-core/tree/master/reactor-tools</a></li><li><a href="https://blog.jetbrains.com/idea/2019/10/whats-new-in-intellij-idea-2019-3-eap6-improved-reactor-support-and-a-huge-pack-of-fixes/">https://blog.jetbrains.com/idea/2019/10/whats-new-in-intellij-idea-2019-3-eap6-improved-reactor-support-and-a-huge-pack-of-fixes/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;A set of tools to improve Project Reactor’s debugging and development experience.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;reactor-tools란 Reacto
      
    
    </summary>
    
      <category term="spring-webflux" scheme="https://dlsrb6342.github.io/categories/spring-webflux/"/>
    
      <category term="reactor" scheme="https://dlsrb6342.github.io/categories/spring-webflux/reactor/"/>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
      <category term="spring" scheme="https://dlsrb6342.github.io/tags/spring/"/>
    
      <category term="reactor" scheme="https://dlsrb6342.github.io/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>jib-gradle-plugin으로 spring-boot application을 Docker에 배포하기</title>
    <link href="https://dlsrb6342.github.io/2019/07/26/jib-gradle-plugin%EC%9C%BC%EB%A1%9C-spring-boot-application%EC%9D%84-Docker%EC%97%90-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/"/>
    <id>https://dlsrb6342.github.io/2019/07/26/jib-gradle-plugin으로-spring-boot-application을-Docker에-배포하기/</id>
    <published>2019-07-26T07:39:46.000Z</published>
    <updated>2021-01-30T08:34:59.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Build container images for your Java applications.<br><a href="https://github.com/GoogleContainerTools/jib">https://github.com/GoogleContainerTools/jib</a></p></blockquote><p>spring boot application을 Docker에 배포해보기 위해 검색했을 때 가장 먼저 뜨는 링크는 spring.io에 실려있는 <a href="https://spring.io/guides/gs/spring-boot-docker/">게시글</a>이다. 이 게시글에서는 <a href="https://github.com/palantir/gradle-docker">com.palantir.docker plugin</a>을 사용하고 Dockerfile을 작성하여 image build를 해주고 있다. 물론 착착 잘 되는 사람도 있었겠지만 내가 하는 환경에서는 잘 되지 않았다. Mac에서는 docker command의 PATH를 찾지 못하고 계속 오류를 내고 있었다. (참고 : <a href="https://github.com/palantir/gradle-docker/issues/162">https://github.com/palantir/gradle-docker/issues/162</a>)<br>여러 시도를 하다가 포기하고 다른 plugin을 찾았는데 그것이 Google에서 만든 jib-gradle-plugin이다. 사용해본 결과, 정말 편하게 별다른 설정없이 docker에 application을 올릴 수 있었다. <a href="https://github.com/GoogleContainerTools/jib">jib github repo</a>에 들어가보면 maven plugin도 있으니 maven을 사용하신다면 한번 확인해보기 바란다.</p><h2 id="jib-gradle-plugin"><a href="#jib-gradle-plugin" class="headerlink" title="jib-gradle-plugin"></a>jib-gradle-plugin</h2><h3 id="Image-build"><a href="#Image-build" class="headerlink" title="Image build"></a>Image build</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">&#x27;com.google.cloud.tools.jib&#x27;</span> version <span class="string">&#x27;1.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>적용방법은 간단하다. build.gradle에 plugin으로 넣어주면 된다. 아무런 설정을 넣어주지 않는다면 image의 이름은 module 이름과 version 태그로 빌드된다. 물론 이름과 태깅 설정도 간단하다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bootJar &#123;</span><br><span class="line">    baseName = <span class="string">&#x27;service-1&#x27;</span></span><br><span class="line">    version =  <span class="string">&#x27;0.1.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jib &#123;</span><br><span class="line">    to &#123;</span><br><span class="line">      image = <span class="string">&quot;$&#123;bootJar.baseName&#125;:$&#123;bootJar.version&#125;&quot;</span></span><br><span class="line">      tags = [<span class="string">&#x27;latest&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>난 bootJar를 통해 만들어지는 jar 파일과 이름을 같게 하기 위해 위와 같이 설정했다. 위 설정으로 이미지를 빌드하면 service-1:0.1.0과 service01:latest 두 개의 태그가 만들어진다. </p><h3 id="Push-to-Docker-hub"><a href="#Push-to-Docker-hub" class="headerlink" title="Push to Docker hub"></a>Push to Docker hub</h3><p>Docker hub나 원하는 docker registry에 Push하는 것도 간단하다. jib github repo를 확인해보면 다양한 cloud service에 push하는 방법들이 나와있다. 난 Docker hub로 Push하도록 설정해보았다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ext.dockerId = <span class="string">&#x27;dlsrb6342&#x27;</span></span><br><span class="line"></span><br><span class="line">jib &#123;</span><br><span class="line">    to &#123;</span><br><span class="line">        image = <span class="string">&quot;$&#123;dockerId&#125;/$&#123;bootJar.baseName&#125;:$&#123;bootJar.version&#125;&quot;</span></span><br><span class="line">        username = <span class="string">&quot;USER_ID&quot;</span></span><br><span class="line">        password = <span class="string">&quot;PASSWORD&quot;</span></span><br><span class="line">        tags = [<span class="string">&#x27;latest&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>위의 이미지 및 태그 설정했던 부분에 docker hub ID를 넣어주고 username / password 값을 추가해주면 된다. 하지만 이 방법은 password가 다 노출될 수 있기 때문에 <a href="https://github.com/docker/docker-credential-helpers">docker-credential-helper</a>를 사용하기를 권장한다. docker-credential-helper를 사용하면 username과 password를 직접 적어두지 않아도 된다. 나는 OSX를 사용 중이기에 osxkeychain을 설치했다.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew install go</span><br><span class="line"><span class="built_in">export</span> GOPATH=/usr/<span class="built_in">local</span>/Cellar/go/1.12.7</span><br><span class="line">go get github.com/docker/docker-credential-helpers</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/docker/docker-credentials-helpers</span><br><span class="line">make osxkeychain</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$&#123;PATH:+<span class="variable">$&#123;PATH&#125;</span>:&#125;</span>/usr/local/Cellar/go/1.12.7/src/github.com/docker/docker-credential-helpers/bin&quot;</span></span><br></pre></td></tr></table></figure><br>go lang도 설치되어있지 않아 다 설치해주었다. 다 설치해주고 나서 <code>docker-credential-osxkeychain list</code>를 입력해보면 잘 설정되었는지 볼 수 있을 것이다. </p><p>여기서 하나 정리해야 하는것이 jib-gradle-plugin이 가지고있는 명령들이다. </p><ul><li>jib : Build your container image</li><li>jibBuildTar : You can build and save your image to disk as a tarball</li><li>jibDockerBuild : Jib can also build your image directly to a Docker daemon</li></ul><p>jibBuildTar는 이름 그래도 image를 tar 파일로 만들어주는 명령이다. jib과 jibDockerBuild는 하는 일은 거의 똑같다. 한 가지 다른 점은 jib은 docker hub와 같은 원격 registry에도 image를 push해준다는 점이다. jibDockerBuild를 사용하면 자신의 환경에 설치되어있는 docker command를 사용하기 때문에 local에만 image가 올라가게 된다.</p><p>우린 remote registry에 올릴 것이기 때문에 jib 명령을 사용하면 된다.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>코드는 <a href="https://github.com/dlsrb6342/blog-sample/tree/master/gradle-docker-example에">https://github.com/dlsrb6342/blog-sample/tree/master/gradle-docker-example에</a> 올려두었다. service1, service2 2개의 모듈이 있고 이를 jib-gradle-plugin으로 빌드하고 docker-compose를 사용해 두 모듈을 함께 실행해보는 예제이다.</p><p>위에 얘기한 설정들은 각 모듈의 build.gradle에서 확인할 수 있고 root project의 build.gradle을 보면 편의를 위해 직접 task를 추가해었다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task dockerDownAll(<span class="attr">type:</span>Exec) &#123;</span><br><span class="line">    commandLine <span class="string">&#x27;docker-compose&#x27;</span>, <span class="string">&#x27;down&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task dockerRunAll(<span class="attr">type:</span>Exec) &#123;</span><br><span class="line">    dependsOn dockerDownAll</span><br><span class="line">    dependsOn subprojects.jibDockerBuild</span><br><span class="line">    commandLine <span class="string">&#x27;docker-compose&#x27;</span>, <span class="string">&#x27;up&#x27;</span>, <span class="string">&#x27;-d&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>dockerRunAll : subprojects를 모두 이미지로 빌드하고 docker-compose를 사용해 실행시키는 명령</li><li>dockerDownAll : 모든 모듈을 중지시키는 명령</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./gradlew dockerRunAll</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Task :dockerRunAll</span></span><br><span class="line">Creating network &quot;gradle-docker-example_default&quot; with the default driver</span><br><span class="line">Creating service-1 ... </span><br><span class="line">Creating service-2 ... </span><br><span class="line">Creating service-2 ... done</span><br><span class="line">BUILD SUCCESSFUL in 30s</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">3053876b03ee        service-2:latest    &quot;java -cp /app/resou…&quot;   10 seconds ago      Up 7 seconds        0.0.0.0:8082-&gt;8082/tcp   service-2</span><br><span class="line">983cb559414e        service-1:latest    &quot;java -cp /app/resou…&quot;   10 seconds ago      Up 7 seconds        0.0.0.0:8081-&gt;8081/tcp   service-1</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> curl http://127.0.0.1:8081/toService2</span></span><br><span class="line">&#123;&quot;service2&quot;:&quot;success&quot;,&quot;service1&quot;:&quot;toService2-passed&quot;&#125;</span><br></pre></td></tr></table></figure><p>dockerRunAll 명령을 실행하게 되면 service1, service2 모듈이 실행되는 것을 볼 수 있다. </p><p>Docker hub에 push하는 방법은 각 모듈에서 jib 명령을 실행해주면 된다.<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./gradlew :service1:jib</span></span><br><span class="line">...</span><br><span class="line">Built and pushed image as dlsrb6342/service-1:0.1.0, dlsrb6342/service-1</span><br><span class="line">Executing tasks:</span><br><span class="line">[==============================] 100.0% complete</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 17s</span><br><span class="line">3 actionable tasks: 2 executed, 1 up-to-date</span><br></pre></td></tr></table></figure><br><img src="/2019/07/26/jib-gradle-plugin%EC%9C%BC%EB%A1%9C-spring-boot-application%EC%9D%84-Docker%EC%97%90-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/dockerhub.png" class="" title="docker hub"><br>push된 이미지는 Docker hub 페이지에서 확인할 수 있다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>com.palantir.docker plugin을 사용하면서 힘들었던 점이 많았다. Dockerfile을 작성하는 문법도 정확히 몰라서 계속 찾아봐야 했고 심지어 다 작성한 후에는 무슨 이유인지 모르게 docker command의 PATH를 찾지 못하는 이슈도 있었다. 이런 일이 있어서인지 jib-gradle-plugin은 정말 편하다는 느낌을 많이 받았다. java application을 docker image로 빌드할 때는 고민없이 이 plugin을 사용할 것 같다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Build container images for your Java applications.&lt;br&gt;&lt;a href=&quot;https://github.com/GoogleContainerTools/jib&quot;&gt;https://github.c
      
    
    </summary>
    
      <category term="build" scheme="https://dlsrb6342.github.io/categories/build/"/>
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/categories/build/gradle/"/>
    
      <category term="spring-boot" scheme="https://dlsrb6342.github.io/categories/build/gradle/spring-boot/"/>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/tags/gradle/"/>
    
      <category term="spring" scheme="https://dlsrb6342.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring-cloud-sleuth 예제로 살펴보기</title>
    <link href="https://dlsrb6342.github.io/2019/07/20/spring-cloud-sleuth-%EC%98%88%EC%A0%9C%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/"/>
    <id>https://dlsrb6342.github.io/2019/07/20/spring-cloud-sleuth-예제로-살펴보기/</id>
    <published>2019-07-20T08:36:43.000Z</published>
    <updated>2021-01-30T08:34:59.279Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring Cloud Sleuth implements a distributed tracing solution for Spring Cloud.</p></blockquote><p>오늘은 spring-cloud 프로젝트 중 분산형 추적 솔루션인 spring-cloud-sleuth에 대해 알아보려한다.<br>공식 문서 : <a href="https://cloud.spring.io/spring-cloud-sleuth/spring-cloud-sleuth.html">https://cloud.spring.io/spring-cloud-sleuth/spring-cloud-sleuth.html</a></p><h2 id="용어"><a href="#용어" class="headerlink" title="용어"></a>용어</h2><p>spring-cloud-sleuth는 <a href="https://ai.google/research/pubs/pub36356">Dapper</a>의 용어를 가져와서 사용하고 있다. 중요한 용어 몇가지만 정리하겠다.</p><h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>Span은 64 bit unique ID를 가지는 Tracing의 가장 기본 단위이다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSpan</span> <span class="keyword">extends</span> <span class="title">Span</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> TraceContext context;</span><br><span class="line">  <span class="keyword">final</span> PendingSpans pendingSpans;</span><br><span class="line">  <span class="keyword">final</span> MutableSpan state;</span><br><span class="line">  <span class="keyword">final</span> Clock clock;</span><br><span class="line">  <span class="keyword">final</span> FinishedSpanHandler finishedSpanHandler;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="https://github.com/openzipkin/brave">openzipkin/brave</a>에 있는 Span 구현체이다. context는 span이 속해있는 Trace에 대한 정보를 들고 있고 pendingSpans에는 report되기 전의 pending된 span들이 WeakConcurrentMap으로 담겨있다.<br>실제로 이 Span에 대한 정보를 담고 있는건 state이다. TraceContext를 제외한 시작시간 / local ip / remote ip / tags 등등 많은 정보를 들고 있다.</p><h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>Span을 설명할때 잠깐 언급된 Trace이다. Trace는 span들을 모아둔 것으로 tree와 비슷한 구조로 되어있다. Trace Id는 가장 처음 trace를 시작시킨 span의 ID와 같다.</p><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><p>Annotation은 어떤 이벤트가 발생하고 진행되는지에 대한 기록을 쓰인다. 하지만 <a href="https://github.com/openzipkin/brave">Brave</a>를 사용하면서 더이상 request에 대해 이벤트들을 기록할 필요가 없어졌다. </p><ul><li>cs : Client Sent. client가 request를 보낸 이벤트. span의 시작이다.</li><li>sr : Server Received. server가 request를 받는 이벤트. </li><li>ss : Server Sent. server가 request 처리를 완료한 이벤트.</li><li>cr “ Client Received. client가 response를 받는 이벤트. span의 종료이다.</li></ul><h2 id="Brave"><a href="#Brave" class="headerlink" title="Brave"></a>Brave</h2><p>spring-cloud-sleuth 2.0.0 version부터는 tracing instrumentation library인 <a href="https://github.com/openzipkin/brave">Brave</a>를 사용하고 있다.  sleuth는 더이상 context를 만들거나 관리하지 않고 그 일을 Brave에게 위임하였다. naming이나 tagging conventions도 Brave와 똑같게 변경하였다.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>이제 spring-cloud-sleuth를 실제로 사용해보면서 공부해보겠다. 예시 코드는 <a href="https://github.com/dlsrb6342/blog-sample/tree/master/spring-cloud-sleuth-example">https://github.com/dlsrb6342/blog-sample/tree/master/spring-cloud-sleuth-example</a> 에 올라가있다. 예시는 spring-webflux를 사용해서 만들려고 했지만 제대로 동작하질 않아서 힘들었다. 이틀정도 고생하면서 내가 뭘 잘못해서 안되는지 찾아봤다. 결론은 내 잘못은 아닌것으로 보인다. <a href="https://github.com/spring-cloud/spring-cloud-sleuth/issues/1402">spring-cloud-sleuth 이슈</a>로 등록해두었다. 아직 답변은 못 받았지만 버그인 것 같다. 예시 코드는 일단 webflux와 mvc 두개 모두 만들어두었다.</p><p>예시 코드의 구조는 간단하다. 4가지 application(fcaller, fclient, mcaller, mclient)을 만들고 모두 sleuth를 적용시켜두었다. zipkin 서버는 간단하게 docker에 띄우고 실행했다. <a href="http://localhost:9411에">http://localhost:9411에</a> 접근해보면 zipkin ui를 볼 수 있을 것이다.<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> docker run -d -p 9411:9411 openzipkin/zipkin</span></span><br></pre></td></tr></table></figure></p><h3 id="user-gt-mcaller-gt-mclient"><a href="#user-gt-mcaller-gt-mclient" class="headerlink" title="user -&gt; mcaller -&gt; mclient"></a>user -&gt; mcaller -&gt; mclient</h3><p>mcaller와 mclient는 spring-mvc를 사용해 구현한 application이다.<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> curl http://localhost:8082/mcaller</span></span><br><span class="line">&#123;&quot;mclient&quot;:&quot;client&quot;,&quot;mcaller&quot;:&quot;caller&quot;&#125;</span><br></pre></td></tr></table></figure><br>위 요청을 보내면 mcaller가 mclient에 요청을 보내고 받은 응답을 user에게 돌려준다. zipkin에도 해당 request가 정확히 tracing되었다.</p><img src="/2019/07/20/spring-cloud-sleuth-%EC%98%88%EC%A0%9C%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/mvc.png" class="" title="sleuth with mvc"><ol><li>mcaller가 user로부터 받은 요청으로 인해 생긴 “Server Start / Server finish” span</li><li>mcaller가 mclient를 호출하면서 생긴 “Client Start / Client finish” span</li><li>mclient가 mcaller로부터 받은 요청으로 인해 생긴 “Server Start / Server finish” span</li></ol><p>총 3개의 span이 생성되었고 문제없이 잘 동작하였다.</p><h3 id="user-gt-fcaller-gt-fclient"><a href="#user-gt-fcaller-gt-fclient" class="headerlink" title="user -&gt; fcaller -&gt; fclient"></a>user -&gt; fcaller -&gt; fclient</h3><p>fcaller와 fclient는 spring-weblfux로 만들었는데 위에 언급했듯이 정확하게 동작하지 않는다. Tracing정보를 넘겨주고 요청이 완료될 경우 report를 하고 있는 CoreSubscriber의 onComplete 함수가 제대로 호출되지 않고 있다.<br>자세한 예시와 내용에 대해서는 <a href="https://github.com/spring-cloud/spring-cloud-sleuth/issues/1402">https://github.com/spring-cloud/spring-cloud-sleuth/issues/1402</a> 여기서 확인하면 된다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>spring boot의 auto configuration 덕분에 spring-cloud-sleuth를 dependency에 넣어주고 zipkin uri만 넣어주는 것만으로도 쉽게 적용할 수 있었다. 하지만 spring-webflux에서는 제대로 동작하지 않을뿐만 아니라 성능상의 이슈도 있다고 한다( <a href="https://github.com/spring-cloud/spring-cloud-sleuth/issues/1397">https://github.com/spring-cloud/spring-cloud-sleuth/issues/1397</a> ). 성능이 중요한 webflux application을 개발할 때는 spring-cloud-sleuth를 적용하는 것에 대해 조금 고민이 필요할 것 같다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Spring Cloud Sleuth implements a distributed tracing solution for Spring Cloud.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;오늘은 spring-cloud 프로젝트 중
      
    
    </summary>
    
      <category term="spring-cloud" scheme="https://dlsrb6342.github.io/categories/spring-cloud/"/>
    
      <category term="spring-cloud-sleuth" scheme="https://dlsrb6342.github.io/categories/spring-cloud/spring-cloud-sleuth/"/>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
      <category term="spring" scheme="https://dlsrb6342.github.io/tags/spring/"/>
    
      <category term="spring-cloud" scheme="https://dlsrb6342.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Gradle Guide 3. Creating Multi-project Builds</title>
    <link href="https://dlsrb6342.github.io/2019/07/20/Gradle-Guide-3-Creating-Multi-project-Builds/"/>
    <id>https://dlsrb6342.github.io/2019/07/20/Gradle-Guide-3-Creating-Multi-project-Builds/</id>
    <published>2019-07-20T04:02:38.000Z</published>
    <updated>2021-01-30T08:34:59.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gradle-Guide-3-Creating-Multi-project-Builds"><a href="#Gradle-Guide-3-Creating-Multi-project-Builds" class="headerlink" title="Gradle Guide 3. Creating Multi-project Builds"></a>Gradle Guide 3. Creating Multi-project Builds</h1><blockquote><p>공식 가이드 : <a href="https://guides.gradle.org/creating-multi-project-builds/">https://guides.gradle.org/creating-multi-project-builds/</a></p></blockquote><p>이번 가이드에는 gradle로 멀티 모듈의 프로젝트를 만들고 빌드하는 것에 대해 배운다.</p><h2 id="Create-a-root-project"><a href="#Create-a-root-project" class="headerlink" title="Create a root project"></a>Create a root project</h2><p><a href="https://dlsrb6342.github.io/2019/07/14/Gradle-Guide-2-Create-new-Gradle-builds/">Gradle Guide 2</a>에서 했던 것처럼 <code>gradle init</code>으로 새로운 root project를 만들어준다. 자동생성된 많은 파일 중에 <code>settings.gradle</code>을 보면 rootProject.name이 잘 들어가 있을 것이다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gradle init</span></span><br><span class="line">Starting a Gradle Daemon (subsequent builds will be faster)</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 5s</span><br><span class="line">2 actionable tasks: 2 executed</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat settings.gradle</span></span><br><span class="line">rootProject.name = &#x27;gradle-3&#x27;</span><br></pre></td></tr></table></figure><h2 id="Configure-from-above"><a href="#Configure-from-above" class="headerlink" title="Configure from above"></a>Configure from above</h2><p>내가 멀티 프로젝트의 장점이라 생각하는 점 중에 하나는 공통의 dependency나 설정에 대해 root project에 한번에 쓸 수 있다는 점이다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subprojects &#123;</span><br><span class="line">    version = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="allprojects"><a href="#allprojects" class="headerlink" title="allprojects"></a>allprojects</h3><p>allprojects는 root를 포함한 모든 sub project들에 configuration을 추가하는 block이다. 위에서는 모든 project에 jcenter repository를 추가하였다.</p><h3 id="subprojects"><a href="#subprojects" class="headerlink" title="subprojects"></a>subprojects</h3><p>subprojects는 allprojects block에서 root를 제외한 설정이다. 위에서는 모든 sub project에 version을 1.0으로 설정하였다. </p><blockquote><p>다른 scripts block에 대해서는 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N159F0">gradle docs</a>를 보면 자세히 설명이 되어있다. </p></blockquote><h2 id="Add-a-Groovy-library-subproject"><a href="#Add-a-Groovy-library-subproject" class="headerlink" title="Add a Groovy library subproject"></a>Add a Groovy library subproject</h2><p>이제 sub project를 추가해보자. 가이드에서는 groovy library를 추가하는 방법에 대해 설명하고 있어서 groovy를 잘 모르지만 그냥 따라해봤다.</p><p>greeting-library란 폴더를 만들고 build.gradle 파일을 작성하였다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greeting-library/build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;groovy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&#x27;org.codehaus.groovy:groovy:2.4.10&#x27;</span></span><br><span class="line"></span><br><span class="line">    testCompile <span class="string">&#x27;org.spockframework:spock-core:1.0-groovy-2.4&#x27;</span>, &#123;</span><br><span class="line">        exclude <span class="attr">module:</span> <span class="string">&#x27;groovy-all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>이제 root project에 greeting-library를 포함시켜보자. 아까 rootProject.name이 쓰여있던 settings.gradle 파일에 써주면된다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name = <span class="string">&#x27;gradle-3&#x27;</span></span><br><span class="line">include <span class="string">&#x27;greeting-library&#x27;</span></span><br></pre></td></tr></table></figure><br>기본 폴더 구조인 src/main/groovy/greeter, src/main/test/groovy/greeter를 만들어주고 간단한 코드를 작성해준다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greeting-library/src/main/groovy/greeter/GreetingFormatter.groovy</span></span><br><span class="line"><span class="keyword">package</span> greeter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> groovy.transform.CompileStatic</span><br><span class="line"></span><br><span class="line"><span class="meta">@CompileStatic</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingFormatter</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> String greeting(<span class="keyword">final</span> String name) &#123;</span><br><span class="line">        <span class="string">&quot;Hello, $&#123;name.capitalize()&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><del>테스트코드는 건너뛰겠다..</del></p><p>다 작성한 후에 <code>./gradlew build</code>를 쓰면 greeting-library 모듈이 빌드되는 것을 볼 수 있을 것이다. gradle은 sub project의 build task가 있다는것을 자동으로 감지하고 그것을 실행해준다. 이 부분이 gradle multi project의 큰 장점 중 하나라고 한다.<br><strong><em>=&gt; Root project에 있는 task 이름과 같은 task가 sub project에 있다면 Gradle이 각각의 project의 같은 이름의 task를 함께 실행해줄 수 있다.</em></strong></p><h2 id="Add-a-Java-application-sub-project"><a href="#Add-a-Java-application-sub-project" class="headerlink" title="Add a Java application sub-project"></a>Add a Java application sub-project</h2><p>이번엔 java application을 추가한다. 똑같이 폴더를 만들고 build.gradle 작성, code 작성을 하면 된다. 물론 root project의 settings.gradle에도 sub project로 추가하여야 한다. 코드는 생략하고 github에 올려두었다.</p><p>위의 gradle project와 다른 점은 mainClassName을 설정해주어야 한다는 점이다. Java application 모듈이기 때문에 gradle에게 진입점(main 함수가 있는 class)를 알려주어야 한다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greeter/build.gradle</span></span><br><span class="line">mainClassName = <span class="string">&#x27;greeter.Greeter&#x27;</span></span><br></pre></td></tr></table></figure><br>또 greeter-library에 있는 GreetingFormatter를 사용하기 때문에 greeting-library를 greeter의 dependency로 추가해주어야 한다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greeter/build.gradle</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile project(<span class="string">&#x27;:greeting-library&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>두 sub project가 완성되었으니 이제 build를 해보자. 문제없이 sub project 모두 build가 잘 될것이다.<br><br/></p><hr><p><br/><br>본문 가이드에서는 Docs / Test 추가있지만 따로 다루진 않겠지만 한번 읽어보면 좋을 것 같다. 이 가이드 관련 코드는 <a href="https://github.com/dlsrb6342/gradle-study/tree/guide-3-multi-projects에">https://github.com/dlsrb6342/gradle-study/tree/guide-3-multi-projects에</a> 올려두었다. gradle guide를 공부하게 된 계기도 multi project를 구성하려다 막혀서 였는데 이 가이드를 통해서 어느정도 알아간 것 같다. scripts block에 대해서도 조금 찾아봐야 할 것 같다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gradle-Guide-3-Creating-Multi-project-Builds&quot;&gt;&lt;a href=&quot;#Gradle-Guide-3-Creating-Multi-project-Builds&quot; class=&quot;headerlink&quot; title=&quot;Grad
      
    
    </summary>
    
      <category term="build" scheme="https://dlsrb6342.github.io/categories/build/"/>
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/categories/build/gradle/"/>
    
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal vs. InheritableThreadLocal</title>
    <link href="https://dlsrb6342.github.io/2019/07/15/ThreadLocal-vs-InheritableThreadLocal/"/>
    <id>https://dlsrb6342.github.io/2019/07/15/ThreadLocal-vs-InheritableThreadLocal/</id>
    <published>2019-07-15T13:13:44.000Z</published>
    <updated>2021-01-30T08:34:59.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal-vs-InheritableThreadLocal"><a href="#ThreadLocal-vs-InheritableThreadLocal" class="headerlink" title="ThreadLocal vs. InheritableThreadLocal"></a>ThreadLocal vs. InheritableThreadLocal</h1><p>Thread.java 코드를 보면 아래와 같이 InheritableThreadLocal과 ThreadLocal이 따로 관리되는 것을 볼 수 있다. 둘의 차이가 무엇인지 확인해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment">     * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal은 이름에서도 알 수 있듯이 한 Thread의 scope내의 local variable이다. 하나의 Thread 안에서는 같은 값을 공유해서 사용한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성</span></span><br><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 저장</span></span><br><span class="line">threadLocal.set(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용</span></span><br><span class="line">threadLocal.get();</span><br></pre></td></tr></table></figure><br>사용법도 간단하다. 만들고 저장하고 쓰면 된다. </p><h3 id="활용"><a href="#활용" class="headerlink" title="활용"></a>활용</h3><p>보통 하나의 Request에 대한 정보들을 저장할 때 사용된다. </p><ul><li>spring-security : 사용자 인증 정보를 ThreadLocal에 담아서 전달해준다. </li><li>spring-web : RequestContextHolder가 요청의 Context를 ThreadLocal로 들고 있어 어디서든 꺼내쓸 수 있다.</li><li>mdc : Logging에 사용될 attribute를 ThreadLocal로 들고 있다.</li></ul><p>ThreadLocal은 spring-web을 사용할때는 문제가 되지 않았다. 하지만 reactive programming(spring-webflux)을 사용하게 되고 하나의 요청이 여러 Thread에서 처리될 수 있게 되면서 ThreadLocal이 문제가 되었다.</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><p>이름에서도 알 수 있듯이 <strong>Inheritable</strong>한 ThreadLocal이다. InheritableThreadLocal은 부모 Thread에서 생성된 자식 Thread에 그 값이 전달된다. 사용법은 ThreadLocal과 똑같다.<br>자식 Thread에도 그 값이 전달되기 때문에 Thread를 왔다갔다 할수도 있는 reactive programming에서도 문제없이 사용 가능하다.</p><h2 id="비교-테스트"><a href="#비교-테스트" class="headerlink" title="비교 테스트"></a>비교 테스트</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toAnotherThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">threadLocal.set(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">inheritableThreadLocal.set(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(String.format(</span><br><span class="line"><span class="string">&quot;Thread ID : %s / ThreadLocal : %s / InheritableThreadLocal : %s&quot;</span>,</span><br><span class="line">threadId, threadLocal.get(), inheritableThreadLocal.get()));</span><br><span class="line"></span><br><span class="line">Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line"><span class="keyword">long</span> anotherThreadId = Thread.currentThread().getId();</span><br><span class="line">System.out.println(String.format(</span><br><span class="line"><span class="string">&quot;Thread ID : %s / ThreadLocal : %s / InheritableThreadLocal : %s&quot;</span>,</span><br><span class="line">anotherThreadId, threadLocal.get(), inheritableThreadLocal.get()));</span><br><span class="line">&#125;).subscribeOn(Schedulers.elastic()).subscribe();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal과 InheritableThreadLocal을 비교하는 테스트이다. 부모 Thread에서 ThreadLocal과 InheritableThreadLocal를 모두 set해주고 자식 Thread에서 꺼내서 확인하는 코드이다. 다른 Thread를 실행하는 것은 reactor의 subscribeOn을 사용했다.<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread ID : 1 / ThreadLocal : test / InheritableThreadLocal : test</span><br><span class="line">Thread ID : 15 / ThreadLocal : null / InheritableThreadLocal : test</span><br></pre></td></tr></table></figure><br>결과는 이렇게 나온다. 부모 Thread에서는 두 값 모두 저장되어있지만 자식 Thread에서는 InheritableThreadLocal만 남아있다. </p><h2 id="InheritableThreadLocal-in-zipkin"><a href="#InheritableThreadLocal-in-zipkin" class="headerlink" title="InheritableThreadLocal in zipkin"></a>InheritableThreadLocal in zipkin</h2><p>InheritableThreadLocal은 spring-cloud-sleuth와 zipkin을 사용하다가 발견했다. zipkin은 다른 Thread로 넘어가도 문제가 없게 하기 위해 현재 span의 정보를 CurrentTraceContext에 InheritableThreadLocal에 담아서 들고 있고 새로운 Scope가 시작될때 바꿔주고 있다. zipkin에서 MDC도 활용하고 있기 때문에 MDC에 넣어주는 부분은 Slf4jScopeDecorator를 참고하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CurrentTraceContext.java</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">extends</span> <span class="title">ThreadLocalCurrentTraceContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;TraceContext&gt; INHERITABLE = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CurrentTraceContext <span class="title">inheritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Default();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Default() &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="keyword">new</span> Builder(), INHERITABLE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalCurrentTraceContext.java</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Scope <span class="title">newScope</span><span class="params">(<span class="meta">@Nullable</span> TraceContext currentSpan)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TraceContext previous = local.get();</span><br><span class="line">    local.set(currentSpan);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        local.set(previous);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Scope result = <span class="keyword">new</span> ThreadLocalScope();</span><br><span class="line">    <span class="keyword">return</span> decorateScope(currentSpan, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br/></p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>Reactive 환경에서는 InheritableThreadLocal을 사용하면 Servlet에서 RequestContext를 관리했던 것처럼 할 수 있을 것 같다. 하지만 reactor에서는 <code>subscriberContext()</code>를 제공하기 때문에 이것을 활용하는 것이 더 나을수도 있을 것 같다. 나중에 그 둘을 비교하는 글도 작성할 예정이다.<br>또 여러 글들을 보다보니 InheritableThreadLocal은 Servlet에서는 사용하면 좋지 않다는 얘기가 있다. 관련된 내용은 <a href="https://stackoverflow.com/questions/14498503/why-should-i-avoid-using-inheritablethreadlocal-in-servlets">https://stackoverflow.com/questions/14498503/why-should-i-avoid-using-inheritablethreadlocal-in-servlets</a> 이 링크에서 확인하면 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ThreadLocal-vs-InheritableThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal-vs-InheritableThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal vs. In
      
    
    </summary>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3rd ITEM 69 70 71</title>
    <link href="https://dlsrb6342.github.io/2019/07/14/Effective-Java-3rd-ITEM-69-70-71/"/>
    <id>https://dlsrb6342.github.io/2019/07/14/Effective-Java-3rd-ITEM-69-70-71/</id>
    <published>2019-07-14T06:20:49.000Z</published>
    <updated>2021-01-30T08:34:59.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ITEM-69-Use-exceptions-only-for-exceptional-conditions"><a href="#ITEM-69-Use-exceptions-only-for-exceptional-conditions" class="headerlink" title="ITEM 69. Use exceptions only for exceptional conditions"></a>ITEM 69. Use exceptions only for exceptional conditions</h1><p>예외는 이름 그대로 오직 예외 상황에서만 상황해야 한다. 절대로 일상적인 흐름을 제어하기 위해 사용되어서는 안된다. 일부러 예외를 만들고 그 예외를 catch하는 흐름을 만들어서는 안된다.</p><p>이런 원칙은 API 설계에도 똑같이 적용할 수 있다. 클라이언트가 정상적인 흐름에서 예외를 사용할 일은 없어야 한다. 특정 상황에서만 호출 가능한 <strong>상태 의존적 메서드</strong>는 <strong>상태 검사 메서드</strong>와 함께 제공되어야 한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 상태 의존적 메서드</span></span><br><span class="line">iterator.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 상태 검사 메서드</span></span><br><span class="line">iterator.hasNext();</span><br></pre></td></tr></table></figure><br>이런 상태 검사 메서드 대신 null같은 특정값 혹은 Optional은 return하는 방법도 있다.</p><ul><li>특정값? Optional? 상태 검사 메서드?</li></ul><ol><li>외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부요인으로 상태가 변할 수 있다면 Optional이나 특정값을 사용하자. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 상태가 변경될 수 있기 때문이다.</li><li>성능이 중요한 상황에서 상태 검사 메서드와 상태 의존적 메서드의 작업이 일부 중복된다면 Optional이나 특정값을 사용하자.</li><li>1번 2번을 제외한 모든 경우에 상태 검사 메서드가 더 낫다. 가독성도 좋고 버그를 발견하기도 쉽기 때문이다.<br><br/></li></ol><h1 id="ITEM-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors"><a href="#ITEM-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors" class="headerlink" title="ITEM 70. Use checked exceptions for recoverable conditions and runtime exceptions for programming errors"></a>ITEM 70. Use checked exceptions for recoverable conditions and runtime exceptions for programming errors</h1><p>throwable에는 검사 예외, 런타임 예외, 에러 3가지가 있다. 이중에 비검사 throwable에는 런ㅁ타임 예외와 에러가 있고 둘의 동작도 똑같다. 이 둘은 프로그램에서 잡을 필요가 없거나 잡으면 안되는 예외들이다. 또 비검사 throwable들은 모두 RuntimeException의 하위 클래스이다.</p><h3 id="검사-예외-런타임-예외-에러"><a href="#검사-예외-런타임-예외-에러" class="headerlink" title="검사 예외? 런타임 예외? 에러?"></a>검사 예외? 런타임 예외? 에러?</h3><ul><li>호출하는 쪽에서 catch하고 처리해야하는 상황이라면 검사 예외를 사용하라.</li><li>프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하라.</li><li>Exception / RuntimeException / Error 모두 상속하지 않은 throwable은 사용하지 말자.</li><li>검사 예외는 복구할 수 있는 조건일 때 사용하자.</li></ul><p><br/></p><h1 id="ITEM-71-Avoid-unnecessary-use-of-checked-exceptions"><a href="#ITEM-71-Avoid-unnecessary-use-of-checked-exceptions" class="headerlink" title="ITEM 71. Avoid unnecessary use of checked exceptions"></a>ITEM 71. Avoid unnecessary use of checked exceptions</h1><p>검사 예외를 과하게 사용하면 쓰기 불편한 API가 될 수 있다. 어떤 메서드가 검사 예외를 던진다면, 그것을 호출하는 클라이언트는 catch 블록을 두고 처리하거나 바깥으로 던져주는 코드를 작성해야 한다. 결국 사용자에게 부담을 주게 된다. </p><p>API를 제대로 사용해도 발생할 수 있는 예외이거나 의미있는 예외가 아니라면 비검사 예외를 사용하는 것이 좋다. 검사 예외 대신 Optional을 return하는 것도 방법이다. 상태 검사 메서드를 추가할 수 있지만 여러 단점이 존재해 적절하지 않을 수 있다.</p><p><strong>검사 예외는 프로그램의 안전성을 높여주지만 사용자에게 부담을 줄 수 있다. 비검사 예외를 사용하거나 Optional로 처리해보자</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ITEM-69-Use-exceptions-only-for-exceptional-conditions&quot;&gt;&lt;a href=&quot;#ITEM-69-Use-exceptions-only-for-exceptional-conditions&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="Effective Java 3rd" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/"/>
    
      <category term="10. Exceptions" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/10-Exceptions/"/>
    
    
      <category term="effective_java" scheme="https://dlsrb6342.github.io/tags/effective-java/"/>
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Gradle Guide 2. Create new Gradle builds</title>
    <link href="https://dlsrb6342.github.io/2019/07/14/Gradle-Guide-2-Create-new-Gradle-builds/"/>
    <id>https://dlsrb6342.github.io/2019/07/14/Gradle-Guide-2-Create-new-Gradle-builds/</id>
    <published>2019-07-14T05:40:56.000Z</published>
    <updated>2021-01-30T08:34:59.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gradle-Guide-2-Create-new-Gradle-builds"><a href="#Gradle-Guide-2-Create-new-Gradle-builds" class="headerlink" title="Gradle Guide 2. Create new Gradle builds"></a>Gradle Guide 2. Create new Gradle builds</h1><blockquote><p>공식 가이드 : <a href="https://guides.gradle.org/creating-new-gradle-builds/">https://guides.gradle.org/creating-new-gradle-builds/</a></p></blockquote><p>이번 가이드에서는 command line에서 gradle project를 생성하고 기본적인 명령어를 배운다.</p><h2 id="gradle-init"><a href="#gradle-init" class="headerlink" title="gradle init"></a>gradle init</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kotlin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gradle init --dsl kotlin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> groovy</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> gradle init</span></span><br><span class="line">Starting a Gradle Daemon (subsequent builds will be faster)</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 6s</span><br><span class="line">2 actionable tasks: 2 executed</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tree .</span></span><br><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">└── settings.gradle</span><br><span class="line"></span><br><span class="line">2 directories, 6 files</span><br></pre></td></tr></table></figure><ul><li>build.gradle : project의 configuration을 담고 있는 build script이다.</li><li>gradle-wrapper.jar : Gradle Wrapper을 들고있는 executable jar 이다.</li><li>gradle-wrapper.properties : Gradle Wrapper의 설정을 가진 파일이다.</li><li>gradlew : UNIX 계열에서 사용할 수 있는 Gradle Wrapper script이다.</li><li>gradlew.bat : Windows에서 사용할 수 있는 Gradle Wrapper script이다.</li><li>settings.gradle : gradle build를 위해 gradle을 설정하는 script이다.</li></ul><blockquote><p>Gradle Wrapper란 선언된 gradle version으로 gradle을 실행하는 script이다. 필요하다면 실행 전에 gradle 다운로드도 실행한다. gradle project의 빌드에는 Gradle Wrapper를 사용하도록 권장된다.</p></blockquote><h2 id="Task-Plugin"><a href="#Task-Plugin" class="headerlink" title="Task / Plugin"></a>Task / Plugin</h2><p>새로운 Task를 만들고 실행하는 방법에 대한 설명이 있지만 간단해서 생략하겠다. 여러가지 gradle task type을 알고 싶다면 <a href="https://docs.gradle.org/4.10.3/dsl/">Documentation</a>의 왼쪽 목록 중 Task Type을 보면 된다.</p><p>Plugin 적용은 이전에 작성한 <a href="https://dlsrb6342.github.io/2019/07/13/Gradle-Guide-1-Build-scan/">build-scan을 적용하는 글</a>을 참고하면 된다.</p><h2 id="Explore-build"><a href="#Explore-build" class="headerlink" title="Explore build"></a>Explore build</h2><ul><li><code>./gradlew tasks</code> : 사용 가능한 모든 task를 보는 명령이다.</li><li><code>./gradlew properties</code>: 프로젝트의 모든 properties를 보는 명령이다.</li></ul><h2 id="Debug-build"><a href="#Debug-build" class="headerlink" title="Debug build"></a>Debug build</h2><p>어떤 task든 실행할 때 <code>--scan</code> 옵션을 주면 build scan이 적용되어 웹UI로 task의 과정을 모두 디버깅할 수 있다. build scan을 적용하는 방법은 <a href="https://dlsrb6342.github.io/2019/07/13/Gradle-Guide-1-Build-scan/">이전 글</a>을 확인하면 알 수 있다.</p><p><br/><br>gradle project 생성했을 때의 기초적인 명령들을 알 수 있었다. <strong><code>./gradlew tasks</code>나 <code>./gradlew properties</code>는 정말 유용하게 사용할 수 있을 것 같다.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gradle-Guide-2-Create-new-Gradle-builds&quot;&gt;&lt;a href=&quot;#Gradle-Guide-2-Create-new-Gradle-builds&quot; class=&quot;headerlink&quot; title=&quot;Gradle Guide 2
      
    
    </summary>
    
      <category term="build" scheme="https://dlsrb6342.github.io/categories/build/"/>
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/categories/build/gradle/"/>
    
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle Guide 1. Build scan</title>
    <link href="https://dlsrb6342.github.io/2019/07/13/Gradle-Guide-1-Build-scan/"/>
    <id>https://dlsrb6342.github.io/2019/07/13/Gradle-Guide-1-Build-scan/</id>
    <published>2019-07-13T09:37:53.000Z</published>
    <updated>2021-01-30T08:34:59.180Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/07/13/Gradle-Guide-1-Build-scan/Gradle.png" class="" title="Gradle Logo"><p>gradle.. spring을 처음 사용했을때 gradle을 썼었다(뭣도모르고 좋다니 쓴 느낌). 그 이후부터는 항상 maven을 썼고 이제는 maven의 xml이 너무 편해졌다. 그래도 혼자 공부할때나 토이 프로젝트를 할 때는 gradle을 썼다. 하지만 <strong>갓</strong>텔리제이가 처음 initializing 해주는 gradle 파일로도 충분했기에 따로 공부할 생각을 안했다. </p><p>결국 항상 가져다만 쓰던 gradle에 발목이 잡혔다. 멀티모듈 프로젝트를 구성하고 root module의 build.gradle을 어떻게 사용하는지 찾아봤는데 도대체가 답변마다 다 가지각색으로 다르게 사용하고 있다. 이걸 보고나서 ‘아 이젠 공부하고 써야겠다’ 라는 마음이 들어 <a href="https://gradle.org/guides/#getting-started">gradle 공식문서의 guide</a>들을 공부하기로 했다.</p><p>가이드 공부에 사용된 gradle 프로젝트 IntelliJ spring initializr로 생성한 간단한 spring 프로젝트이다.<br><a href="https://github.com/dlsrb6342/gradle-study">https://github.com/dlsrb6342/gradle-study</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./gradlew --version</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 5.4.1</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2019-04-26 08:14:42 UTC</span><br><span class="line">Revision:     261d171646b36a6a28d5a19a69676cd098a4c19d</span><br><span class="line"></span><br><span class="line">Kotlin:       1.3.21</span><br><span class="line">Groovy:       2.5.4</span><br><span class="line">Ant:          Apache Ant(TM) version 1.9.13 compiled on July 10 2018</span><br><span class="line">JVM:          12.0.1 (Azul Systems, Inc. 12.0.1+12)</span><br><span class="line">OS:           Mac OS X 10.14.4 x86_64</span><br></pre></td></tr></table></figure></p><h1 id="Gradle-Guide-1-Creating-Build-Scans"><a href="#Gradle-Guide-1-Creating-Build-Scans" class="headerlink" title="Gradle Guide 1. Creating Build Scans"></a>Gradle Guide 1. Creating Build Scans</h1><blockquote><p>공식 가이드 : <a href="https://guides.gradle.org/creating-build-scans/">https://guides.gradle.org/creating-build-scans/</a></p></blockquote><p>1번부터 처음보는 것이다. 여태까지 정말 막 써 왔구나를 느낀다. </p><p>이 가이드에서는 별다른 수정이나 설정없이 build scan ad-hoc을 적용하는 방법에 대해 배운다.</p><h2 id="Upper-gradle-4-3"><a href="#Upper-gradle-4-3" class="headerlink" title="Upper gradle 4.3"></a>Upper gradle 4.3</h2><p>gradle 4.3 이후부터는 별다른 설정없이 <code>./gradlew build --scan</code>을 입력하면 build scan을 사용할 수 있다고 한다. 는 개구라였다 ㅋㅋㅋㅋ 안된다!!! gradle 관련 글들이 너무 가지각색이라 공식 문서로 찾아왔는데 공식문서도 안된다 ㅋㅋㅋㅋㅋㅋ <code>./gradlew build --help</code>를 쳐보니 build scan plugin을 넣어야한다고 한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./gradlew biuld --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">--scan    Creates a build scan. Gradle will emit a warning if the build scan plugin has not been applied. (https://gradle.com/build-scans)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>사실 이 글을 다 쓰고 build-scan plugin 제거하고 다시 <code>./gradlew build --scan</code>을 입력해봤는데 plugin없이도 된다.. 뭐가 문제였는지 모르겠다 ㅠㅠ</p><h2 id="build-scan-plugin"><a href="#build-scan-plugin" class="headerlink" title="build-scan plugin"></a>build-scan plugin</h2><p>추가하는 방법은 간단하다. build.gradle에 plugins 안에 넣어주면 된다. 만약 현재 사용중인 plugin이 있다면 build-sacn을 가장 위에 놓아야 한다. 아래 넣어도 똑같이 동작하지만 모든 build 과정을 scan하지 못하게 된다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.gradle.build-scan&#x27;</span> version <span class="string">&#x27;2.1&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>plugin을 추가하고 나서 <code>./gradlew build --scan</code>을 입력하면 잘 동작한다.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./gradlew build --scan</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Publishing a build scan to scans.gradle.com requires accepting the Gradle Terms of Service defined at https://gradle.com/terms-of-service. Do you accept these terms? [yes, no] yes</span><br><span class="line"></span><br><span class="line">Gradle Terms of Service accepted.</span><br><span class="line"></span><br><span class="line">Publishing build scan...</span><br><span class="line">https://gradle.com/s/&#123;어쩌구저쩌구&#125;</span><br></pre></td></tr></table></figure><br>아래 주소에 url에 들어가면 이메일 주소를 입력하게 되고 scan결과를 보여주는 url을 메일로 받을 수 있다. 보여주는 것도 깔끔하고 실행시간, 콜솔 로그 등등 엄청 많은 정보가 들어있어 디버깅하기 좋아보인다.</p><img src="/2019/07/13/Gradle-Guide-1-Build-scan/email.png" class="" title="Insert email"><img src="/2019/07/13/Gradle-Guide-1-Build-scan/discover.png" class="" title="Check your email"><img src="/2019/07/13/Gradle-Guide-1-Build-scan/scan.png" class="" title="Scan Result"><h2 id="License-Agreement"><a href="#License-Agreement" class="headerlink" title="License Agreement"></a>License Agreement</h2><p>build scan의 귀찮은 점은 build가 끝나고 항상 license agreement에 yes라고 타이핑해줘야 한다는 점이다. 이것 또한 항상 동의할 수 있도록 설정할 수 있다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">buildScan &#123;</span><br><span class="line">    termsOfServiceUrl = <span class="string">&#x27;https://gradle.com/terms-of-service&#x27;</span></span><br><span class="line">    termsOfServiceAgree = <span class="string">&#x27;yes&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br/><br>기존 프로젝트에 별다른 추가 사항은 없지만 따로 관리하기 위해 이번 build-scan 가이드는 <a href="https://github.com/dlsrb6342/gradle-study/tree/guide-1-build-scan에">https://github.com/dlsrb6342/gradle-study/tree/guide-1-build-scan에</a> 올려두었다.<br>gradle build가 너무 오래 걸리거나 혹은 오류를 뱉어낸다면 정말 유용한 툴이 될 수 있을 것 같다. <strong>첫 가이드부터 좋은 글인거 같아 다음 가이드들이 기대된다.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/07/13/Gradle-Guide-1-Build-scan/Gradle.png&quot; class=&quot;&quot; title=&quot;Gradle Logo&quot;&gt;
&lt;p&gt;gradle.. spring을 처음 사용했을때 gradle을 썼었다(뭣도모르고 좋다니
      
    
    </summary>
    
      <category term="build" scheme="https://dlsrb6342.github.io/categories/build/"/>
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/categories/build/gradle/"/>
    
    
      <category term="gradle" scheme="https://dlsrb6342.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3rd ITEM 66 67 68</title>
    <link href="https://dlsrb6342.github.io/2019/07/13/Effective-Java-3rd-ITEM-66-67-68/"/>
    <id>https://dlsrb6342.github.io/2019/07/13/Effective-Java-3rd-ITEM-66-67-68/</id>
    <published>2019-07-13T05:57:25.000Z</published>
    <updated>2021-01-30T08:34:59.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ITEM-66-Use-native-methods-judiciously"><a href="#ITEM-66-Use-native-methods-judiciously" class="headerlink" title="ITEM 66. Use native methods judiciously"></a>ITEM 66. Use native methods judiciously</h1><p>JNI(Java Native Interface)는 네이티브 메서드를 호출할 수 있게 해주는 기술이다. 네이티브 메서드란 C나 C++로 작성한 네이티브 프로그래밍 언어로 작성한 메서드를 말한다. 네이티브 메서드는 레지스트리같은 플랫폼 특화된 기능을 사용할때, 기존 라이브러리를 사용할때, 성능 개선을 목적으로 사용할때, 이렇게 3가지 경우에 주로 사용한다.</p><h3 id="1-플랫폼-특화된-기능-기존-라이브러리-사용"><a href="#1-플랫폼-특화된-기능-기존-라이브러리-사용" class="headerlink" title="1. 플랫폼 특화된 기능 / 기존 라이브러리 사용"></a>1. 플랫폼 특화된 기능 / 기존 라이브러리 사용</h3><p>자바가 발전하면서 OS같은 하부 플랫폼의 기능들을 점차 사용할 수 있게 되었다. java9에서 process API가 추가되어 OS process에 접근할 수 있게 되었다. 대체할만한 자바 라이브러리가 없을 경우엔 네이티브 메서드를 사용해야 한다.</p><h3 id="2-성능-개선"><a href="#2-성능-개선" class="headerlink" title="2. 성능 개선"></a>2. 성능 개선</h3><p>성능 개선을 목적으로 사용하는건 권장하지 않는다. JVM의 발전으로 네이티브 구현보다도 빨라진 부분도 있다.<br><br/><br>네이티브 메서드는 안전하지 않아 메모리 훼손 오류가 있을 수 있고 플랫폼을 많이 타서 이식성도 낮다. 디버깅도 어렵고 속도가 오히려 느려질 수 있다. 네이티브 메모리는 GC가 자동회수 하지 못하고 추적도 못해 위험할 수 있다. 네이티브 메서드와 자바 코드 사이의 접착 코드도 작성해야 하며, 넘나들때 비용도 추가된다. </p><p><strong><em>=&gt; 네이티브 메서드를 사용하려거든 다시 한번 더 생각해보자.</em></strong><br><br/></p><h1 id="ITEM-67-Optimize-judiciously"><a href="#ITEM-67-Optimize-judiciously" class="headerlink" title="ITEM 67. Optimize judiciously"></a>ITEM 67. Optimize judiciously</h1><p>성능 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고 프로그램의 견고한 구조를 망가뜨릴 수 있다.<br><strong><em>=&gt; 빠른 프로그램보다는 좋은 프로그램을 작성하자.</em></strong></p><h3 id="아키텍처-성능"><a href="#아키텍처-성능" class="headerlink" title="아키텍처 - 성능"></a>아키텍처 - 성능</h3><p>그렇다고 성능을 무시하라는 것이 아니다. 최적화는 나중에 해결할 수 있지만 아키텍처가 망가지면 선능을 제한할 수 있다. 또 성능을 위해 아키텍처 설계의 기본 틀을 변경하려다 보면 유지보수가 어려운 구조의 시스템이 만들어지기 쉽다. 따라서 아키텍처 설계 과정에서 성능을 반드시 염두해야 한다. </p><ol><li>성능을 제한하는 설계를 피하라.</li><li>API를 설계할 때 성능에 주는 영향을 고려하라.</li><li>신중한 설계로 멋진 구조를 갖춘 프로그램을 완성한 후에 성능 최적화를 생각하자.</li><li>각각의 최적화 시도 전후로 성능을 측정하라.</li></ol><p><br/></p><h1 id="ITEM-68-Adhere-to-generally-accepted-naming-conventions"><a href="#ITEM-68-Adhere-to-generally-accepted-naming-conventions" class="headerlink" title="ITEM 68. Adhere to generally accepted naming conventions"></a>ITEM 68. Adhere to generally accepted naming conventions</h1><h3 id="패키지"><a href="#패키지" class="headerlink" title="패키지"></a>패키지</h3><ul><li>각 요소를 점(.)으로 구분하여 계층적으로 짓는다.</li><li>모두 소문자 알파벳 혹은 숫자로 이뤄진다.</li><li>8자 이하의 짧은 단어로 한다.</li></ul><h3 id="클래스와-인터페이스"><a href="#클래스와-인터페이스" class="headerlink" title="클래스와 인터페이스"></a>클래스와 인터페이스</h3><ul><li>하나 이상의 단어로 이뤈진다.</li><li>각 단어는 대문자로 시작한다.</li><li>통용되는 줄임말을 제외하고는 줄여 쓰지 않는다.</li></ul><h3 id="메서드와-필드-이름"><a href="#메서드와-필드-이름" class="headerlink" title="메서드와 필드 이름"></a>메서드와 필드 이름</h3><ul><li>첫글자를 소문자로 쓴다.</li><li>나머지 규칙은 클래스와 같다.</li></ul><h3 id="상수-필드"><a href="#상수-필드" class="headerlink" title="상수 필드"></a>상수 필드</h3><ul><li>모두 대문자로 쓰며 단어 사이는 밑줄로 구분한다.</li></ul><h3 id="타입-매개변수"><a href="#타입-매개변수" class="headerlink" title="타입 매개변수"></a>타입 매개변수</h3><ul><li>보통 한문자로 표현한다.</li><li>T : Type / E : Element / K : Key / V : Value / X : eXception / R : Return</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ITEM-66-Use-native-methods-judiciously&quot;&gt;&lt;a href=&quot;#ITEM-66-Use-native-methods-judiciously&quot; class=&quot;headerlink&quot; title=&quot;ITEM 66. Use nat
      
    
    </summary>
    
      <category term="Effective Java 3rd" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/"/>
    
      <category term="9. General Programming" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/9-General-Programming/"/>
    
    
      <category term="effective_java" scheme="https://dlsrb6342.github.io/tags/effective-java/"/>
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3rd ITEM 63 64 65</title>
    <link href="https://dlsrb6342.github.io/2019/07/13/Effective-Java-3rd-ITEM-63-64-65/"/>
    <id>https://dlsrb6342.github.io/2019/07/13/Effective-Java-3rd-ITEM-63-64-65/</id>
    <published>2019-07-13T05:40:42.000Z</published>
    <updated>2021-01-30T08:34:59.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ITEM-63-Beware-the-performance-of-string-concatenation"><a href="#ITEM-63-Beware-the-performance-of-string-concatenation" class="headerlink" title="ITEM 63. Beware the performance of string concatenation"></a>ITEM 63. Beware the performance of string concatenation</h1><p>문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례한다.<br>=&gt; StringBuilder를 사용하자!</p><p><br/></p><h1 id="ITEM-64-Refer-to-objects-by-their-interfaces"><a href="#ITEM-64-Refer-to-objects-by-their-interfaces" class="headerlink" title="ITEM 64. Refer to objects by their interfaces"></a>ITEM 64. Refer to objects by their interfaces</h1><p>매개변수 반환값 변수 필드 등 전부 인터페이스 타입으로 선언하는 것이 좋다. 프로그램을 훨씬 유연하게 만들 수 있다.<br>적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 <strong>덜 구체적인</strong> 클래스를 타입으로 사용하자!</p><p><br/></p><h1 id="ITEM-65-Prefer-interfaces-to-reflection"><a href="#ITEM-65-Prefer-interfaces-to-reflection" class="headerlink" title="ITEM 65. Prefer interfaces to reflection"></a>ITEM 65. Prefer interfaces to reflection</h1><p>리플렉션(java.lang.reflect)를 사용하면 클래스의 생성자 메서드 필드에 해당하는 인스턴스를 꺼낼 수 있고 그에 해당하는 정보를 가져올 수 있다. 클래스의 거의 모든 것을 조작하고 호출할 수 있다.</p><h3 id="리플렉션의-단점"><a href="#리플렉션의-단점" class="headerlink" title="리플렉션의 단점"></a>리플렉션의 단점</h3><ol><li>컴파일타임의 타입 검사의 이점을 누릴 수 없다.</li><li>코드가 지저분해지고 장황해진다.</li><li>성능이 떨어진다. </li></ol><p>컴파일 타임에 알 수 없는 클래스를 사용해야 한다면 리플렉션을 사용할 수 밖에 없을 것이다. 이 경우에도 객체 생성에만 리플렉션을 사용하고 객체를 사용할 때는 적절한 인터페이스나 상위 클래스로 사용하자.<br><strong><em>=&gt; 리플렉션은 단점을 피하고 이점만 취할 수 있는 아주 제한된 형태로만 사용하자!</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ITEM-63-Beware-the-performance-of-string-concatenation&quot;&gt;&lt;a href=&quot;#ITEM-63-Beware-the-performance-of-string-concatenation&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="Effective Java 3rd" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/"/>
    
      <category term="9. General Programming" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/9-General-Programming/"/>
    
    
      <category term="effective_java" scheme="https://dlsrb6342.github.io/tags/effective-java/"/>
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3rd ITEM 60 61 62</title>
    <link href="https://dlsrb6342.github.io/2019/07/10/Effective-Java-3rd-ITEM-60-61-62/"/>
    <id>https://dlsrb6342.github.io/2019/07/10/Effective-Java-3rd-ITEM-60-61-62/</id>
    <published>2019-07-10T13:44:50.000Z</published>
    <updated>2021-01-30T08:34:59.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ITEM-60-Avoid-float-and-double-if-exact-answers-are-required"><a href="#ITEM-60-Avoid-float-and-double-if-exact-answers-are-required" class="headerlink" title="ITEM 60. Avoid float and double if exact answers are required"></a>ITEM 60. Avoid float and double if exact answers are required</h1><p>float와 double은 부동소수점 연산에 쓰이고 과학과 공학 계산용으로 설계되었다. 따라서 정확한 결과가 필요할 때는 적절치 않다. 따라서 올바른 값을 얻기 위해서는 BigDecimal이나 int 혹은 long을 사용해야 한다. </p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>BigDecimal은 정확한 값을 얻을 수 있지만 기본 타입보다 쓰기 불편하고 느리다. 그 대안으로 int 혹은 long을 쓸 수 있다. </p><h3 id="int-혹은-long"><a href="#int-혹은-long" class="headerlink" title="int 혹은 long"></a>int 혹은 long</h3><p>int 혹은 long은 정확한 값을 얻을 수 있고 기본 타입이라 편하고 속도도 좋다. 하지만 값의 크기가 제한되고 소수점을 직접 관리해야 한다.<br><br/></p><h1 id="ITEM-61-Prefer-primitive-types-to-boxed-primitives"><a href="#ITEM-61-Prefer-primitive-types-to-boxed-primitives" class="headerlink" title="ITEM 61. Prefer primitive types to boxed primitives"></a>ITEM 61. Prefer primitive types to boxed primitives</h1><h3 id="기본-타입과-박싱된-기본-타입의-차이"><a href="#기본-타입과-박싱된-기본-타입의-차이" class="headerlink" title="기본 타입과 박싱된 기본 타입의 차이"></a>기본 타입과 박싱된 기본 타입의 차이</h3><ul><li>기본 타입은 값만 / 박싱된 기본 타입은 값과 식별성을 갖는다.</li><li>기본 타입의 값은 언제나 유효 / 박싱된 기본 타입은 null을 가질 수 있다.</li><li>기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.</li></ul><h3 id="주의할점"><a href="#주의할점" class="headerlink" title="주의할점"></a>주의할점</h3><ul><li>박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.</li><li>기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 오토언박싱이 일어나 NPE가 발생할 수 있다.</li><li>박싱과 언박싱이 반복해서 일어나면 성능이 굉장히 느려진다.</li></ul><p><br/></p><h1 id="ITEM-62-Avoid-strings-where-other-types-are-more-appropriate"><a href="#ITEM-62-Avoid-strings-where-other-types-are-more-appropriate" class="headerlink" title="ITEM 62. Avoid strings where other types are more appropriate"></a>ITEM 62. Avoid strings where other types are more appropriate</h1><ul><li>문자열은 다른 값 타입(boolean / int / long …)을 대신하기에 적합하지 않다. </li><li>문자열은 열거 타입을 대신하기에 적합하지 않다.</li><li>문자열은 혼합 타입을 대신하기에 적합하지 않다. </li><li>문자열은 권한을 표현하기에 적합하지 않다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ITEM-60-Avoid-float-and-double-if-exact-answers-are-required&quot;&gt;&lt;a href=&quot;#ITEM-60-Avoid-float-and-double-if-exact-answers-are-required
      
    
    </summary>
    
      <category term="Effective Java 3rd" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/"/>
    
      <category term="9. General Programming" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/9-General-Programming/"/>
    
    
      <category term="effective_java" scheme="https://dlsrb6342.github.io/tags/effective-java/"/>
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3rd ITEM 57 58 59</title>
    <link href="https://dlsrb6342.github.io/2019/07/10/Effective-Java-3rd-ITEM-57-58-59/"/>
    <id>https://dlsrb6342.github.io/2019/07/10/Effective-Java-3rd-ITEM-57-58-59/</id>
    <published>2019-07-10T13:10:59.000Z</published>
    <updated>2021-01-30T08:34:59.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ITEM-57-Minimize-the-scope-of-local-variables"><a href="#ITEM-57-Minimize-the-scope-of-local-variables" class="headerlink" title="ITEM 57. Minimize the scope of local variables"></a>ITEM 57. Minimize the scope of local variables</h1><p>지역변수의 범위를 최소화하면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.</p><ul><li>지역 변수가 가장 처음 쓰일 때 선언하자. </li><li>거의 모든 지역변수는 선언과 동시에 초기화하자. </li><li>메서드를 작게 유지하고 한 가지 기능에 집중하자.<br><br/></li></ul><h1 id="ITEM-58-Prefer-for-each-loops-to-traditional-for-loops"><a href="#ITEM-58-Prefer-for-each-loops-to-traditional-for-loops" class="headerlink" title="ITEM 58. Prefer for-each loops to traditional for loops"></a>ITEM 58. Prefer for-each loops to traditional for loops</h1><p>Iterator를 사용한 for문이나 인덱스 변수로인한 for문은 코드를 지저분하게 하고 오류가 생길 가능성이 높아진다. 또 컬렉션 / 배열에 따라 코드 형태도 달라지는 문제점이 있다.</p><p>for-each문을 사용하면 이 모든 문제를 해결할 수 있다. 또한 for-each문은 사람이 손으로 최적화한 것과 같은 성능을 낸다.<br><br/></p><h1 id="ITEM-59-Know-and-use-the-libraries"><a href="#ITEM-59-Know-and-use-the-libraries" class="headerlink" title="ITEM 59. Know and use the libraries"></a>ITEM 59. Know and use the libraries</h1><h2 id="표준-라이브러리-사용의-이점"><a href="#표준-라이브러리-사용의-이점" class="headerlink" title="표준 라이브러리 사용의 이점"></a>표준 라이브러리 사용의 이점</h2><ul><li>그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다. </li><li>핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.</li><li>따로 노력하지 않아도 성능이 지속해서 개선된다.</li><li>기능이 점점 많아진다.</li><li>우리가 작성한 코드가 많은 사람에게 낯익은 코드가 된다.</li></ul><p>java.lang / java.util / java.io 는 잘 알아두자! 특히 java.util.stream / java.util.Collections / java.util.concurrent는 능숙하게 다룰 수 있게 하자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ITEM-57-Minimize-the-scope-of-local-variables&quot;&gt;&lt;a href=&quot;#ITEM-57-Minimize-the-scope-of-local-variables&quot; class=&quot;headerlink&quot; title=&quot;IT
      
    
    </summary>
    
      <category term="Effective Java 3rd" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/"/>
    
      <category term="9. General Programming" scheme="https://dlsrb6342.github.io/categories/Effective-Java-3rd/9-General-Programming/"/>
    
    
      <category term="effective_java" scheme="https://dlsrb6342.github.io/tags/effective-java/"/>
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Content Logging</title>
    <link href="https://dlsrb6342.github.io/2019/07/02/Spring-Content-Logging/"/>
    <id>https://dlsrb6342.github.io/2019/07/02/Spring-Content-Logging/</id>
    <published>2019-07-02T12:55:05.000Z</published>
    <updated>2021-01-30T08:34:59.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Content-Logging"><a href="#Spring-Content-Logging" class="headerlink" title="Spring Content Logging"></a>Spring Content Logging</h1><p>요구사항은 간단하다. Request body와 Response body를 로깅하는 것이다. 생각보다 간단했다.</p><h2 id="Servlet-Wrapper"><a href="#Servlet-Wrapper" class="headerlink" title="Servlet Wrapper"></a>Servlet Wrapper</h2><p>spring boot에서는 기본적으로 <a href="https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/catalina/connector/RequestFacade.html">RequestPacade</a> / <a href="https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/catalina/connector/ResponseFacade.html">ResponsePacade</a>로 SevletRequest / ServletResponse가 들어온다. 이를 Content Caching Wrapper로 감싸주기만 하면 된다.</p><p>spring-web에 이미 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/util/ContentCachingRequestWrapper.java">ContentCachingRequestWrapper</a>와 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/util/ContentCachingResponseWrapper.java">ContentCachingResponseWrapper</a>가 구현되어있다.<br>물론 원하는대로 직접 구현해도 되지만 spring이 예쁘게 구현해두었으니 활용해보자.</p><h3 id="CustomServletWrapperFilter"><a href="#CustomServletWrapperFilter" class="headerlink" title="CustomServletWrapperFilter"></a>CustomServletWrapperFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomServletWrappingFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HttpServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ContentCachingRequestWrapper wrappingRequest = <span class="keyword">new</span> ContentCachingRequestWrapper(request);</span><br><span class="line">        ContentCachingResponseWrapper wrappingResponse = <span class="keyword">new</span> ContentCachingResponseWrapper(response);</span><br><span class="line"></span><br><span class="line">        chain.doFilter(wrappingRequest, wrappingResponse);</span><br><span class="line"></span><br><span class="line">        wrappingResponse.copyBodyToResponse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet을 wrapping해주는 filter를 구현했다. OncePerRequestFilter를 상속받아 한 reuqest당 한번의 실행만 되도록 보장하였다. spring bean으로 등록해두면 Filter 적용은 끝난다.</p><p>가장 중요한 점은 마지막 줄에 있다. <code>wrappingResponse.copyBodyToResponse()</code>로 실제 response body에다가 값을 넣어주어야 한다. 이 코드를 안넣어주면 클라이언트가 아무 응답도 받지 못하게 된다.</p><h3 id="LoggingInterceptor"><a href="#LoggingInterceptor" class="headerlink" title="LoggingInterceptor"></a>LoggingInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ContentCachingRequestWrapper cachingRequest = (ContentCachingRequestWrapper) request;</span><br><span class="line">        <span class="keyword">final</span> ContentCachingResponseWrapper cachingResponse = (ContentCachingResponseWrapper) response;</span><br><span class="line"></span><br><span class="line">        log.info(</span><br><span class="line">                <span class="string">&quot;ReqBody : &#123;&#125; / ResBody : &#123;&#125;&quot;</span>,</span><br><span class="line">                objectMapper.readTree(cachingRequest.getContentAsByteArray()),</span><br><span class="line">                objectMapper.readTree(cachingResponse.getContentAsByteArray())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logging은 interceptor로 구현하였다. 이 코드는 간단하게 구현하느라 validation들을 모두 제외하였다. 직접 구현할 때는 wrapping이 안됐을 경우나 caching된 content가 없을 경우 등, 검증해야 할 부분이 많다.<br>caching된 content는 byte array로 들고 있기 때문에 objectMapper를 이용해 JsonNode로 읽어주고 로깅했다. </p><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>Sample code는 <a href="https://github.com/dlsrb6342/blog-sample/tree/master/spring-content-caching">https://github.com/dlsrb6342/blog-sample/tree/master/spring-content-caching</a> 에서 확인할 수 있다.<br>아래 예시와 같이 request body / response body logging을 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; request</span><br><span class="line">curl -X POST \</span><br><span class="line">  http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;test \</span><br><span class="line">  -H &#39;Content-Type: application&#x2F;json&#39; \</span><br><span class="line">  -d &#39;&#123;</span><br><span class="line">&quot;foo&quot;: &quot;foo&quot;,</span><br><span class="line">&quot;bar&quot;: &quot;bar&quot;</span><br><span class="line">&#125;&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; response</span><br><span class="line">&#123;&quot;result&quot;:&quot;test&quot;,&quot;code&quot;:100&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; logging result</span><br><span class="line">2019-07-02 22:44:21.195  INFO 15920 --- [nio-8080-exec-1] c.c.caching.demo.LoggingInterceptor      : ReqBody : &#123;&quot;foo&quot;:&quot;foo&quot;,&quot;bar&quot;:&quot;bar&quot;&#125; &#x2F; ResBody : &#123;&quot;result&quot;:&quot;test&quot;,&quot;code&quot;:100&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Content-Logging&quot;&gt;&lt;a href=&quot;#Spring-Content-Logging&quot; class=&quot;headerlink&quot; title=&quot;Spring Content Logging&quot;&gt;&lt;/a&gt;Spring Content Loggi
      
    
    </summary>
    
      <category term="spring-mvc" scheme="https://dlsrb6342.github.io/categories/spring-mvc/"/>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
      <category term="spring" scheme="https://dlsrb6342.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring-cloud-gateway Custom Filter</title>
    <link href="https://dlsrb6342.github.io/2019/06/30/spring-cloud-gateway-Custom-Filter/"/>
    <id>https://dlsrb6342.github.io/2019/06/30/spring-cloud-gateway-Custom-Filter/</id>
    <published>2019-06-30T14:01:11.000Z</published>
    <updated>2021-01-30T08:34:59.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-cloud-gateway-Custom-Filter"><a href="#spring-cloud-gateway-Custom-Filter" class="headerlink" title="spring-cloud-gateway Custom Filter"></a>spring-cloud-gateway Custom Filter</h1><p>spring-cloud-gateway에서 Custom Filter 추가하는 방법에 대해 정리해보았다.</p><h2 id="Add-shortcutField"><a href="#Add-shortcutField" class="headerlink" title="Add shortcutField"></a>Add shortcutField</h2><p>spring-cloud-gateway를 쓰면서 정말 편하다고 생각했던 부분은 yml에도 custom으로 추가한 Filter나 Predicate를 쓸 수 있다는 점이다.<br><code>**GatewayFilterFactory</code> / <code>**RoutePredicateFactory</code>라고 이름을 지어줬다면 postfix를 제거한 이름으로 yml에서 사용할 수 있다. 물론 Bean으로 등록해줘야 한다.</p><p>여기서 더 발전하여 custom Factory에서도 shortcut field를 사용할 수 있다.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shortcut field</span></span><br><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">StripPrefix=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># without shortcut field</span></span><br><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">StripPrefix</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">      <span class="attr">parts:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><br>위 yaml은 기본구현체인 StripPrefixGatewayFilterFactory를 shortcut을 쓴 예시와 안쓴 예시의 설정이다. shortcut field를 쓰면 조금 더 간단하게 설정을 할 수가 있다.<br>이를 구현하는것은 간단하다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomGatewayFilterFactory</span> </span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractGatewayFilterFactory</span>&lt;<span class="title">Config</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOO_KEY = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BAR_KEY = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">shortcutFieldOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(FOO_KEY, BAR_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String foo;</span><br><span class="line">        <span class="keyword">private</span> String bar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom=foo_value,bar_value</span></span><br></pre></td></tr></table></figure><br><code>shortcutFieldOrder()</code>를 override해주면 된다. 반환값은 Config class의 field의 이름들을 담은 리스트이다. 마지막줄의 주석처럼 yaml 설정 파일에서 foo의 값, bar의 값을 순서대로 넣어주면 된다!<br>shortcut field를 사용하면 간단해서 좋긴 하지만, 그 값이 무슨 field를 뜻하는지 한눈에 보기 어려운 단점이 있는듯하다. field가 하나이거나 의미가 명확한 경우 사용하면 좋을 것 같다.</p><h2 id="Add-Order"><a href="#Add-Order" class="headerlink" title="Add Order"></a>Add Order</h2><p>spring-cloud-gateway에서는 filter들에게 순서를 줄 수 있다. 명시해주지 않는다면 yaml 설정에 적어준 순서대로 0, 1, 2, … 의 order 값을 받게 된다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RouteDefinitionRouteLocator.java</span></span><br><span class="line">ArrayList&lt;GatewayFilter&gt; ordered = <span class="keyword">new</span> ArrayList&lt;&gt;(filters.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filters.size(); i++) &#123;</span><br><span class="line">GatewayFilter gatewayFilter = filters.get(i);</span><br><span class="line"><span class="keyword">if</span> (gatewayFilter <span class="keyword">instanceof</span> Ordered) &#123;</span><br><span class="line">ordered.add(gatewayFilter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ordered.add(<span class="keyword">new</span> OrderedGatewayFilter(gatewayFilter, i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Order-Ordered"><a href="#Order-Ordered" class="headerlink" title="@Order / Ordered"></a>@Order / Ordered</h3><p>custom filter에 순서를 넣어주고자 할때 가장 먼저 드는 생각은 <code>@Order</code> annotation이나 <code>Ordered</code>를 implement하는 것일 것이다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(100)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomGatewayFilterFactory</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomGatewayFilterFactory</span> <span class="title">implement</span> <span class="title">Ordered</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><br>하지만 이런 방법은 filter에 순서를 넣어주지 못한다. Filter가 아닌 FilterFactory에게 순서를 넣어줬을 뿐이다. <strong>따라서 이를 위해 spring-cloud-gateway가 지원하는 <code>OrderedGatewayFilter</code>를 사용해야 한다.</strong></p><h3 id="OrderedGatewayFilter"><a href="#OrderedGatewayFilter" class="headerlink" title="OrderedGatewayFilter"></a>OrderedGatewayFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomGatewayFilterFactory</span> </span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractGatewayFilterFactory</span>&lt;<span class="title">Config</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Config config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedGatewayFilter((exchange, chain) -&gt; &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예시는 가장 높은 우선순위를 주어 구현한 OrderedGatewayFilter이다. 이 GatewayFilterFacotyr를 사용하면 가장 먼저 이 filter를 타게 된다.<br>사실 난 처음엔 <code>OrderedGatewayFilter</code>의 존재를 몰랐고 왜 GatewayFilterFactory의 Order를 받지 않는지 의문이 생겼었다. 그래서 spring-cloud-gateway에 <a href="https://github.com/spring-cloud/spring-cloud-gateway/issues/1122">issue</a>를 남겼었다. 올리고나서 OrderedGatewayFilter를 발견했고 코멘트로도 이것을 사용하라는 가이드를 받았다.</p><h2 id="Sample-Source-Code"><a href="#Sample-Source-Code" class="headerlink" title="Sample Source Code"></a>Sample Source Code</h2><p><a href="https://github.com/dlsrb6342/blog-sample/tree/master/spring-cloud-gateway-custom-filter">https://github.com/dlsrb6342/blog-sample/tree/master/spring-cloud-gateway-custom-filter</a><br>ShortCut field와 OrderedGatewayFilter를 사용한 sample custom filter code이다. 가장 높은 우선순위를 준 filter가 설정에 상관없이 항상 먼저 실행되는 것을 확인할 수 있을 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-cloud-gateway-Custom-Filter&quot;&gt;&lt;a href=&quot;#spring-cloud-gateway-Custom-Filter&quot; class=&quot;headerlink&quot; title=&quot;spring-cloud-gateway Cus
      
    
    </summary>
    
      <category term="spring-cloud" scheme="https://dlsrb6342.github.io/categories/spring-cloud/"/>
    
      <category term="spring-cloud-gateway" scheme="https://dlsrb6342.github.io/categories/spring-cloud/spring-cloud-gateway/"/>
    
    
      <category term="java" scheme="https://dlsrb6342.github.io/tags/java/"/>
    
      <category term="spring" scheme="https://dlsrb6342.github.io/tags/spring/"/>
    
      <category term="spring-cloud" scheme="https://dlsrb6342.github.io/tags/spring-cloud/"/>
    
  </entry>
  
</feed>
